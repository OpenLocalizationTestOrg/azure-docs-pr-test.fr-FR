---
title: "Liste de contrôle des performances et de l’extensibilité d’Azure Storage | Microsoft Docs"
description: "Une liste des pratiques éprouvées à utiliser avec Azure Storage dans le développement d’applications performantes."
services: storage
documentationcenter: 
author: robinsh
manager: timlt
editor: tysonn
ms.assetid: 959d831b-a4fd-4634-a646-0d2c0c462ef8
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 12/08/2016
ms.author: robinsh
ms.openlocfilehash: d2683bf9a2833485467bf2b4edff527876102f7d
ms.sourcegitcommit: 18ad9bc049589c8e44ed277f8f43dcaa483f3339
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/29/2017
---
# <a name="microsoft-azure-storage-performance-and-scalability-checklist"></a><span data-ttu-id="9ebaa-103">Liste de contrôle des performances et de l’extensibilité de Microsoft Azure Storage</span><span class="sxs-lookup"><span data-stu-id="9ebaa-103">Microsoft Azure Storage Performance and Scalability Checklist</span></span>
## <a name="overview"></a><span data-ttu-id="9ebaa-104">Vue d'ensemble</span><span class="sxs-lookup"><span data-stu-id="9ebaa-104">Overview</span></span>
<span data-ttu-id="9ebaa-105">Depuis la publication des services Microsoft Azure Storage, Microsoft a élaboré une série de pratiques éprouvées pour les utiliser de manière performante. Cet article se propose d’énumérer les méthodes les plus importantes sous la forme d’une liste de contrôle.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-105">Since the release of the Microsoft Azure Storage services, Microsoft has developed a number of proven practices for using these services in a performant manner, and this article serves to consolidate the most important of them into a checklist-style list.</span></span> <span data-ttu-id="9ebaa-106">L’objectif de cet article est double : aider les développeurs d’applications à s’assurer qu’ils utilisent des pratiques éprouvées avec Azure Storage et les aider à en identifier d’autres en vue de les adopter.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-106">The intention of this article is to help application developers verify they are using proven practices with Azure Storage and to help them identify other proven practices they should consider adopting.</span></span> <span data-ttu-id="9ebaa-107">Cet article n’a pas pour but d’aborder toutes les questions relatives à l’optimisation de l’extensibilité et des performances. Sont exclues les pratiques dont l’impact est minime ou celles qui ne sont pas applicables à grande échelle.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-107">This article does not attempt to cover every possible performance and scalability optimization — it excludes those that are small in their impact or not broadly applicable.</span></span> <span data-ttu-id="9ebaa-108">Dans la mesure où le comportement de l’application peut être prévu au cours de la conception, il convient de tenir compte de ces pratiques suffisamment tôt afin d’éviter les problèmes de performances ultérieurs.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-108">To the extent that the application's behavior can be predicted during design, it's useful to keep these in mind early on to avoid designs that will run into performance problems.</span></span>  

<span data-ttu-id="9ebaa-109">Chaque développeur d’applications qui utilise Azure Storage doit prendre le temps de lire cet article et s’assurer que son application respecte chacune des pratiques éprouvées répertoriées ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-109">Every application developer using Azure Storage should take the time to read this article, and check that his or her application follows each of the proven practices listed below.</span></span>  

## <a name="checklist"></a><span data-ttu-id="9ebaa-110">Liste de contrôle</span><span class="sxs-lookup"><span data-stu-id="9ebaa-110">Checklist</span></span>
<span data-ttu-id="9ebaa-111">Dans cet article, les pratiques éprouvées sont classées dans les groupes suivants.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-111">This article organizes the proven practices into the following groups.</span></span> <span data-ttu-id="9ebaa-112">Pratiques éprouvées applicables aux éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="9ebaa-112">Proven practices applicable to:</span></span>  

* <span data-ttu-id="9ebaa-113">Tous les services Azure Storage (objets blob, tables, files d’attente et fichiers)</span><span class="sxs-lookup"><span data-stu-id="9ebaa-113">All Azure Storage services (blobs, tables, queues, and files)</span></span>
* <span data-ttu-id="9ebaa-114">Objets blob</span><span class="sxs-lookup"><span data-stu-id="9ebaa-114">Blobs</span></span>
* <span data-ttu-id="9ebaa-115">Tables</span><span class="sxs-lookup"><span data-stu-id="9ebaa-115">Tables</span></span>
* <span data-ttu-id="9ebaa-116">Files d’attente</span><span class="sxs-lookup"><span data-stu-id="9ebaa-116">Queues</span></span>  

| <span data-ttu-id="9ebaa-117">Terminé</span><span class="sxs-lookup"><span data-stu-id="9ebaa-117">Done</span></span> | <span data-ttu-id="9ebaa-118">Domaine</span><span class="sxs-lookup"><span data-stu-id="9ebaa-118">Area</span></span> | <span data-ttu-id="9ebaa-119">Catégorie</span><span class="sxs-lookup"><span data-stu-id="9ebaa-119">Category</span></span> | <span data-ttu-id="9ebaa-120">Question</span><span class="sxs-lookup"><span data-stu-id="9ebaa-120">Question</span></span> |
| --- | --- | --- | --- |
| &nbsp; | <span data-ttu-id="9ebaa-121">Tous les services</span><span class="sxs-lookup"><span data-stu-id="9ebaa-121">All Services</span></span> |<span data-ttu-id="9ebaa-122">Objectifs d'évolutivité</span><span class="sxs-lookup"><span data-stu-id="9ebaa-122">Scalability Targets</span></span> |[<span data-ttu-id="9ebaa-123">Votre application est-elle conçue de manière à éviter d'atteindre les objectifs d'évolutivité ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-123">Is your application designed to avoid approaching the scalability targets?</span></span>](#subheading1) |
| &nbsp; | <span data-ttu-id="9ebaa-124">Tous les services</span><span class="sxs-lookup"><span data-stu-id="9ebaa-124">All Services</span></span> |<span data-ttu-id="9ebaa-125">Objectifs d'évolutivité</span><span class="sxs-lookup"><span data-stu-id="9ebaa-125">Scalability Targets</span></span> |[<span data-ttu-id="9ebaa-126">Votre convention d'affectation de noms est-elle conçue pour améliorer l'équilibrage de la charge ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-126">Is your naming convention designed to enable better load-balancing?</span></span>](#subheading47) |
| &nbsp; | <span data-ttu-id="9ebaa-127">Tous les services</span><span class="sxs-lookup"><span data-stu-id="9ebaa-127">All Services</span></span> |<span data-ttu-id="9ebaa-128">Mise en réseau</span><span class="sxs-lookup"><span data-stu-id="9ebaa-128">Networking</span></span> |[<span data-ttu-id="9ebaa-129">Les appareils côté client disposent-ils d'une bande passante suffisamment large et d'une latence suffisamment faible pour parvenir aux performances requises ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-129">Do client side devices have sufficiently high bandwidth and low latency to achieve the performance needed?</span></span>](#subheading2) |
| &nbsp; | <span data-ttu-id="9ebaa-130">Tous les services</span><span class="sxs-lookup"><span data-stu-id="9ebaa-130">All Services</span></span> |<span data-ttu-id="9ebaa-131">Mise en réseau</span><span class="sxs-lookup"><span data-stu-id="9ebaa-131">Networking</span></span> |[<span data-ttu-id="9ebaa-132">La qualité de la liaison des appareils côté client est-elle suffisamment élevée ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-132">Do client side devices have a high enough quality link?</span></span>](#subheading3) |
| &nbsp; | <span data-ttu-id="9ebaa-133">Tous les services</span><span class="sxs-lookup"><span data-stu-id="9ebaa-133">All Services</span></span> |<span data-ttu-id="9ebaa-134">Mise en réseau</span><span class="sxs-lookup"><span data-stu-id="9ebaa-134">Networking</span></span> |[<span data-ttu-id="9ebaa-135">L'application cliente est-elle située « à proximité » du compte de stockage ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-135">Is the client application located "near" the storage account?</span></span>](#subheading4) |
| &nbsp; | <span data-ttu-id="9ebaa-136">Tous les services</span><span class="sxs-lookup"><span data-stu-id="9ebaa-136">All Services</span></span> |<span data-ttu-id="9ebaa-137">Distribution de contenu</span><span class="sxs-lookup"><span data-stu-id="9ebaa-137">Content Distribution</span></span> |[<span data-ttu-id="9ebaa-138">Utilisez-vous un CDN pour la distribution de contenu ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-138">Are you using a CDN for content distribution?</span></span>](#subheading5) |
| &nbsp; | <span data-ttu-id="9ebaa-139">Tous les services</span><span class="sxs-lookup"><span data-stu-id="9ebaa-139">All Services</span></span> |<span data-ttu-id="9ebaa-140">Accès direct au client</span><span class="sxs-lookup"><span data-stu-id="9ebaa-140">Direct Client Access</span></span> |[<span data-ttu-id="9ebaa-141">Utilisez-vous SAP et CORS au lieu d'un proxy pour permettre un accès direct au client ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-141">Are you using SAS and CORS to allow direct access to storage instead of proxy?</span></span>](#subheading6) |
| &nbsp; | <span data-ttu-id="9ebaa-142">Tous les services</span><span class="sxs-lookup"><span data-stu-id="9ebaa-142">All Services</span></span> |<span data-ttu-id="9ebaa-143">Mise en cache</span><span class="sxs-lookup"><span data-stu-id="9ebaa-143">Caching</span></span> |[<span data-ttu-id="9ebaa-144">Votre application met-elle en cache les données qui sont utilisées fréquemment et qui changent rarement ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-144">Is your application caching data that is repeatedly used and changes rarely?</span></span>](#subheading7) |
| &nbsp; | <span data-ttu-id="9ebaa-145">Tous les services</span><span class="sxs-lookup"><span data-stu-id="9ebaa-145">All Services</span></span> |<span data-ttu-id="9ebaa-146">Mise en cache</span><span class="sxs-lookup"><span data-stu-id="9ebaa-146">Caching</span></span> |[<span data-ttu-id="9ebaa-147">Votre application traite-t-elle les mises à jour par lots (mise en cache côté client, suivie du téléchargement dans des ensembles plus grands) ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-147">Is your application batching updates (caching them client side and then uploading in larger sets)?</span></span>](#subheading8) |
| &nbsp; | <span data-ttu-id="9ebaa-148">Tous les services</span><span class="sxs-lookup"><span data-stu-id="9ebaa-148">All Services</span></span> |<span data-ttu-id="9ebaa-149">Configuration .NET</span><span class="sxs-lookup"><span data-stu-id="9ebaa-149">.NET Configuration</span></span> |[<span data-ttu-id="9ebaa-150">Avez-vous configuré votre client pour qu'il utilise un nombre suffisant de connexions simultanées ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-150">Have you configured your client to use a sufficient number of concurrent connections?</span></span>](#subheading9) |
| &nbsp; | <span data-ttu-id="9ebaa-151">Tous les services</span><span class="sxs-lookup"><span data-stu-id="9ebaa-151">All Services</span></span> |<span data-ttu-id="9ebaa-152">Configuration .NET</span><span class="sxs-lookup"><span data-stu-id="9ebaa-152">.NET Configuration</span></span> |[<span data-ttu-id="9ebaa-153">Avez-vous configuré .NET pour qu'il utilise un nombre suffisant de threads ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-153">Have you configured .NET to use a sufficient number of threads?</span></span>](#subheading10) |
| &nbsp; | <span data-ttu-id="9ebaa-154">Tous les services</span><span class="sxs-lookup"><span data-stu-id="9ebaa-154">All Services</span></span> |<span data-ttu-id="9ebaa-155">Configuration .NET</span><span class="sxs-lookup"><span data-stu-id="9ebaa-155">.NET Configuration</span></span> |[<span data-ttu-id="9ebaa-156">Utilisez-vous .NET 4.5 ou version ultérieure, qui présente une méthode de nettoyage de mémoire optimisée ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-156">Are you using .NET 4.5 or later, which has improved garbage collection?</span></span>](#subheading11) |
| &nbsp; | <span data-ttu-id="9ebaa-157">Tous les services</span><span class="sxs-lookup"><span data-stu-id="9ebaa-157">All Services</span></span> |<span data-ttu-id="9ebaa-158">Parallélisme</span><span class="sxs-lookup"><span data-stu-id="9ebaa-158">Parallelism</span></span> |[<span data-ttu-id="9ebaa-159">Vous êtes-vous assuré que le parallélisme était limité de manière appropriée, de manière à ne pas surcharger les capacités du client, ni dépasser les objectifs d'évolutivité ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-159">Have you ensured that parallelism is bounded appropriately so that you don't overload either your client capabilities or the scalability targets?</span></span>](#subheading12) |
| &nbsp; | <span data-ttu-id="9ebaa-160">Tous les services</span><span class="sxs-lookup"><span data-stu-id="9ebaa-160">All Services</span></span> |<span data-ttu-id="9ebaa-161">Outils</span><span class="sxs-lookup"><span data-stu-id="9ebaa-161">Tools</span></span> |[<span data-ttu-id="9ebaa-162">Utilisez-vous la version la plus récente des outils et bibliothèques clientes fournis par Microsoft ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-162">Are you using the latest version of Microsoft provided client libraries and tools?</span></span>](#subheading13) |
| &nbsp; | <span data-ttu-id="9ebaa-163">Tous les services</span><span class="sxs-lookup"><span data-stu-id="9ebaa-163">All Services</span></span> |<span data-ttu-id="9ebaa-164">Nouvelle tentatives</span><span class="sxs-lookup"><span data-stu-id="9ebaa-164">Retries</span></span> |[<span data-ttu-id="9ebaa-165">Utilisez-vous une stratégie de nouvelles tentatives d'interruption exponentielle pour les erreurs de limitation et les délais d'expiration ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-165">Are you using an exponential backoff retry policy for throttling errors and timeouts?</span></span>](#subheading14) |
| &nbsp; | <span data-ttu-id="9ebaa-166">Tous les services</span><span class="sxs-lookup"><span data-stu-id="9ebaa-166">All Services</span></span> |<span data-ttu-id="9ebaa-167">Nouvelle tentatives</span><span class="sxs-lookup"><span data-stu-id="9ebaa-167">Retries</span></span> |[<span data-ttu-id="9ebaa-168">Votre application empêche-t-elle les nouvelles tentatives pour les erreurs non renouvelables ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-168">Is your application avoiding retries for non-retryable errors?</span></span>](#subheading15) |
| &nbsp; | <span data-ttu-id="9ebaa-169">Objets blob</span><span class="sxs-lookup"><span data-stu-id="9ebaa-169">Blobs</span></span> |<span data-ttu-id="9ebaa-170">Objectifs d'évolutivité</span><span class="sxs-lookup"><span data-stu-id="9ebaa-170">Scalability Targets</span></span> |[<span data-ttu-id="9ebaa-171">Disposez-vous d’un grand nombre de clients qui accèdent simultanément à un seul objet ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-171">Do you have a large number of clients accessing a single object concurrently?</span></span>](#subheading46) |
| &nbsp; | <span data-ttu-id="9ebaa-172">Objets blob</span><span class="sxs-lookup"><span data-stu-id="9ebaa-172">Blobs</span></span> |<span data-ttu-id="9ebaa-173">Objectifs d'évolutivité</span><span class="sxs-lookup"><span data-stu-id="9ebaa-173">Scalability Targets</span></span> |[<span data-ttu-id="9ebaa-174">Votre application respecte-t-elle l'objectif d'évolutivité relatif aux opérations ou à la bande passante pour un objet blob unique ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-174">Is your application staying within the bandwidth or operations scalability target for a single blob?</span></span>](#subheading16) |
| &nbsp; | <span data-ttu-id="9ebaa-175">Objets blob</span><span class="sxs-lookup"><span data-stu-id="9ebaa-175">Blobs</span></span> |<span data-ttu-id="9ebaa-176">Copie d'objets blob</span><span class="sxs-lookup"><span data-stu-id="9ebaa-176">Copying Blobs</span></span> |[<span data-ttu-id="9ebaa-177">La copie des objets blob s'effectue-t-elle de manière efficace ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-177">Are you copying blobs in an efficient manner?</span></span>](#subheading17) |
| &nbsp; | <span data-ttu-id="9ebaa-178">Objets blob</span><span class="sxs-lookup"><span data-stu-id="9ebaa-178">Blobs</span></span> |<span data-ttu-id="9ebaa-179">Copie d'objets blob</span><span class="sxs-lookup"><span data-stu-id="9ebaa-179">Copying Blobs</span></span> |[<span data-ttu-id="9ebaa-180">Utilisez-vous AzCopy pour les copies en bloc d'objets blob ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-180">Are you using AzCopy for bulk copies of blobs?</span></span>](#subheading18) |
| &nbsp; | <span data-ttu-id="9ebaa-181">Objets blob</span><span class="sxs-lookup"><span data-stu-id="9ebaa-181">Blobs</span></span> |<span data-ttu-id="9ebaa-182">Copie d'objets blob</span><span class="sxs-lookup"><span data-stu-id="9ebaa-182">Copying Blobs</span></span> |[<span data-ttu-id="9ebaa-183">Utilisez-vous le service Azure Import/Export pour transférer de très gros volumes de données ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-183">Are you using Azure Import/Export to transfer very large volumes of data?</span></span>](#subheading19) |
| &nbsp; | <span data-ttu-id="9ebaa-184">Objets blob</span><span class="sxs-lookup"><span data-stu-id="9ebaa-184">Blobs</span></span> |<span data-ttu-id="9ebaa-185">Utilisation de métadonnées</span><span class="sxs-lookup"><span data-stu-id="9ebaa-185">Use Metadata</span></span> |[<span data-ttu-id="9ebaa-186">Stockez-vous des métadonnées fréquemment utilisées concernant des objets blob dans leurs métadonnées ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-186">Are you storing frequently used metadata about blobs in their metadata?</span></span>](#subheading20) |
| &nbsp; | <span data-ttu-id="9ebaa-187">Objets blob</span><span class="sxs-lookup"><span data-stu-id="9ebaa-187">Blobs</span></span> |<span data-ttu-id="9ebaa-188">Téléchargement rapide</span><span class="sxs-lookup"><span data-stu-id="9ebaa-188">Uploading Fast</span></span> |[<span data-ttu-id="9ebaa-189">Lorsque vous essayez de télécharger rapidement un seul objet blob, téléchargez-vous les blocs en parallèle ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-189">When trying to upload one blob quickly, are you uploading blocks in parallel?</span></span>](#subheading21) |
| &nbsp; | <span data-ttu-id="9ebaa-190">Objets blob</span><span class="sxs-lookup"><span data-stu-id="9ebaa-190">Blobs</span></span> |<span data-ttu-id="9ebaa-191">Téléchargement rapide</span><span class="sxs-lookup"><span data-stu-id="9ebaa-191">Uploading Fast</span></span> |[<span data-ttu-id="9ebaa-192">Lorsque vous essayez de télécharger rapidement de nombreux objets blob, les téléchargez-vous en parallèle ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-192">When trying to upload many blobs quickly, are you uploading blobs in parallel?</span></span>](#subheading22) |
| &nbsp; | <span data-ttu-id="9ebaa-193">Objets blob</span><span class="sxs-lookup"><span data-stu-id="9ebaa-193">Blobs</span></span> |<span data-ttu-id="9ebaa-194">Type d'objet blob correct</span><span class="sxs-lookup"><span data-stu-id="9ebaa-194">Correct Blob Type</span></span> |[<span data-ttu-id="9ebaa-195">Utilisez-vous des objets blob de pages ou de blocs lorsque cela s'avère approprié ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-195">Are you using page blobs or block blobs when appropriate?</span></span>](#subheading23) |
| &nbsp; | <span data-ttu-id="9ebaa-196">Tables</span><span class="sxs-lookup"><span data-stu-id="9ebaa-196">Tables</span></span> |<span data-ttu-id="9ebaa-197">Objectifs d'évolutivité</span><span class="sxs-lookup"><span data-stu-id="9ebaa-197">Scalability Targets</span></span> |[<span data-ttu-id="9ebaa-198">Vous approchez-vous des objectifs d'évolutivité en termes d'entités par seconde ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-198">Are you approaching the scalability targets for entities per second?</span></span>](#subheading24) |
| &nbsp; | <span data-ttu-id="9ebaa-199">Tables</span><span class="sxs-lookup"><span data-stu-id="9ebaa-199">Tables</span></span> |<span data-ttu-id="9ebaa-200">Configuration</span><span class="sxs-lookup"><span data-stu-id="9ebaa-200">Configuration</span></span> |[<span data-ttu-id="9ebaa-201">Utilisez-vous JSON pour vos demandes de table ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-201">Are you using JSON for your table requests?</span></span>](#subheading25) |
| &nbsp; | <span data-ttu-id="9ebaa-202">Tables</span><span class="sxs-lookup"><span data-stu-id="9ebaa-202">Tables</span></span> |<span data-ttu-id="9ebaa-203">Configuration</span><span class="sxs-lookup"><span data-stu-id="9ebaa-203">Configuration</span></span> |[<span data-ttu-id="9ebaa-204">Avez-vous désactivé Nagle pour améliorer les performances des petites demandes ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-204">Have you turned Nagle off to improve the performance of small requests?</span></span>](#subheading26) |
| &nbsp; | <span data-ttu-id="9ebaa-205">Tables</span><span class="sxs-lookup"><span data-stu-id="9ebaa-205">Tables</span></span> |<span data-ttu-id="9ebaa-206">Tables et partitions</span><span class="sxs-lookup"><span data-stu-id="9ebaa-206">Tables and Partitions</span></span> |[<span data-ttu-id="9ebaa-207">Avez-vous correctement partitionné vos données ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-207">Have you properly partitioned your data?</span></span>](#subheading27) |
| &nbsp; | <span data-ttu-id="9ebaa-208">Tables</span><span class="sxs-lookup"><span data-stu-id="9ebaa-208">Tables</span></span> |<span data-ttu-id="9ebaa-209">Partitions actives</span><span class="sxs-lookup"><span data-stu-id="9ebaa-209">Hot Partitions</span></span> |[<span data-ttu-id="9ebaa-210">Évitez-vous les modèles « Ajouter après uniquement » ou « Ajouter avant uniquement » ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-210">Are you avoiding append-only and prepend-only patterns?</span></span>](#subheading28) |
| &nbsp; | <span data-ttu-id="9ebaa-211">Tables</span><span class="sxs-lookup"><span data-stu-id="9ebaa-211">Tables</span></span> |<span data-ttu-id="9ebaa-212">Partitions actives</span><span class="sxs-lookup"><span data-stu-id="9ebaa-212">Hot Partitions</span></span> |[<span data-ttu-id="9ebaa-213">Vos opérations d'insertion/de mise à jour couvrent-elles plusieurs partitions ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-213">Are your inserts/updates spread across many partitions?</span></span>](#subheading29) |
| &nbsp; | <span data-ttu-id="9ebaa-214">Tables</span><span class="sxs-lookup"><span data-stu-id="9ebaa-214">Tables</span></span> |<span data-ttu-id="9ebaa-215">Étendue de requête</span><span class="sxs-lookup"><span data-stu-id="9ebaa-215">Query Scope</span></span> |[<span data-ttu-id="9ebaa-216">Avez-vous conçu votre schéma pour qu'il autorise l'utilisation des requêtes de point dans la plupart des cas et l'utilisation modérée des requêtes de tables ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-216">Have you designed your schema to allow for point queries to be used in most cases, and table queries to be used sparingly?</span></span>](#subheading30) |
| &nbsp; | <span data-ttu-id="9ebaa-217">Tables</span><span class="sxs-lookup"><span data-stu-id="9ebaa-217">Tables</span></span> |<span data-ttu-id="9ebaa-218">Densité des requêtes</span><span class="sxs-lookup"><span data-stu-id="9ebaa-218">Query Density</span></span> |[<span data-ttu-id="9ebaa-219">En règle générale, vos requêtes n'analysent et ne renvoient-elles que les lignes qui seront utilisées par votre application ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-219">Do your queries typically only scan and return rows that your application will use?</span></span>](#subheading31) |
| &nbsp; | <span data-ttu-id="9ebaa-220">Tables</span><span class="sxs-lookup"><span data-stu-id="9ebaa-220">Tables</span></span> |<span data-ttu-id="9ebaa-221">Limitation des données renvoyées</span><span class="sxs-lookup"><span data-stu-id="9ebaa-221">Limiting Returned Data</span></span> |[<span data-ttu-id="9ebaa-222">Utilisez-vous le filtrage pour éviter le renvoi d'entités inutiles ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-222">Are you using filtering to avoid returning entities that are not needed?</span></span>](#subheading32) |
| &nbsp; | <span data-ttu-id="9ebaa-223">Tables</span><span class="sxs-lookup"><span data-stu-id="9ebaa-223">Tables</span></span> |<span data-ttu-id="9ebaa-224">Limitation des données renvoyées</span><span class="sxs-lookup"><span data-stu-id="9ebaa-224">Limiting Returned Data</span></span> |[<span data-ttu-id="9ebaa-225">Utilisez-vous la projection pour éviter le renvoi de propriétés inutiles ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-225">Are you using projection to avoid returning properties that are not needed?</span></span>](#subheading33) |
| &nbsp; | <span data-ttu-id="9ebaa-226">Tables</span><span class="sxs-lookup"><span data-stu-id="9ebaa-226">Tables</span></span> |<span data-ttu-id="9ebaa-227">Dénormalisation</span><span class="sxs-lookup"><span data-stu-id="9ebaa-227">Denormalization</span></span> |[<span data-ttu-id="9ebaa-228">Avez-vous dénormalisé vos données de manière à éviter les requêtes inefficaces ou les demandes de lecture multiples lorsque vous essayez de récupérer des données ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-228">Have you denormalized your data such that you avoid inefficient queries or multiple read requests when trying to get data?</span></span>](#subheading34) |
| &nbsp; | <span data-ttu-id="9ebaa-229">Tables</span><span class="sxs-lookup"><span data-stu-id="9ebaa-229">Tables</span></span> |<span data-ttu-id="9ebaa-230">Insertion/Mise à jour/Suppression</span><span class="sxs-lookup"><span data-stu-id="9ebaa-230">Insert/Update/Delete</span></span> |[<span data-ttu-id="9ebaa-231">Effectuez-vous un traitement par lots des demandes qui doivent être transactionnelles ou qui peuvent être effectuées en même temps pour réduire les allers-retours ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-231">Are you batching requests that need to be transactional or can be done at the same time to reduce round-trips?</span></span>](#subheading35) |
| &nbsp; | <span data-ttu-id="9ebaa-232">Tables</span><span class="sxs-lookup"><span data-stu-id="9ebaa-232">Tables</span></span> |<span data-ttu-id="9ebaa-233">Insertion/Mise à jour/Suppression</span><span class="sxs-lookup"><span data-stu-id="9ebaa-233">Insert/Update/Delete</span></span> |[<span data-ttu-id="9ebaa-234">Évitez-vous de récupérer une entité pour déterminer simplement s'il faut appeler l'opération insert ou update ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-234">Are you avoiding retrieving an entity just to determine whether to call insert or update?</span></span>](#subheading36) |
| &nbsp; | <span data-ttu-id="9ebaa-235">Tables</span><span class="sxs-lookup"><span data-stu-id="9ebaa-235">Tables</span></span> |<span data-ttu-id="9ebaa-236">Insertion/Mise à jour/Suppression</span><span class="sxs-lookup"><span data-stu-id="9ebaa-236">Insert/Update/Delete</span></span> |[<span data-ttu-id="9ebaa-237">Avez-vous envisagé de stocker des séries de données qui seront fréquemment récupérées ensemble dans une seule entité sous la forme de propriétés plutôt que d'entités multiples ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-237">Have you considered storing series of data that will frequently be retrieved together in a single entity as properties instead of multiple entities?</span></span>](#subheading37) |
| &nbsp; | <span data-ttu-id="9ebaa-238">Tables</span><span class="sxs-lookup"><span data-stu-id="9ebaa-238">Tables</span></span> |<span data-ttu-id="9ebaa-239">Insertion/Mise à jour/Suppression</span><span class="sxs-lookup"><span data-stu-id="9ebaa-239">Insert/Update/Delete</span></span> |[<span data-ttu-id="9ebaa-240">Dans le cas des tables qui sont toujours récupérées ensemble et qui peuvent être écrites par lots (des données de séries temporelles, par exemple), avez-vous envisagé d'utiliser des objets blob à la place de tables ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-240">For entities that will always be retrieved together and can be written in batches (e.g. time series data), have you considered using blobs instead of tables?</span></span>](#subheading38) |
| &nbsp; | <span data-ttu-id="9ebaa-241">Files d’attente</span><span class="sxs-lookup"><span data-stu-id="9ebaa-241">Queues</span></span> |<span data-ttu-id="9ebaa-242">Objectifs d'évolutivité</span><span class="sxs-lookup"><span data-stu-id="9ebaa-242">Scalability Targets</span></span> |[<span data-ttu-id="9ebaa-243">Vous approchez-vous des objectifs d'évolutivité en termes de messages par seconde ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-243">Are you approaching the scalability targets for messages per second?</span></span>](#subheading39) |
| &nbsp; | <span data-ttu-id="9ebaa-244">Files d’attente</span><span class="sxs-lookup"><span data-stu-id="9ebaa-244">Queues</span></span> |<span data-ttu-id="9ebaa-245">Configuration</span><span class="sxs-lookup"><span data-stu-id="9ebaa-245">Configuration</span></span> |[<span data-ttu-id="9ebaa-246">Avez-vous désactivé Nagle pour améliorer les performances des petites demandes ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-246">Have you turned Nagle off to improve the performance of small requests?</span></span>](#subheading40) |
| &nbsp; | <span data-ttu-id="9ebaa-247">Files d’attente</span><span class="sxs-lookup"><span data-stu-id="9ebaa-247">Queues</span></span> |<span data-ttu-id="9ebaa-248">Taille des messages</span><span class="sxs-lookup"><span data-stu-id="9ebaa-248">Message Size</span></span> |[<span data-ttu-id="9ebaa-249">Vos messages sont-ils compacts pour améliorer les performances de la file d'attente ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-249">Are your messages compact to improve the performance of the queue?</span></span>](#subheading41) |
| &nbsp; | <span data-ttu-id="9ebaa-250">Files d’attente</span><span class="sxs-lookup"><span data-stu-id="9ebaa-250">Queues</span></span> |<span data-ttu-id="9ebaa-251">Récupération en bloc</span><span class="sxs-lookup"><span data-stu-id="9ebaa-251">Bulk Retrieve</span></span> |[<span data-ttu-id="9ebaa-252">Récupérez-vous plusieurs messages dans une seule opération « Get » ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-252">Are you retrieving multiple messages in a single "Get" operation?</span></span>](#subheading42) |
| &nbsp; | <span data-ttu-id="9ebaa-253">Files d’attente</span><span class="sxs-lookup"><span data-stu-id="9ebaa-253">Queues</span></span> |<span data-ttu-id="9ebaa-254">Fréquence d'interrogation</span><span class="sxs-lookup"><span data-stu-id="9ebaa-254">Polling Frequency</span></span> |[<span data-ttu-id="9ebaa-255">Effectuez-vous des interrogations suffisamment fréquentes pour réduire la latence perçue de votre application ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-255">Are you polling frequently enough to reduce the perceived latency of your application?</span></span>](#subheading43) |
| &nbsp; | <span data-ttu-id="9ebaa-256">Files d’attente</span><span class="sxs-lookup"><span data-stu-id="9ebaa-256">Queues</span></span> |<span data-ttu-id="9ebaa-257">Mise à jour de message</span><span class="sxs-lookup"><span data-stu-id="9ebaa-257">Update Message</span></span> |[<span data-ttu-id="9ebaa-258">Utilisez-vous la méthode UpdateMessage pour stocker la progression du traitement des messages et éviter de devoir retraiter l'intégralité du message en cas d'erreur ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-258">Are you using UpdateMessage to store progress in processing messages, avoiding having to reprocess the entire message if an error occurs?</span></span>](#subheading44) |
| &nbsp; | <span data-ttu-id="9ebaa-259">Files d’attente</span><span class="sxs-lookup"><span data-stu-id="9ebaa-259">Queues</span></span> |<span data-ttu-id="9ebaa-260">Architecture</span><span class="sxs-lookup"><span data-stu-id="9ebaa-260">Architecture</span></span> |[<span data-ttu-id="9ebaa-261">Utilisez-vous des files d'attente pour rendre toute votre application plus extensible en excluant les charges de travail de longue durée du chemin critique et pour les faire ensuite évoluer séparément ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-261">Are you using queues to make your entire application more scalable by keeping long-running workloads out of the critical path and scale then independently?</span></span>](#subheading45) |

## <span data-ttu-id="9ebaa-262"><a name="allservices"></a>Tous les Services</span><span class="sxs-lookup"><span data-stu-id="9ebaa-262"><a name="allservices"></a>All Services</span></span>
<span data-ttu-id="9ebaa-263">Cette section répertorie les pratiques éprouvées qui s’appliquent à l’utilisation de tout service Azure Storage (objets blob, tables, files d’attente ou fichiers).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-263">This section lists proven practices that are applicable to the use of any of the Azure Storage services (blobs, tables, queues, or files).</span></span>  

### <span data-ttu-id="9ebaa-264"><a name="subheading1"></a>Objectifs d’extensibilité</span><span class="sxs-lookup"><span data-stu-id="9ebaa-264"><a name="subheading1"></a>Scalability Targets</span></span>
<span data-ttu-id="9ebaa-265">Chaque service Azure Storage présente des objectifs d’extensibilité en termes de capacité (Go), de taux de transactions et de bande passante.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-265">Each of the Azure Storage services has scalability targets for capacity (GB), transaction rate, and bandwidth.</span></span> <span data-ttu-id="9ebaa-266">Si votre application s’approche de l’un des objectifs d’extensibilité, voire le dépasse, une limitation ou des latences de transaction accrues peuvent survenir.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-266">If your application approaches or exceeds any of the scalability targets, it may encounter increased transaction latencies or throttling.</span></span> <span data-ttu-id="9ebaa-267">Lorsqu’un service de stockage limite votre application, il commence à renvoyer les codes d’erreur « 503 Serveur occupé » ou « 500 Délai d’expiration de l’opération » pour certaines opérations de stockage.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-267">When a Storage service throttles your application, the service begins to return "503 Server busy" or "500 Operation timeout" error codes for some storage transactions.</span></span> <span data-ttu-id="9ebaa-268">Cette section traite de la méthode générale de traitement des objectifs d’extensibilité et, en particulier, des objectifs d’extensibilité de bande passante.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-268">This section discusses both the general approach to dealing with scalability targets and bandwidth scalability targets in particular.</span></span> <span data-ttu-id="9ebaa-269">Les sections ultérieures portant sur les différents services de stockage traitent des objectifs d’extensibilité dans le cadre de ce service spécifique :</span><span class="sxs-lookup"><span data-stu-id="9ebaa-269">Later sections that deal with individual storage services discuss scalability targets in the context of that specific service:</span></span>  

* [<span data-ttu-id="9ebaa-270">Bande passante des objets blob et demandes par seconde</span><span class="sxs-lookup"><span data-stu-id="9ebaa-270">Blob bandwidth and requests per second</span></span>](#subheading16)
* [<span data-ttu-id="9ebaa-271">Entités de table par seconde</span><span class="sxs-lookup"><span data-stu-id="9ebaa-271">Table entities per second</span></span>](#subheading24)
* [<span data-ttu-id="9ebaa-272">Messages de file d’attente par seconde</span><span class="sxs-lookup"><span data-stu-id="9ebaa-272">Queue messages per second</span></span>](#subheading39)  

#### <span data-ttu-id="9ebaa-273"><a name="sub1bandwidth"></a>Cible d’extensibilité de bande passante pour tous les services</span><span class="sxs-lookup"><span data-stu-id="9ebaa-273"><a name="sub1bandwidth"></a>Bandwidth Scalability Target for All Services</span></span>
<span data-ttu-id="9ebaa-274">Au moment de la rédaction du présent document, les objectifs de bande passante, aux États-Unis, d’un compte de stockage géo-redondant (GRS) étaient de 10 Gbits/s (gigabits par seconde) en entrée (données envoyées vers le compte de stockage) et de 20 Gbits/s en sortie (données envoyées à partir du compte de stockage).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-274">At the time of writing, the bandwidth targets in the US for a geo-redundant storage (GRS) account are 10 gigabits per second (Gbps) for ingress (data sent to the storage account) and 20 Gbps for egress (data sent from the storage account).</span></span> <span data-ttu-id="9ebaa-275">Ces limites sont plus élevées dans le cas d’un compte de stockage redondant local (LRS), à savoir : 20 Gbits/s en entrée et 30 Gbits/s en sortie.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-275">For a locally redundant storage (LRS) account, the limits are higher – 20 Gbps for ingress and 30 Gbps for egress.</span></span>  <span data-ttu-id="9ebaa-276">Les limites de bande passante internationales peuvent être inférieures. Pour les consulter, rendez-vous sur la [page traitant des objectifs d’extensibilité](http://msdn.microsoft.com/library/azure/dn249410.aspx).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-276">International bandwidth limits may be lower and can be found on our [scalability targets page](http://msdn.microsoft.com/library/azure/dn249410.aspx).</span></span>  <span data-ttu-id="9ebaa-277">Pour plus d’informations sur les options de redondance du stockage, voir les liens de la section [Ressources utiles](#sub1useful) ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-277">For more information on the storage redundancy options, see the links in [Useful Resources](#sub1useful) below.</span></span>  

#### <a name="what-to-do-when-approaching-a-scalability-target"></a><span data-ttu-id="9ebaa-278">Que faire lorsque l’on s’approche d’un objectif d’extensibilité ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-278">What to do when approaching a scalability target</span></span>
<span data-ttu-id="9ebaa-279">Si votre application s’approche des objectifs d’extensibilité d’un seul compte de stockage, pensez à appliquer l’une des méthodes suivantes :</span><span class="sxs-lookup"><span data-stu-id="9ebaa-279">If your application is approaching the scalability targets for a single storage account, consider adopting one of the following approaches:</span></span>  

* <span data-ttu-id="9ebaa-280">Réexaminez la charge de travail à cause de laquelle votre application s’approche de l’objectif d’extensibilité ou le dépasse.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-280">Reconsider the workload that causes your application to approach or exceed the scalability target.</span></span> <span data-ttu-id="9ebaa-281">Est-il possible de la concevoir différemment pour qu’elle utilise moins de bande passante ou de capacité, ou moins de transactions ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-281">Can you design it differently to use less bandwidth or capacity, or fewer transactions?</span></span>
* <span data-ttu-id="9ebaa-282">Si une application doit dépasser l’un des objectifs d’extensibilité, vous devez créer plusieurs comptes de stockage et partitionner vos données d’application sur ces comptes.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-282">If an application must exceed one of the scalability targets, you should create multiple storage accounts and partition your application data across those multiple storage accounts.</span></span> <span data-ttu-id="9ebaa-283">Si vous optez pour ce modèle, veillez à concevoir votre application de telle sorte que vous puissiez ajouter davantage de comptes de stockage à l’avenir en vue de l’équilibrage de la charge.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-283">If you use this pattern, then be sure to design your application so that you can add more storage accounts in the future for load balancing.</span></span> <span data-ttu-id="9ebaa-284">Au moment de la rédaction du présent document, chaque abonnement Azure peut comporter jusqu’à 100 comptes de stockage.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-284">At time of writing, each Azure subscription can have up to 100 storage accounts.</span></span>  <span data-ttu-id="9ebaa-285">De plus, aucun coût autre que l’utilisation en termes de données stockées, de transactions effectuées ou de données transférées n’est associé à ces comptes de stockage.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-285">Storage accounts also have no cost other than your usage in terms of data stored, transactions made, or data transferred.</span></span>
* <span data-ttu-id="9ebaa-286">Si votre application atteint les objectifs de bande passante, pensez à compresser les données dans le client afin de réduire la bande passante nécessaire pour envoyer les données au service de stockage.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-286">If your application hits the bandwidth targets, consider compressing data in the client to reduce the bandwidth required to send the data to the storage service.</span></span>  <span data-ttu-id="9ebaa-287">Bien que cela puisse réduire la bande passante et améliorer les performances du réseau, cette méthode présente des aspects négatifs.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-287">Note that while this may save bandwidth and improve network performance, it can also have some negative impacts.</span></span>  <span data-ttu-id="9ebaa-288">Vous devez évaluer l’impact sur les performances en raison des exigences de traitement supplémentaires liées à la compression et à la décompression des données sur le client.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-288">You should evaluate the performance impact of this due to the additional processing requirements for compressing and decompressing data in the client.</span></span> <span data-ttu-id="9ebaa-289">Le stockage de données compressées peut, en outre, rendre plus complexe la résolution des problèmes, étant donné qu’il peut s’avérer plus difficile d’afficher les données stockées à l’aide d’outils standard.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-289">In addition, storing compressed data can make it more difficult to troubleshoot issues since it could be more difficult to view stored data using standard tools.</span></span>
* <span data-ttu-id="9ebaa-290">Si votre application atteint les objectifs d’extensibilité, vérifiez que vous utilisez bien une interruption exponentielle pour les nouvelles tentatives (voir [Nouvelles tentatives](#subheading14)).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-290">If your application hits the scalability targets, then ensure that you are using an exponential backoff for retries (see [Retries](#subheading14)).</span></span>  <span data-ttu-id="9ebaa-291">Il est préférable de veiller à ne jamais s’approcher des objectifs d’extensibilité (en utilisant l’une des méthodes ci-dessus). Vous vous assurez ainsi que votre application n’effectue pas de nouvelle tentative immédiatement, ce qui aurait pour conséquence d’empirer la limitation.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-291">It's better to make sure you never approach the scalability targets (by using one of the above methods), but this will ensure your application won't just keep retrying rapidly, making the throttling worse.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="9ebaa-292">Ressources utiles</span><span class="sxs-lookup"><span data-stu-id="9ebaa-292">Useful Resources</span></span>
<span data-ttu-id="9ebaa-293">Suivez les liens ci-dessous pour obtenir des informations détaillées sur les objectifs d'évolutivité :</span><span class="sxs-lookup"><span data-stu-id="9ebaa-293">The following links provide additional detail on scalability targets:</span></span>

* <span data-ttu-id="9ebaa-294">Pour plus d’informations sur les objectifs d’extensibilité, consultez [Objectifs de performance et évolutivité d’Azure Storage](storage-scalability-targets.md) .</span><span class="sxs-lookup"><span data-stu-id="9ebaa-294">See [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md) for information about scalability targets.</span></span>
* <span data-ttu-id="9ebaa-295">Consultez la [réplication Azure Storage](storage-redundancy.md) et le billet de blog [Options de redondance de Microsoft Azure Storage et stockage géo-redondant avec accès en lecture](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/11/introducing-read-access-geo-replicated-storage-ra-grs-for-windows-azure-storage.aspx) pour plus d’informations sur les options de redondance de stockage.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-295">See [Azure Storage replication](storage-redundancy.md) and the blog post [Azure Storage Redundancy Options and Read Access Geo Redundant Storage](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/11/introducing-read-access-geo-replicated-storage-ra-grs-for-windows-azure-storage.aspx) for information about storage redundancy options.</span></span>
* <span data-ttu-id="9ebaa-296">Pour obtenir des informations à jour sur la tarification des services Azure, consultez la page [Tarification Azure](https://azure.microsoft.com/pricing/overview/).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-296">For current information about pricing for Azure services, see [Azure pricing](https://azure.microsoft.com/pricing/overview/).</span></span>  

### <span data-ttu-id="9ebaa-297"><a name="subheading47"></a>Conventions d’affectation de noms aux partitions</span><span class="sxs-lookup"><span data-stu-id="9ebaa-297"><a name="subheading47"></a>Partition Naming Convention</span></span>
<span data-ttu-id="9ebaa-298">Azure Storage utilise un schéma de partitionnement basé sur une plage pour mettre à l'échelle et équilibrer la charge du système.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-298">Azure Storage uses a range-based partitioning scheme to scale and load balance the system.</span></span> <span data-ttu-id="9ebaa-299">La clé de partition sert à partitionner les données en plages, et la charge de ces plages est équilibrée sur l’ensemble du système.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-299">The partition key is used to partition data into ranges and these ranges are load-balanced across the system.</span></span> <span data-ttu-id="9ebaa-300">Cela signifie que les conventions d'affectation de noms telles que l'ordre lexical (par exemple, msftpayroll, msftperformance, msftemployees, etc.) ou à l'aide d'un horodatage (log20160101, log20160102, log20160102, etc.) utiliseront les partitions potentiellement en colocation sur le même serveur de partition, jusqu’à ce qu’une opération de fractionnement les fractionne en plages plus petites.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-300">This means naming conventions such as lexical ordering (e.g. msftpayroll, msftperformance, msftemployees, etc) or using time-stamps (log20160101, log20160102, log20160102, etc) will lend itself to the partitions being potentially co-located on the same partition server, until a load balancing operation splits them out into smaller ranges.</span></span> <span data-ttu-id="9ebaa-301">Par exemple, tous les objets blob d’un conteneur peuvent être fournis par un même serveur jusqu'à ce que la charge sur ces objets blob nécessite un rééquilibrage plus approfondi des plages de la partition.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-301">For example, all blobs within a container can be served by a single server until the load on these blobs requires further rebalancing of the partition ranges.</span></span> <span data-ttu-id="9ebaa-302">De même, un groupe de comptes faiblement chargés avec leurs noms classés par ordre lexical peut être pris en charge par un même serveur jusqu'à ce que la charge sur un ou tous ces comptes nécessite qu’ils soient répartis entre plusieurs serveurs de partitions.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-302">Similarly, a group of lightly loaded accounts with their names arranged in lexical order may be served by a single server until the load on one or all of these accounts require them to be split across multiple partitions servers.</span></span> <span data-ttu-id="9ebaa-303">Chaque opération d'équilibrage de la charge peut affecter la latence des appels de stockage lors de l'opération.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-303">Each load balancing operation may impact the latency of storage calls during the operation.</span></span> <span data-ttu-id="9ebaa-304">La capacité du système à gérer une hausse soudaine du trafic vers une partition est limitée par l'évolutivité d'un serveur de partition unique jusqu'à ce que l'opération d'équilibrage de la charge intervienne et rééquilibre la plage clé de la partition.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-304">The system's ability to handle a sudden burst of traffic to a partition is limited by the scalability of a single partition server until the load balancing operation kicks-in and rebalances the partition key range.</span></span>  

<span data-ttu-id="9ebaa-305">Vous pouvez suivre quelques bonnes pratiques pour réduire la fréquence de ces opérations.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-305">You can follow some best practices to reduce the frequency of such operations.</span></span>  

* <span data-ttu-id="9ebaa-306">Examinez attentivement la convention d’affectation de noms que vous utilisez pour les comptes, conteneurs, objets blob, tables et files d'attente.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-306">Examine the naming convention you use for accounts, containers, blobs, tables and queues, closely.</span></span> <span data-ttu-id="9ebaa-307">Vous pouvez ajouter un préfixe aux noms de comptes avec un hachage à 3 chiffres à l'aide d'une fonction de hachage qui correspond le mieux à vos besoins.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-307">Consider prefixing account names with a 3-digit hash using a hashing function that best suits your needs.</span></span>  
* <span data-ttu-id="9ebaa-308">Si vous organisez vos données à l'aide d'horodatages ou d’identificateurs numériques, vous devez veiller à ne pas utiliser des modèles de trafic « Ajouter après uniquement » ou « Ajouter avant uniquement ».</span><span class="sxs-lookup"><span data-stu-id="9ebaa-308">If you organize your data using timestamps or numerical identifiers, you have to ensure you are not using an append-only (or prepend-only) traffic patterns.</span></span> <span data-ttu-id="9ebaa-309">Ces modèles ne sont pas adaptés à un système de partitionnement basé sur des plages et risquent de diriger tout le trafic vers une partition unique, empêchant ainsi un équilibrage optimal de la charge sur le système.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-309">These patterns are not suitable for a range -based partitioning system, and could lead to all the traffic going to a single partition and limiting the system from effectively load balancing.</span></span> <span data-ttu-id="9ebaa-310">Par exemple, si vos opérations quotidiennes utilisent un objet blob avec un horodatage comme yyyymmdd, tout le trafic pour cette opération quotidienne est alors dirigé vers un objet unique pris en charge par un serveur de partition unique.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-310">For instance, if you have daily operations that use a blob object with a timestamp such as yyyymmdd, then all the traffic for that daily operation is directed to a single object which is served by a single partition server.</span></span> <span data-ttu-id="9ebaa-311">Vérifiez si les limites par objet blob et par partition répondent à vos besoins, et pensez à diviser cette opération en plusieurs objets blob si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-311">Look at whether the per blob limits and per partition limits meet your needs, and consider breaking this operation into multiple blobs if needed.</span></span> <span data-ttu-id="9ebaa-312">De même, si vous stockez des données chronologiques dans vos tables, tout le trafic pourrait être dirigé vers la dernière partie de l'espace de noms de clé.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-312">Similarly, if you store time series data in your tables, all the traffic could be directed to the last part of the key namespace.</span></span> <span data-ttu-id="9ebaa-313">Si vous devez utiliser des horodatages ou des ID numériques, ajoutez en préfixe un hachage à 3 chiffres à l’ID ou, dans le cas des horodateurs, ajoutez en préfixe la partie des secondes, par exemple ssyyyymmdd.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-313">If you must use timestamps or numerical IDs, prefix the id with a 3-digit hash, or in the case of timestamps prefix the seconds part of the time such as ssyyyymmdd.</span></span> <span data-ttu-id="9ebaa-314">Si des opérations de listage et d'interrogation sont effectuées régulièrement, choisissez une fonction de hachage qui limite le nombre de vos requêtes.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-314">If listing and querying operations are routinely performed, choose a hashing function that will limit your number of queries.</span></span> <span data-ttu-id="9ebaa-315">Dans d'autres cas, un préfixe aléatoire peut être suffisant.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-315">In other cases, a random prefix may be sufficient.</span></span>  
* <span data-ttu-id="9ebaa-316">Pour plus d'informations sur le schéma de partitionnement utilisé dans Azure Storage, consultez le document SOSP disponible [ici](http://sigops.org/sosp/sosp11/current/2011-Cascais/printable/11-calder.pdf).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-316">For additional information on the partitioning scheme used in Azure Storage, read the SOSP paper [here](http://sigops.org/sosp/sosp11/current/2011-Cascais/printable/11-calder.pdf).</span></span>

### <a name="networking"></a><span data-ttu-id="9ebaa-317">Mise en réseau</span><span class="sxs-lookup"><span data-stu-id="9ebaa-317">Networking</span></span>
<span data-ttu-id="9ebaa-318">Bien que les appels d’API soient importants, les contraintes de réseau physiques de l’application ont souvent un impact majeur sur les performances.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-318">While the API calls matter, often the physical network constraints of the application have a significant impact on performance.</span></span> <span data-ttu-id="9ebaa-319">Vous trouverez, ci-dessous, certaines des limitations auxquelles les utilisateurs peuvent être confrontés.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-319">The following describe some of limitations users may encounter.</span></span>  

#### <a name="client-network-capability"></a><span data-ttu-id="9ebaa-320">Fonctionnalités réseau du client</span><span class="sxs-lookup"><span data-stu-id="9ebaa-320">Client Network Capability</span></span>
##### <span data-ttu-id="9ebaa-321"><a name="subheading2"></a>Débit</span><span class="sxs-lookup"><span data-stu-id="9ebaa-321"><a name="subheading2"></a>Throughput</span></span>
<span data-ttu-id="9ebaa-322">Dans le cas de la bande passante, le problème est souvent dû aux capacités du client.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-322">For bandwidth, the problem is often the capabilities of the client.</span></span> <span data-ttu-id="9ebaa-323">Par exemple, bien qu’un seul compte de stockage puisse gérer un débit de 10 Gbits/s ou plus en entrée (voir [Objectifs d’évolutivité de bande passante](#sub1bandwidth)), la vitesse réseau d’une petite instance Rôle de travail Azure ne permet qu’un débit d’environ 100 Mbits/s.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-323">For example, while a single storage account can handle 10 Gbps or more of ingress (see [bandwidth scalability targets](#sub1bandwidth)), the network speed in a "Small" Azure Worker Role instance is only capable of approximately 100 Mbps.</span></span> <span data-ttu-id="9ebaa-324">Dans le cas des instances Azure plus importantes, les cartes réseau présentent une capacité supérieure. Si vous avez besoin de limites réseau plus élevées à partir d’un seul ordinateur, vous devez donc envisager d’utiliser une instance plus grande ou davantage de machines virtuelles.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-324">Larger Azure instances have NICs with greater capacity, so you should consider using a larger instance or more VM's if you need higher network limits from a single machine.</span></span> <span data-ttu-id="9ebaa-325">Si vous accédez à un service de stockage à partir d’une application locale, alors la même règle s’applique : comprendre les capacités réseau du périphérique client et la connectivité réseau à l’emplacement de stockage Azure et l’améliorer selon vos besoins ou concevoir votre application conformément à ces capacités.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-325">If you are accessing a Storage service from an on premises application, then the same rule applies: understand the network capabilities of the client device and the network connectivity to the Azure Storage location and either improve them as needed or design your application to work within their capabilities.</span></span>  

##### <span data-ttu-id="9ebaa-326"><a name="subheading3"></a>Qualité de la liaison</span><span class="sxs-lookup"><span data-stu-id="9ebaa-326"><a name="subheading3"></a>Link Quality</span></span>
<span data-ttu-id="9ebaa-327">Comme c’est le cas pour toute utilisation du réseau, veuillez tenir compte du fait que les conditions réseau qui génèrent des erreurs et une perte de paquets ralentissent le débit effectif.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-327">As with any network usage, be aware that network conditions resulting in errors and packet loss will slow effective throughput.</span></span>  <span data-ttu-id="9ebaa-328">L’utilisation de WireShark ou de NetMon peut vous aider à diagnostiquer ce problème.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-328">Using WireShark or NetMon may help in diagnosing this issue.</span></span>  

##### <a name="useful-resources"></a><span data-ttu-id="9ebaa-329">Ressources utiles</span><span class="sxs-lookup"><span data-stu-id="9ebaa-329">Useful Resources</span></span>
<span data-ttu-id="9ebaa-330">Pour plus d’informations sur les tailles de machines virtuelles et la bande passante allouée, consultez la rubrique [Tailles des machines virtuelles](../../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) ou [Tailles des machines virtuelles Linux](../../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-330">For more information about virtual machine sizes and allocated bandwidth, see [Windows VM sizes](../../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) or [Linux VM sizes](../../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).</span></span>  

#### <span data-ttu-id="9ebaa-331"><a name="subheading4"></a>Emplacement</span><span class="sxs-lookup"><span data-stu-id="9ebaa-331"><a name="subheading4"></a>Location</span></span>
<span data-ttu-id="9ebaa-332">Dans un environnement distribué, le fait de placer le client à proximité du serveur se traduit par des performances optimales.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-332">In any distributed environment, placing the client near to the server delivers in the best performance.</span></span> <span data-ttu-id="9ebaa-333">Pour accéder à Azure Storage avec un minimum de latence, votre client doit idéalement se trouver dans la même région Azure.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-333">For accessing Azure Storage with the lowest latency, the best location for your client is within the same Azure region.</span></span> <span data-ttu-id="9ebaa-334">Par exemple, dans le cas d’un site web qui utilise Azure Storage, tous deux doivent se trouver dans la même région (Ouest des États-Unis ou Asie du Sud-Est, par exemple).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-334">For example, if you have an Azure Web Site that uses Azure Storage, you should locate them both within a single region (for example, US West or Asia Southeast).</span></span> <span data-ttu-id="9ebaa-335">Cela réduit à la fois la latence et les coûts. Au moment de la rédaction du présent document, l’utilisation de la bande passante dans une seule région était gratuite.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-335">This reduces the latency and the cost — at the time of writing, bandwidth usage within a single region is free.</span></span>  

<span data-ttu-id="9ebaa-336">Si votre application cliente n’est pas hébergée dans Azure (c’est le cas, par exemple, des applications pour appareil mobile ou des services d’entreprise locaux), le fait de placer le compte de stockage dans une région proche des appareils qui y accéderont se traduit généralement par une latence plus faible.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-336">If your client applications are not hosted within Azure (such as mobile device apps or on premises enterprise services), then again placing the storage account in a region near to the devices that will access it, will generally reduce latency.</span></span> <span data-ttu-id="9ebaa-337">En cas de distribution à grande échelle de vos clients (par exemple, certains se trouvent en Amérique du Nord et d’autres en Europe), l’utilisation de plusieurs comptes de stockage peut s’avérer judicieuse : un dans une région de l’Amérique du Nord et l’autre dans une région d’Europe.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-337">If your clients are broadly distributed (for example, some in North America, and some in Europe), then you should consider using multiple storage accounts: one located in a North American region and one in a European region.</span></span> <span data-ttu-id="9ebaa-338">Cela contribue à réduire la latence pour les utilisateurs des deux régions.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-338">This will help to reduce latency for users in both regions.</span></span> <span data-ttu-id="9ebaa-339">En règle générale, cette méthode est plus facile à mettre en œuvre si les données stockées par l’application sont spécifiques de certains utilisateurs et elle ne nécessite pas de réplication des données entre divers comptes de stockage.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-339">This approach is usually easier to implement if the data the application stores is specific to individual users, and does not require replicating data between storage accounts.</span></span>  <span data-ttu-id="9ebaa-340">Pour une distribution du contenu à grande échelle, un CDN est recommandé. Pour plus d’informations à ce sujet, voir la section suivante.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-340">For broad content distribution, a CDN is recommended – see the next section for more details.</span></span>  

### <span data-ttu-id="9ebaa-341"><a name="subheading5"></a>Distribution de contenu</span><span class="sxs-lookup"><span data-stu-id="9ebaa-341"><a name="subheading5"></a>Content Distribution</span></span>
<span data-ttu-id="9ebaa-342">Il arrive qu’une application doive diffuser le même contenu vers plusieurs utilisateurs situés au sein d’une même région ou dans des régions différentes. Il peut s’agir, par exemple, d’une vidéo de démonstration d’un produit utilisée sur la page d’accueil d’un site web.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-342">Sometimes, an application needs to serve the same content to many users (e.g. a product demo video used in the home page of a website), located in either the same or multiple regions.</span></span> <span data-ttu-id="9ebaa-343">Dans ce cas, vous devez utiliser un réseau de distribution de contenu (CDN), tel que le CDN Azure, qui utilise le stockage Azure comme origine des données.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-343">In this scenario, you should use a Content Delivery Network (CDN) such as Azure CDN, and the CDN would use Azure storage as the origin of the data.</span></span> <span data-ttu-id="9ebaa-344">Contrairement à un compte Azure Storage qui existe dans une seule région et qui ne peut pas diffuser de contenu avec une faible latence vers d’autres régions, le CDN Azure utilise des serveurs dans plusieurs centres de données répartis dans le monde entier.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-344">Unlike an Azure Storage account that exists in a single region and that cannot deliver content with low latency to other regions, Azure CDN uses servers in multiple data centers around the world.</span></span> <span data-ttu-id="9ebaa-345">De plus, un CDN peut généralement prendre en charge des limites de sortie bien plus élevées qu’un compte de stockage unique.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-345">Additionally, a CDN can typically support much higher egress limits than a single storage account.</span></span>  

<span data-ttu-id="9ebaa-346">Pour plus d’informations sur le CDN Azure, voir la page [CDN Azure](https://azure.microsoft.com/services/cdn/).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-346">For more information about Azure CDN, see [Azure CDN](https://azure.microsoft.com/services/cdn/).</span></span>  

### <span data-ttu-id="9ebaa-347"><a name="subheading6"></a>Utilisation de SAP et de CORS</span><span class="sxs-lookup"><span data-stu-id="9ebaa-347"><a name="subheading6"></a>Using SAS and CORS</span></span>
<span data-ttu-id="9ebaa-348">Lorsque vous devez autoriser du code, tel que JavaScript, dans le navigateur Web d’un utilisateur ou une application pour téléphone mobile afin d’accéder à des données dans le stockage Azure, une méthode consiste à utiliser une application dans un rôle Web en tant que proxy : l’appareil de l’utilisateur s’authentifie avec le rôle Web, qui à son tour s’authentifie avec le service de stockage.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-348">When you need to authorize code such as JavaScript in a user's web browser or a mobile phone app to access data in Azure Storage, one approach is to use an application in web role as a proxy: the user's device authenticates with the web role, which in turn authenticates with the storage service.</span></span> <span data-ttu-id="9ebaa-349">Vous évitez ainsi d’exposer vos clés de compte de stockage sur des appareils non sécurisés.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-349">In this way, you can avoid exposing your storage account keys on insecure devices.</span></span> <span data-ttu-id="9ebaa-350">Cependant, cela place une surcharge importante sur le rôle web, dans la mesure où toutes les données transférées entre l’appareil de l’utilisateur et le service de stockage doivent transiter par ce rôle.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-350">However, this places a big overhead on the web role because all the data transferred between the user's device and the storage service must pass through the web role.</span></span> <span data-ttu-id="9ebaa-351">Vous pouvez éviter d’utiliser un rôle web comme proxy pour le service de stockage en utilisant des signatures d’accès partagé (SAP), combinées parfois à des en-têtes CORS (Partage des ressources cross-origin).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-351">You can avoid using a web role as a proxy for the storage service by using Shared Access Signatures (SAS), sometimes in conjunction with Cross-Origin Resource Sharing headers (CORS).</span></span> <span data-ttu-id="9ebaa-352">Grâce au modèle SAP, vous pouvez autoriser l’appareil de votre utilisateur à adresser directement des demandes à un service de stockage par le biais d’un jeton à accès limité.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-352">Using SAS, you can allow your user's device to make requests directly to a storage service by means of a limited access token.</span></span> <span data-ttu-id="9ebaa-353">Par exemple, si un utilisateur souhaite télécharger une photo vers votre application, votre rôle web peut générer et envoyer à l’appareil de cet utilisateur un jeton SAP qui accordera des autorisations en écriture sur un conteneur ou un objet blob spécifique au cours des 30 prochaines minutes (au terme desquelles le jeton SAP expirera).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-353">For example, if a user wants to upload a photo to your application, your web role can generate and send to the user's device a SAS token that grants permission to write to a specific blob or container for the next 30 minutes (after which the SAS token expires).</span></span>

<span data-ttu-id="9ebaa-354">En règle générale, un navigateur n’autorise pas le code JavaScript d’une page hébergée par un site web sur un domaine à effectuer des opérations spécifiques telles que « PUT » sur un autre domaine.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-354">Normally, a browser will not allow JavaScript in a page hosted by a website on one domain to perform specific operations such as a "PUT" to another domain.</span></span> <span data-ttu-id="9ebaa-355">Par exemple, si vous hébergez un rôle web à l’adresse « contosomarketing.cloudapp.net » et que vous souhaitez utiliser du code JavaScript côté client pour télécharger un objet blob vers votre compte de stockage à l’adresse « contosoproducts.blob.core.windows.net », la stratégie « same origin policy » du navigateur interdit cette opération.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-355">For example, if you host a web role at "contosomarketing.cloudapp.net," and want to use client side JavaScript to upload a blob to your storage account at "contosoproducts.blob.core.windows.net," the browser's "same origin policy" will forbid this operation.</span></span> <span data-ttu-id="9ebaa-356">CORS est une fonctionnalité de navigateur qui autorise le domaine cible (dans ce cas, le compte de stockage) à indiquer au navigateur qu’il fait confiance aux demandes en provenance du domaine source (dans ce cas, le rôle web).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-356">CORS is a browser feature that allows the target domain (in this case the storage account) to communicate to the browser that it trusts requests originating in the source domain (in this case the web role).</span></span>  

<span data-ttu-id="9ebaa-357">Ces deux technologies vous aident à éviter toute charge inutile (ainsi que les goulots d’étranglement) au niveau de votre application web.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-357">Both of these technologies can help you avoid unnecessary load (and bottlenecks) on your web application.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="9ebaa-358">Ressources utiles</span><span class="sxs-lookup"><span data-stu-id="9ebaa-358">Useful Resources</span></span>
<span data-ttu-id="9ebaa-359">Pour plus d’informations sur SAP, voir la page [Signatures d’accès partagé, partie 1 : présentation du modèle SAP](../storage-dotnet-shared-access-signature-part-1.md)</span><span class="sxs-lookup"><span data-stu-id="9ebaa-359">For more information about SAS, see [Shared Access Signatures, Part 1: Understanding the SAS Model](../storage-dotnet-shared-access-signature-part-1.md).</span></span>  

<span data-ttu-id="9ebaa-360">Pour plus d’informations sur CORS, consultez [Prise en charge du service Partage des ressources cross-origin (CORS) pour les services Azure Storage](http://msdn.microsoft.com/library/azure/dn535601.aspx).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-360">For more information about CORS, see [Cross-Origin Resource Sharing (CORS) Support for the Azure Storage Services](http://msdn.microsoft.com/library/azure/dn535601.aspx).</span></span>  

### <a name="caching"></a><span data-ttu-id="9ebaa-361">Mise en cache</span><span class="sxs-lookup"><span data-stu-id="9ebaa-361">Caching</span></span>
#### <span data-ttu-id="9ebaa-362"><a name="subheading7"></a>Récupération de données</span><span class="sxs-lookup"><span data-stu-id="9ebaa-362"><a name="subheading7"></a>Getting Data</span></span>
<span data-ttu-id="9ebaa-363">En règle générale, il est préférable de récupérer des données d’un service à une seule reprise plutôt que deux fois.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-363">In general, getting data from a service once is better than getting it twice.</span></span> <span data-ttu-id="9ebaa-364">Prenons l’exemple d’une application web MVC exécutée dans un rôle web qui a déjà récupéré un objet blob de 50 Mo du service de stockage afin de le diffuser comme contenu à un utilisateur.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-364">Consider the example of an MVC web application running in a web role that has already retrieved a 50MB blob from the storage service to serve as content to a user.</span></span> <span data-ttu-id="9ebaa-365">L’application pourra, par la suite, récupérer ce même objet blob chaque fois qu’un utilisateur en fera la demande ou le mettre en cache sur un disque local et réutiliser cette version mise en cache pour les demandes ultérieures de l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-365">The application could then retrieve that same blob every time a user requests it, or it could cache it locally to disk and reuse the cached version for subsequent user requests.</span></span> <span data-ttu-id="9ebaa-366">De plus, lorsqu’un utilisateur demandera les données, l’application pourra émettre une commande GET avec un en-tête conditionnel pour l’heure de modification, évitant ainsi la récupération de l’intégralité de l’objet blob s’il n’a pas été modifié.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-366">Furthermore, whenever a user requests the data, the application could issue GET with a conditional header for modification time, which would avoid getting the entire blob if it hasn't been modified.</span></span> <span data-ttu-id="9ebaa-367">Vous pouvez appliquer ce même schéma à l’utilisation des entités de table.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-367">You can apply this same pattern to working with table entities.</span></span>  

<span data-ttu-id="9ebaa-368">Dans certains cas, vous pouvez déterminer que votre application part du principe que l’objet blob reste valide pendant une courte période après sa récupération, et que, au cours de cette période, elle ne doit pas vérifier si l’objet blob a été modifié.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-368">In some cases, you may decide that your application can assume that the blob remains valid for a short period after retrieving it, and that during this period the application does not need to check if the blob was modified.</span></span>

<span data-ttu-id="9ebaa-369">Les données de configuration, de recherche et d’autres données toujours utilisées par l’application constituent de parfaits candidats pour la mise en cache.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-369">Configuration, lookup, and other data that are always used by the application are great candidates for caching.</span></span>  

<span data-ttu-id="9ebaa-370">Pour savoir comment faire en sorte que les propriétés d’un objet blob détectent la date de la dernière modification à l’aide de .NET, consultez [Configuration et récupération des propriétés et des métadonnées](../blobs/storage-properties-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-370">For an example of how to get a blob's properties to discover the last modified date using .NET, see [Set and Retrieve Properties and Metadata](../blobs/storage-properties-metadata.md).</span></span> <span data-ttu-id="9ebaa-371">Pour plus d’informations sur les téléchargements conditionnels, consultez [Spécification d’en-têtes conditionnels pour les opérations de Service Blob](http://msdn.microsoft.com/library/azure/dd179371.aspx).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-371">For more information about conditional downloads, see [Conditionally Refresh a Local Copy of a Blob](http://msdn.microsoft.com/library/azure/dd179371.aspx).</span></span>  

#### <span data-ttu-id="9ebaa-372"><a name="subheading8"></a>Téléchargement de données par lots</span><span class="sxs-lookup"><span data-stu-id="9ebaa-372"><a name="subheading8"></a>Uploading Data in Batches</span></span>
<span data-ttu-id="9ebaa-373">Dans certains scénarios d’application, vous pouvez agréger des données en local, puis les télécharger périodiquement dans un lot au lieu de les télécharger immédiatement une à une.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-373">In some application scenarios, you can aggregate data locally, and then periodically upload it in a batch instead of uploading each piece of data immediately.</span></span> <span data-ttu-id="9ebaa-374">Par exemple, une application web peut conserver un fichier journal des activités : l’application peut soit télécharger, sous la forme d’une entité de table, les détails de chaque activité lorsqu’elle se produit (ce qui implique de nombreuses opérations de stockage), soit enregistrer les détails de l’activité dans un fichier journal local, puis les télécharger régulièrement vers un objet blob sous la forme d’un fichier délimité.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-374">For example, a web application might keep a log file of activities: the application could either upload details of every activity as it happens as a table entity (which requires many storage operations), or it could save activity details to a local log file, and then periodically upload all activity details as a delimited file to a blob.</span></span> <span data-ttu-id="9ebaa-375">Si chaque entrée du journal a une taille de 1 Ko, vous pouvez en télécharger des milliers au cours d’une seule transaction « Put Blob » (vous pouvez télécharger un objet d’une taille maximale de 64 Mo au cours d’une seule transaction).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-375">If each log entry is 1KB in size, you can upload thousands in a single "Put Blob" transaction (you can upload a blob of up to 64MB in size in a single transaction).</span></span> <span data-ttu-id="9ebaa-376">Bien sûr, si l’ordinateur local tombe en panne avant le téléchargement, vous pouvez perdre des données de journal : le développeur de l’application doit penser à la possibilité de défaillances de périphérique client ou de téléchargement.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-376">Of course, if the local machine crashes prior to the upload, you will potentially lose some log data: the application developer must design for the possibility of client device or upload failures.</span></span>  <span data-ttu-id="9ebaa-377">Si les données d’activité doivent être téléchargées pour un intervalle de temps (et pas seulement pour une seule activité), il est préférable d’utiliser des objets blob plutôt que des tables.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-377">If the activity data needs to be downloaded for timespans (not just single activity), then blobs are recommended over tables.</span></span>

### <a name="net-configuration"></a><span data-ttu-id="9ebaa-378">Configuration .NET</span><span class="sxs-lookup"><span data-stu-id="9ebaa-378">.NET Configuration</span></span>
<span data-ttu-id="9ebaa-379">Si vous utilisez .NET Framework, vous trouverez dans cette section plusieurs paramètres de configuration rapide que vous pouvez appliquer pour améliorer sensiblement les performances.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-379">If using the .NET Framework, this section lists several quick configuration settings that you can use to make significant performance improvements.</span></span>  <span data-ttu-id="9ebaa-380">Si vous utilisez un autre langage, vérifiez si des concepts similaires y sont associés.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-380">If using other languages, check to see if similar concepts apply in your chosen language.</span></span>  

#### <span data-ttu-id="9ebaa-381"><a name="subheading9"></a>Augmentation de la limite de connexions par défaut</span><span class="sxs-lookup"><span data-stu-id="9ebaa-381"><a name="subheading9"></a>Increase default connection limit</span></span>
<span data-ttu-id="9ebaa-382">Dans .NET, le code suivant augmente la limite de connexions par défaut (qui est généralement de 2 dans un environnement client ou de 10 dans un environnement de serveur) à 100.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-382">In .NET, the following code increases the default connection limit (which is usually 2 in a client environment or 10 in a server environment) to 100.</span></span> <span data-ttu-id="9ebaa-383">En règle générale, vous devez définir la valeur sur environ le nombre de threads utilisés par votre application.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-383">Typically, you should set the value to approximately the number of threads used by your application.</span></span>  

```csharp
ServicePointManager.DefaultConnectionLimit = 100; //(Or More)  
```

<span data-ttu-id="9ebaa-384">Vous devez définir la limite de connexions avant d’ouvrir une connexion.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-384">You must set the connection limit before opening any connections.</span></span>  

<span data-ttu-id="9ebaa-385">Pour les autres langages de programmation, voir la documentation correspondante pour savoir comment définir la limite de connexions.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-385">For other programming languages, see that language's documentation to determine how to set the connection limit.</span></span>  

<span data-ttu-id="9ebaa-386">Pour plus d’informations, consultez le billet de blog [Services web : connexions simultanées](http://blogs.msdn.com/b/darrenj/archive/2005/03/07/386655.aspx).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-386">For additional information, see the blog post [Web Services: Concurrent Connections](http://blogs.msdn.com/b/darrenj/archive/2005/03/07/386655.aspx).</span></span>  

#### <span data-ttu-id="9ebaa-387"><a name="subheading10"></a>Augmentation du nombre minimum de threads du pool de threads en cas d’utilisation de code synchrone avec Async Tasks</span><span class="sxs-lookup"><span data-stu-id="9ebaa-387"><a name="subheading10"></a>Increase ThreadPool Min Threads if using synchronous code with Async Tasks</span></span>
<span data-ttu-id="9ebaa-388">Ce code augmente le nombre minimum de threads du pool de threads :</span><span class="sxs-lookup"><span data-stu-id="9ebaa-388">This code will increase the thread pool min threads:</span></span>  

```csharp
ThreadPool.SetMinThreads(100,100); //(Determine the right number for your application)  
```

<span data-ttu-id="9ebaa-389">Pour plus d’informations, consultez [Méthode ThreadPool.SetMinThreads](http://msdn.microsoft.com/library/system.threading.threadpool.setminthreads%28v=vs.110%29.aspx).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-389">For more information, see [ThreadPool.SetMinThreads Method](http://msdn.microsoft.com/library/system.threading.threadpool.setminthreads%28v=vs.110%29.aspx).</span></span>  

#### <span data-ttu-id="9ebaa-390"><a name="subheading11"></a>Utilisation du nettoyage de la mémoire de .NET 4.5</span><span class="sxs-lookup"><span data-stu-id="9ebaa-390"><a name="subheading11"></a>Take advantage of .NET 4.5 Garbage Collection</span></span>
<span data-ttu-id="9ebaa-391">Utilisez .NET 4.5 ou version ultérieure pour que l’application cliente tire parti des améliorations de la fonctionnalité de nettoyage de la mémoire du serveur sur le plan des performances.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-391">Use .NET 4.5 or later for the client application to take advantage of performance improvements in server garbage collection.</span></span>

<span data-ttu-id="9ebaa-392">Pour plus d'informations, consultez l'article [Présentation des améliorations des performances de .NET 4.5](http://msdn.microsoft.com/magazine/hh882452.aspx).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-392">For more information, see the article [An Overview of Performance Improvements in .NET 4.5](http://msdn.microsoft.com/magazine/hh882452.aspx).</span></span>  

### <span data-ttu-id="9ebaa-393"><a name="subheading12"></a>Parallélisme illimité</span><span class="sxs-lookup"><span data-stu-id="9ebaa-393"><a name="subheading12"></a>Unbounded Parallelism</span></span>
<span data-ttu-id="9ebaa-394">Le parallélisme peut améliorer sensiblement les performances. Soyez toutefois prudent lorsque vous utilisez le parallélisme illimité (nombre de threads et/ou de demandes parallèles illimité) pour charger ou télécharger des données, ou lors de l’utilisation de plusieurs rôles de travail pour accéder à plusieurs partitions (conteneurs, files d’attente ou partitions de table) dans le même compte de stockage ou à plusieurs éléments d’une même partition.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-394">While parallelism can be great for performance, be careful about using unbounded parallelism (no limit on the number of threads and/or parallel requests) to upload or download data, using multiple workers to access multiple partitions (containers, queues, or table partitions) in the same storage account or to access multiple items in the same partition.</span></span> <span data-ttu-id="9ebaa-395">Si vous optez pour un parallélisme illimité, votre application peut dépasser les capacités de l’appareil client ou les objectifs d’extensibilité du compte de stockage, ce qui se traduit par des temps de latence plus importants et par une limitation.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-395">If the parallelism is unbounded, your application can exceed the client device's capabilities or the storage account's scalability targets resulting in longer latencies and throttling.</span></span>  

### <span data-ttu-id="9ebaa-396"><a name="subheading13"></a>Outils et bibliothèques clientes de stockage</span><span class="sxs-lookup"><span data-stu-id="9ebaa-396"><a name="subheading13"></a>Storage Client Libraries and Tools</span></span>
<span data-ttu-id="9ebaa-397">Utilisez toujours la version la plus récente des outils et bibliothèques clientes fournis par Microsoft.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-397">Always use the latest Microsoft provided client libraries and tools.</span></span> <span data-ttu-id="9ebaa-398">Au moment de la rédaction du présent document, des bibliothèques clientes étaient disponibles pour .NET, Windows Phone, Windows Runtime, Java et C++, et des bibliothèques en version préliminaire sont également disponibles pour d’autres langages.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-398">At the time of writing, there are client libraries available for .NET, Windows Phone, Windows Runtime, Java, and C++, as well as preview libraries for other languages.</span></span> <span data-ttu-id="9ebaa-399">Microsoft a, en outre, publié des cmdlets PowerShell et des commandes de l’interface de ligne de commande, utilisables avec Azure Storage.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-399">In addition, Microsoft has released PowerShell cmdlets and Azure CLI commands for working with Azure Storage.</span></span> <span data-ttu-id="9ebaa-400">Microsoft s’attelle au développement de ces outils dans une optique de performances, veille à leur mise à jour continue avec les versions de service les plus récentes et s’assure qu’ils répondent, en interne, à la majorité des pratiques éprouvées en termes de performances.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-400">Microsoft actively develops these tools with performance in mind, keeps them up to date with the latest service versions, and ensures they handle many of the proven performance practices internally.</span></span>  

### <a name="retries"></a><span data-ttu-id="9ebaa-401">Nouvelle tentatives</span><span class="sxs-lookup"><span data-stu-id="9ebaa-401">Retries</span></span>
#### <span data-ttu-id="9ebaa-402"><a name="subheading14"></a>Limitation/Serveur occupé</span><span class="sxs-lookup"><span data-stu-id="9ebaa-402"><a name="subheading14"></a>Throttling/ServerBusy</span></span>
<span data-ttu-id="9ebaa-403">Dans certains cas, il se peut que le service de stockage limite votre application ou qu’il soit simplement incapable de répondre à la demande en raison d’une situation temporaire, et renvoie alors un message « 503 Serveur occupé » ou « 500 Délai d’expiration de l’opération ».</span><span class="sxs-lookup"><span data-stu-id="9ebaa-403">In some cases, the storage service may throttle your application or may simply be unable to serve the request due to some transient condition and return a "503 Server busy" message or "500 Timeout".</span></span>  <span data-ttu-id="9ebaa-404">Cela peut se produire si votre application s’approche de l’un des objectifs d’extensibilité ou si le système rééquilibre vos données partitionnées pour permettre un débit plus élevé.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-404">This can happen if your application is approaching any of the scalability targets, or if the system is rebalancing your partitioned data to allow for higher throughput.</span></span>  <span data-ttu-id="9ebaa-405">L’application cliente doit généralement réessayer l’opération qui provoque cette erreur : retenter la même demande ultérieurement peut réussir.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-405">The client application should typically retry the operation that causes such an error: attempting the same request later can succeed.</span></span> <span data-ttu-id="9ebaa-406">Cependant, si le service de stockage limite votre application en raison d’un dépassement des objectifs d’extensibilité, ou si le service n’a pas été en mesure de répondre à la demande pour une autre raison, effectuer des nouvelles tentatives agressives ne fait généralement qu’aggraver le problème.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-406">However, if the storage service is throttling your application because it is exceeding scalability targets, or even if the service was unable to serve the request for some other reason, aggressive retries usually make the problem worse.</span></span> <span data-ttu-id="9ebaa-407">C’est pourquoi il est conseillé d’opter pour une interruption exponentielle (il s’agit du comportement par défaut des bibliothèques clientes).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-407">For this reason, you should use an exponential back off (the client libraries default to this behavior).</span></span> <span data-ttu-id="9ebaa-408">Votre application peut, par exemple, effectuer une nouvelle tentative après 2 secondes, puis 4 secondes, 10 secondes, 30 secondes avant d’abandonner complètement.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-408">For example, your application may retry after 2 seconds, then 4 seconds, then 10 seconds, then 30 seconds, and then give up completely.</span></span> <span data-ttu-id="9ebaa-409">Cela se traduit par un allégement sensible de la charge de l’application sur le service, au lieu d’aggraver le problème.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-409">This behavior results in your application significantly reducing its load on the service rather than exacerbating any problems.</span></span>  

<span data-ttu-id="9ebaa-410">Les erreurs de connectivité ne sont pas dues à une limitation et sont généralement temporaires. Dès lors, de nouvelles tentatives peuvent être effectuées immédiatement.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-410">Note that connectivity errors can be retried immediately, because they are not the result of throttling and are expected to be transient.</span></span>  

#### <span data-ttu-id="9ebaa-411"><a name="subheading15"></a>Erreurs non renouvelables</span><span class="sxs-lookup"><span data-stu-id="9ebaa-411"><a name="subheading15"></a>Non-Retryable Errors</span></span>
<span data-ttu-id="9ebaa-412">Les bibliothèques clientes peuvent faire la distinction entre les erreurs renouvelables et celles qui ne le sont pas.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-412">The client libraries are aware of which errors are retry-able and which are not.</span></span> <span data-ttu-id="9ebaa-413">Cependant, si vous écrivez votre propre code par rapport à l’API REST de stockage, n’oubliez pas certaines erreurs non renouvelables : par exemple, une réponse 400 (Bad Request) indique que l’application cliente a envoyé une demande qui n’a pas pu être traitée car elle n’était pas au format attendu.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-413">However, if you are writing your own code against the storage REST API, remember there are some errors that you should not retry: for example, a 400 (Bad Request) response indicates that the client application sent a request that could not be processed because it was not in an expected form.</span></span> <span data-ttu-id="9ebaa-414">Renvoyer cette demande générera à chaque fois la même réponse. La renouveler ne sert donc à rien !</span><span class="sxs-lookup"><span data-stu-id="9ebaa-414">Resending this request will result the same response every time, so there is no point in retrying it.</span></span> <span data-ttu-id="9ebaa-415">Si vous écrivez votre propre code pour l’API REST de stockage, vous devez connaître la signification des codes d’erreur et, le cas échéant, la méthode de renouvellement à appliquer pour chacun d’eux.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-415">If you are writing your own code against the storage REST API, be aware of what the error codes mean and the proper way to retry (or not) for each of them.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="9ebaa-416">Ressources utiles</span><span class="sxs-lookup"><span data-stu-id="9ebaa-416">Useful Resources</span></span>
<span data-ttu-id="9ebaa-417">Pour plus d’informations sur les codes d’erreur de stockage, voir la page [Codes d’état et codes d’erreur](http://msdn.microsoft.com/library/azure/dd179382.aspx) sur le site web Microsoft Azure.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-417">For more information about storage error codes, see [Status and Error Codes](http://msdn.microsoft.com/library/azure/dd179382.aspx) on the Microsoft Azure web site.</span></span>  

## <a name="blobs"></a><span data-ttu-id="9ebaa-418">Objets blob</span><span class="sxs-lookup"><span data-stu-id="9ebaa-418">Blobs</span></span>
<span data-ttu-id="9ebaa-419">Outre les pratiques éprouvées pour [Tous les services](#allservices) décrites précédemment, les pratiques ci-dessous s'appliquent spécifiquement au service BLOB.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-419">In addition to the proven practices for [All Services](#allservices) described previously, the following proven practices apply specifically to the blob service.</span></span>  

### <a name="blob-specific-scalability-targets"></a><span data-ttu-id="9ebaa-420">Objectifs d’extensibilité propres aux objets blob</span><span class="sxs-lookup"><span data-stu-id="9ebaa-420">Blob-Specific Scalability Targets</span></span>
#### <span data-ttu-id="9ebaa-421"><a name="subheading46"></a>Plusieurs clients accédant simultanément à un seul objet</span><span class="sxs-lookup"><span data-stu-id="9ebaa-421"><a name="subheading46"></a>Multiple clients accessing a single object concurrently</span></span>
<span data-ttu-id="9ebaa-422">Si vous avez un grand nombre de clients qui accèdent simultanément à un seul objet, vous devrez prendre en compte les objectifs d’évolutivité de compte de stockage et par objet.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-422">If you have a large number of clients accessing a single object concurrently you will need to consider per object and storage account scalability targets.</span></span> <span data-ttu-id="9ebaa-423">Le nombre exact de clients qui peuvent accéder à un objet unique varie en fonction de facteurs tels que le nombre de clients demandant l’accès à l’objet simultanément, la taille de l’objet, les conditions réseau, etc.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-423">The exact number of clients that can access a single object will vary depending on factors such as the number of clients requesting the object simultaneously, the size of the object, network conditions etc.</span></span>

<span data-ttu-id="9ebaa-424">Si l’objet peut être distribué via un CDN, comme les images ou les vidéos provenant d’un site web, vous devez utiliser un CDN.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-424">If the object can be distributed through a CDN such as images or videos served from a website then you should use a CDN.</span></span> <span data-ttu-id="9ebaa-425">Voir [ici](#subheading5).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-425">See [here](#subheading5).</span></span>

<span data-ttu-id="9ebaa-426">Dans d’autres scénarios tels que les simulations scientifiques où les données sont confidentielles, vous disposez de deux options.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-426">In other scenarios such as scientific simulations where the data is confidential you have two options.</span></span> <span data-ttu-id="9ebaa-427">La première consiste à échelonner l’accès de votre charge de travail de façon à ce que l’objet soit accessible sur une période de temps au lieu d’un accès simultané.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-427">The first is to stagger your workload's access such that the object is accessed over a period of time vs being accessed simultaneously.</span></span> <span data-ttu-id="9ebaa-428">Sinon, vous pouvez copier temporairement l’objet sur plusieurs comptes de stockage pour améliorer le nombre total d’E/S par objet et sur les comptes de stockage.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-428">Alternatively, you can temporarily copy the object to multiple storage accounts thus increasing the total IOPS per object and across storage accounts.</span></span> <span data-ttu-id="9ebaa-429">Dans un test limité, nous avons constaté qu’environ 25 machines virtuelles pouvaient télécharger simultanément un objet blob de 100 Go (chaque machine virtuelle téléchargeait en parallèle à l’aide de 32 threads).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-429">In limited testing we found that around 25 VMs could simultaneously download a 100GB blob in parallel (each VM was parallelizing the download using 32 threads).</span></span> <span data-ttu-id="9ebaa-430">Si vous avez 100 clients devant accéder à l’objet, copiez-le dans un deuxième compte de stockage et attribuez l’accès au premier objet blob aux 50 premières machines virtuelles, puis les 50 machines virtuelles suivantes accèdent au deuxième objet blob.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-430">If you had 100 clients needing to access the object, first copy it to a second storage account and then have the first 50 VMs access the first blob and the second 50 VMs access the second blob.</span></span> <span data-ttu-id="9ebaa-431">Les résultats varient selon le comportement de vos applications. Nous vous conseillons de tester ceci pendant la conception.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-431">Results will vary depending on your applications behavior so you should test this during design.</span></span> 

#### <span data-ttu-id="9ebaa-432"><a name="subheading16"></a>Bande passante et opérations par objet blob</span><span class="sxs-lookup"><span data-stu-id="9ebaa-432"><a name="subheading16"></a>Bandwidth and operations per Blob</span></span>
<span data-ttu-id="9ebaa-433">Le débit maximal en lecture ou en écriture sur un objet blob unique est de 60 Mo/seconde (soit environ 480 Mbits/s), ce qui est supérieur aux capacités de nombreux réseaux côté client (y compris la carte réseau physique qui équipe l’appareil client).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-433">You can read or write to a single blob at up to a maximum of 60 MB/second (this is approximately 480 Mbps which exceeds the capabilities of many client side networks (including the physical NIC on the client device).</span></span> <span data-ttu-id="9ebaa-434">De plus, un seul objet blob prend en charge plus de 500 demandes par seconde.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-434">In addition, a single blob supports up to 500 requests per second.</span></span> <span data-ttu-id="9ebaa-435">Si vous risquez de dépasser ces limites lorsque plusieurs clients doivent lire le même objet blob, il est conseillé d’utiliser un CDN pour distribuer l’objet blob.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-435">If you have multiple clients that need to read the same blob and you might exceed these limits, you should consider using a CDN for distributing the blob.</span></span>  

<span data-ttu-id="9ebaa-436">Pour plus d’informations sur le débit cible pour les objets blob, consultez [Objectifs de performance et d’extensibilité d’Azure Storage](storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-436">For more information about target throughput for blobs, see [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span>  

### <a name="copying-and-moving-blobs"></a><span data-ttu-id="9ebaa-437">Copie et déplacement d’objets blob</span><span class="sxs-lookup"><span data-stu-id="9ebaa-437">Copying and Moving Blobs</span></span>
#### <span data-ttu-id="9ebaa-438"><a name="subheading17"></a>Copie d’un objet blob</span><span class="sxs-lookup"><span data-stu-id="9ebaa-438"><a name="subheading17"></a>Copy Blob</span></span>
<span data-ttu-id="9ebaa-439">L’API REST de stockage version 2012-02-12 a introduit la fonctionnalité utile de copier des objets blob entre les comptes : une application cliente peut indiquer au service de stockage de copier un objet blob d’une autre source (éventuellement dans un compte de stockage différent), puis de laisser au service le soin d’effectuer la copie de manière asynchrone.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-439">The storage REST API version 2012-02-12 introduced the useful ability to copy blobs across accounts: a client application can instruct the storage service to copy a blob from another source (possibly in a different storage account), and then let the service perform the copy asynchronously.</span></span> <span data-ttu-id="9ebaa-440">Cela peut réduire sensiblement la bande passante requise pour l’application lorsque vous faites migrer des données depuis d’autres comptes de stockage, dans la mesure où vous ne devez pas envoyer et télécharger les données.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-440">This can significantly reduce the bandwidth needed for the application when you are migrating data from other storage accounts because you do not need to download and upload the data.</span></span>  

<span data-ttu-id="9ebaa-441">Il convient cependant de tenir compte du fait que lorsque vous effectuez une copie entre des comptes de stockage, vous ne pouvez pas savoir avec certitude quand l’opération prendra fin.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-441">One consideration, however, is that, when copying between storage accounts, there is no time guarantee on when the copy will complete.</span></span> <span data-ttu-id="9ebaa-442">Si votre application doit procéder à une copie rapide d’un objet blob sous votre supervision, il peut être préférable de le copier en le téléchargeant sur une machine virtuelle, puis en le transférant vers la destination.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-442">If your application needs to complete a blob copy quickly under your control, it may be better to copy the blob by downloading it to a VM and then uploading it to the destination.</span></span>  <span data-ttu-id="9ebaa-443">Pour que cette opération se déroule dans les meilleures conditions possibles, assurez-vous que la copie est effectuée par une machine virtuelle exécutée dans la même région Azure, sans quoi les conditions réseau affecteront plus que probablement les performances de copie.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-443">For full predictability in that situation, ensure that the copy is performed by a VM running in the same Azure region, or else network conditions may (and probably will) affect your copy performance.</span></span>  <span data-ttu-id="9ebaa-444">Vous pouvez, en outre, surveiller la progression d’une copie asynchrone via un programme.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-444">In addition, you can monitor the progress of an asynchronous copy programmatically.</span></span>  

<span data-ttu-id="9ebaa-445">Nous attirons votre attention sur le fait que les copies effectuées au sein d’un même compte de stockage sont généralement plus rapides.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-445">Note that copies within the same storage account itself are generally completed quickly.</span></span>  

<span data-ttu-id="9ebaa-446">Pour plus d’informations, consultez [Copie d’un objet blob](http://msdn.microsoft.com/library/azure/dd894037.aspx).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-446">For more information, see [Copy Blob](http://msdn.microsoft.com/library/azure/dd894037.aspx).</span></span>  

#### <span data-ttu-id="9ebaa-447"><a name="subheading18"></a>Utilisation d’AzCopy</span><span class="sxs-lookup"><span data-stu-id="9ebaa-447"><a name="subheading18"></a>Use AzCopy</span></span>
<span data-ttu-id="9ebaa-448">L’équipe Stockage Azure a développé un outil en ligne de commande baptisé « AzCopy », destiné à faciliter le transfert en bloc de nombreux objets blob entre des comptes de stockage.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-448">The Azure Storage team has released a command-line tool "AzCopy" that is meant to help with bulk transferring many blobs to, from, and across storage accounts.</span></span>  <span data-ttu-id="9ebaa-449">Cet outil est optimisé pour ce scénario et peut générer des taux de transfert élevés.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-449">This tool is optimized for this scenario, and can achieve high transfer rates.</span></span>  <span data-ttu-id="9ebaa-450">Il est vivement conseillé de l’utiliser pour les opérations de chargement, de téléchargement et de copie en bloc.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-450">Its use is encouraged for bulk upload, download, and copy scenarios.</span></span> <span data-ttu-id="9ebaa-451">Pour plus d’informations et pour accéder au téléchargement, consultez [Transfert de données avec l’utilitaire de ligne de commande AzCopy](storage-use-azcopy.md).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-451">To learn more about it and download it, see [Transfer data with the AzCopy Command-Line Utility](storage-use-azcopy.md).</span></span>  

#### <span data-ttu-id="9ebaa-452"><a name="subheading19"></a>Service Azure Import/Export</span><span class="sxs-lookup"><span data-stu-id="9ebaa-452"><a name="subheading19"></a>Azure Import/Export Service</span></span>
<span data-ttu-id="9ebaa-453">Pour les très gros volumes de données (plus de 1 To), Azure Storage propose le service Import/Export qui permet de transférer et de télécharger des données à partir d’un stockage d’objets blob en expédiant des disques durs.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-453">For very large volumes of data (more than 1TB), the Azure Storage offers the Import/Export service, which allows for uploading and downloading from blob storage by shipping hard drives.</span></span>  <span data-ttu-id="9ebaa-454">Vous pouvez copier vos données sur un disque dur et l’envoyer à Microsoft en vue du transfert des données, ou envoyer un disque dur vierge à Microsoft en vue de leur téléchargement.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-454">You can put your data on a hard drive and send it to Microsoft for upload, or send a blank hard drive to Microsoft to download data.</span></span>  <span data-ttu-id="9ebaa-455">Pour plus d'informations, consultez [Utilisation du service Import/Export Microsoft Azure pour transférer des données vers le stockage d'objets blob](../storage-import-export-service.md).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-455">For more information, see [Use the Microsoft Azure Import/Export Service to Transfer Data to Blob Storage](../storage-import-export-service.md).</span></span>  <span data-ttu-id="9ebaa-456">Cela peut se révéler bien plus pratique que de transférer un tel volume de données sur le réseau.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-456">This can be much more efficient than uploading/downloading this volume of data over the network.</span></span>  

### <span data-ttu-id="9ebaa-457"><a name="subheading20"></a>Utilisation de métadonnées</span><span class="sxs-lookup"><span data-stu-id="9ebaa-457"><a name="subheading20"></a>Use metadata</span></span>
<span data-ttu-id="9ebaa-458">Le service BLOB prend en charge les demandes HEAD, lesquelles peuvent inclure des métadonnées sur un objet blob.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-458">The blob service supports head requests, which can include metadata about the blob.</span></span> <span data-ttu-id="9ebaa-459">Par exemple, si votre application doit extraire les données EXIF d’une photo, elle peut récupérer la photo en question, puis procéder à l’extraction.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-459">For example, if your application needed the EXIF data out of a photo, it could retrieve the photo and extract it.</span></span> <span data-ttu-id="9ebaa-460">Pour économiser la bande passante et améliorer les performances, votre application peut stocker les données EXIF dans les métadonnées de l’objet blob lorsque l’application a téléchargé la photo : vous pouvez ensuite récupérer les données EXIF dans les métadonnées à l’aide d’une simple demande HEAD, ce qui permet d’économiser beaucoup de bande passante et de temps de traitement, nécessaires pour extraire les données EXIF chaque fois que l’objet blob est lu.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-460">To save bandwidth and improve performance, your application could store the EXIF data in the blob's metadata when the application uploaded the photo: you can then retrieve the EXIF data in metadata using only a HEAD request, saving significant bandwidth and the processing time needed to extract the EXIF data each time the blob is read.</span></span> <span data-ttu-id="9ebaa-461">Cela s’avère particulièrement utile lorsque vous avez simplement besoin des métadonnées, et non de tout le contenu d’un objet blob.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-461">This would be useful in scenarios where you only need the metadata, and not the full content of a blob.</span></span>  <span data-ttu-id="9ebaa-462">Un maximum de 8 Ko de métadonnées peut être stocké par objet blob (le service refusera les demandes de stockage supérieures). Dès lors, si vos données ne respectent pas cette taille, vous ne pourrez pas utiliser cette méthode.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-462">Note that only 8 KB of metadata can be stored per blob (the service will not accept a request to store more than that), so if the data does not fit in that size, you may not be able to use this approach.</span></span>  

<span data-ttu-id="9ebaa-463">Pour savoir comment récupérer les métadonnées d’un objet blob à l’aide de .NET, consultez [Configuration et récupération des propriétés et des métadonnées](../blobs/storage-properties-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-463">For an example of how to get a blob's metadata using .NET, see [Set and Retrieve Properties and Metadata](../blobs/storage-properties-metadata.md).</span></span>  

### <a name="uploading-fast"></a><span data-ttu-id="9ebaa-464">Téléchargement rapide</span><span class="sxs-lookup"><span data-stu-id="9ebaa-464">Uploading Fast</span></span>
<span data-ttu-id="9ebaa-465">Pour télécharger les objets blob rapidement, la première question est : téléchargez-vous un blob ou plusieurs ?</span><span class="sxs-lookup"><span data-stu-id="9ebaa-465">To upload blobs fast, the first question to answer is: are you uploading one blob or many?</span></span>  <span data-ttu-id="9ebaa-466">Utilisez les instructions ci-dessous pour déterminer la méthode correcte en fonction de votre scénario.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-466">Use the below guidance to determine the correct method to use depending on your scenario.</span></span>  

#### <span data-ttu-id="9ebaa-467"><a name="subheading21"></a>Téléchargement rapide d’un objet blob volumineux</span><span class="sxs-lookup"><span data-stu-id="9ebaa-467"><a name="subheading21"></a>Uploading one large blob quickly</span></span>
<span data-ttu-id="9ebaa-468">Pour télécharger rapidement un seul objet blob de grande taille, votre application cliente doit télécharger ses blocs ou pages en parallèle (en tenant compte des objectifs d’extensibilité des différents objets blob et du compte de stockage dans son ensemble).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-468">To upload a single large blob quickly, your client application should upload its blocks or pages in parallel (being mindful of the scalability targets for individual blobs and the storage account as a whole).</span></span>  <span data-ttu-id="9ebaa-469">Notez que les bibliothèques clientes de stockage RTM fournies par Microsoft (.NET, Java) offrent cette possibilité.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-469">Note that the official Microsoft-provided RTM Storage Client libraries (.NET, Java) have the ability to do this.</span></span>  <span data-ttu-id="9ebaa-470">Pour chacune des bibliothèques, utilisez l’objet ou la propriété indiqué ci-dessous pour définir le niveau de simultanéité :</span><span class="sxs-lookup"><span data-stu-id="9ebaa-470">For each of the libraries, use the below specified object/property to set the level of concurrency:</span></span>  

* <span data-ttu-id="9ebaa-471">.NET : définissez ParallelOperationThreadCount sur un objet BlobRequestOptions à utiliser.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-471">.NET: Set ParallelOperationThreadCount on a BlobRequestOptions object to be used.</span></span>
* <span data-ttu-id="9ebaa-472">Java/Android : utilisez BlobRequestOptions.setConcurrentRequestCount()</span><span class="sxs-lookup"><span data-stu-id="9ebaa-472">Java/Android: Use BlobRequestOptions.setConcurrentRequestCount()</span></span>
* <span data-ttu-id="9ebaa-473">Node.js : utilisez parallelOperationThreadCount sur les options de demande ou sur le service BLOB.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-473">Node.js: Use parallelOperationThreadCount on either the request options or on the blob service.</span></span>
* <span data-ttu-id="9ebaa-474">C++ : utilisez la méthode blob_request_options::set_parallelism_factor.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-474">C++: Use the blob_request_options::set_parallelism_factor method.</span></span>

#### <span data-ttu-id="9ebaa-475"><a name="subheading22"></a>Téléchargement rapide de nombreux objets blob</span><span class="sxs-lookup"><span data-stu-id="9ebaa-475"><a name="subheading22"></a>Uploading many blobs quickly</span></span>
<span data-ttu-id="9ebaa-476">Pour télécharger rapidement de nombreux objets blob, effectuez cette opération en parallèle.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-476">To upload many blobs quickly, upload blobs in parallel.</span></span> <span data-ttu-id="9ebaa-477">Cela s’avère plus rapide que de télécharger des objets blob individuels avec des téléchargements de blocs parallèles, dans la mesure où le transfert est réparti entre plusieurs partitions du service de stockage.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-477">This is faster than uploading single blobs at a time with parallel block uploads because it spreads the upload across multiple partitions of the storage service.</span></span> <span data-ttu-id="9ebaa-478">Dans le cas d’un objet blob unique, le débit pris en charge est seulement de 60 Mo/seconde (environ 480 Mbits/s).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-478">A single blob only supports a throughput of 60 MB/second (approximately 480 Mbps).</span></span> <span data-ttu-id="9ebaa-479">Au moment de la rédaction du présent document, un compte LRS basé sur US prenait en charge un débit de 20 Gbit/s en entrée, soit bien plus que le débit pris en charge par un objet blob individuel.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-479">At the time of writing, a US-based LRS account supports up to 20 Gbps ingress which is far more than the throughput supported by an individual blob.</span></span>  <span data-ttu-id="9ebaa-480">[AzCopy](#subheading18) effectue des téléchargements en parallèle et son utilisation est recommandée pour ce scénario.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-480">[AzCopy](#subheading18) performs uploads in parallel by default, and is recommended for this scenario.</span></span>  

### <span data-ttu-id="9ebaa-481"><a name="subheading23"></a>Choix du type d’objet blob approprié</span><span class="sxs-lookup"><span data-stu-id="9ebaa-481"><a name="subheading23"></a>Choosing the correct type of blob</span></span>
<span data-ttu-id="9ebaa-482">Azure Storage prend en charge deux types d’objet blob : *de pages* et *de blocs*.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-482">Azure Storage supports two types of blob: *page* blobs and *block* blobs.</span></span> <span data-ttu-id="9ebaa-483">Pour un scénario d’utilisation donné, le type d’objet blob choisi affecte les performances et l’extensibilité de la solution.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-483">For a given usage scenario, your choice of blob type will affect the performance and scalability of your solution.</span></span> <span data-ttu-id="9ebaa-484">Les objets blob de blocs sont utiles si vous souhaitez télécharger efficacement de grandes quantités de données : par exemple, une application cliente a besoin de télécharger des photos ou vidéos sur le stockage d’objets blob.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-484">Block blobs are appropriate when you want to upload large amounts of data efficiently: for example, a client application may need to upload photos or video to blob storage.</span></span> <span data-ttu-id="9ebaa-485">Les objets blob de pages sont appropriées si l’application doit effectuer des écritures aléatoires sur les données : par exemple, les disques durs virtuels d’Azure sont stockés en tant qu’objets blob de pages.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-485">Page blobs are appropriate if the application needs to perform random writes on the data: for example, Azure VHDs are stored as page blobs.</span></span>  

<span data-ttu-id="9ebaa-486">Pour plus d’informations, consultez [Présentation des objets blob de blocs, des objets blob d’ajout et des objets blob de pages](http://msdn.microsoft.com/library/azure/ee691964.aspx).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-486">For more information, see [Understanding Block Blobs, Append Blobs, and Page Blobs](http://msdn.microsoft.com/library/azure/ee691964.aspx).</span></span>  

## <a name="tables"></a><span data-ttu-id="9ebaa-487">Tables</span><span class="sxs-lookup"><span data-stu-id="9ebaa-487">Tables</span></span>
<span data-ttu-id="9ebaa-488">Outre les pratiques éprouvées pour [Tous les services](#allservices) décrites précédemment, les pratiques ci-dessous s'appliquent spécifiquement au service de Table.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-488">In addition to the proven practices for [All Services](#allservices) described previously, the following proven practices apply specifically to the table service.</span></span>  

### <span data-ttu-id="9ebaa-489"><a name="subheading24"></a>Objectifs d’extensibilité propres aux tables</span><span class="sxs-lookup"><span data-stu-id="9ebaa-489"><a name="subheading24"></a>Table-Specific Scalability Targets</span></span>
<span data-ttu-id="9ebaa-490">Outre les limitations de bande passante d’un compte de stockage complet, les tables possèdent leur propre limite d’extensibilité.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-490">In addition to the bandwidth limitations of an entire storage account, tables have the following specific scalability limit.</span></span>  <span data-ttu-id="9ebaa-491">Notez que le système équilibre la charge à mesure que le trafic augmente. Cependant, en cas de salves de trafic, il peut s’avérer impossible d’obtenir immédiatement ce volume de débit.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-491">Note that the system will load balance as your traffic increases, but if your traffic has sudden bursts, you may not be able to get this volume of throughput immediately.</span></span>  <span data-ttu-id="9ebaa-492">En cas de pic de trafic, une limitation et/ou des délais d’attente risquent de se produire tandis que le service de stockage décharge automatiquement votre table.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-492">If your pattern has bursts, you should expect to see throttling and/or timeouts during the burst as the storage service automatically load balances out your table.</span></span>  <span data-ttu-id="9ebaa-493">Une accélération progressive offre généralement de meilleurs résultats, dans la mesure où cela donne au système le temps d’équilibrer la charge de manière appropriée.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-493">Ramping up slowly generally has better results as it gives the system time to load balance appropriately.</span></span>  

#### <a name="entities-per-second-account"></a><span data-ttu-id="9ebaa-494">Entités par seconde (compte)</span><span class="sxs-lookup"><span data-stu-id="9ebaa-494">Entities per Second (Account)</span></span>
<span data-ttu-id="9ebaa-495">S’agissant de l’accès aux tables, la limite d’extensibilité est de 20 000 entités (d’une taille individuelle de 1 Ko) par seconde pour un compte.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-495">The scalability limit for accessing tables is up to 20,000 entities (1KB each) per second for an account.</span></span>  <span data-ttu-id="9ebaa-496">En règle générale, chaque entité insérée, mise à jour, supprimée ou analysée est comptabilisée.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-496">In general, each entity that is inserted, updated, deleted, or scanned counts toward this target.</span></span>  <span data-ttu-id="9ebaa-497">Une insertion par lots composée de 100 entités compte donc pour 100 entités.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-497">So a batch insert that contains 100 entities would count as 100 entities.</span></span>  <span data-ttu-id="9ebaa-498">De même, une requête qui analyse 1 000 entités et en renvoie 5 compte pour 1 000 entités.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-498">A query that scans 1000 entities and returns 5 would count as 1000 entities.</span></span>  

#### <a name="entities-per-second-partition"></a><span data-ttu-id="9ebaa-499">Entités par seconde (partition)</span><span class="sxs-lookup"><span data-stu-id="9ebaa-499">Entities per Second (Partition)</span></span>
<span data-ttu-id="9ebaa-500">Dans une partition unique, l’objectif d’extensibilité pour l’accès aux tables est de 2 000 entités (d’une taille individuelle de 1 Ko) par seconde, en utilisant le même mode de calcul que celui décrit dans la section précédente.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-500">Within a single partition, the scalability target for accessing tables is 2,000 entities (1KB each) per second, using the same counting as described in the previous section.</span></span>  

### <a name="configuration"></a><span data-ttu-id="9ebaa-501">Configuration</span><span class="sxs-lookup"><span data-stu-id="9ebaa-501">Configuration</span></span>
<span data-ttu-id="9ebaa-502">Cette section décrit les paramètres de configuration rapide que vous pouvez utiliser pour améliorer sensiblement les performances du service de Table :</span><span class="sxs-lookup"><span data-stu-id="9ebaa-502">This section lists several quick configuration settings that you can use to make significant performance improvements in the table service:</span></span>  

#### <span data-ttu-id="9ebaa-503"><a name="subheading25"></a>Utilisation de JSON</span><span class="sxs-lookup"><span data-stu-id="9ebaa-503"><a name="subheading25"></a>Use JSON</span></span>
<span data-ttu-id="9ebaa-504">Depuis la version 2013-08-15 du service de stockage, le service de Table prend en charge l’utilisation de JSON plutôt que le format AtomPub XML pour transférer des données de table.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-504">Beginning with storage service version 2013-08-15, the table service supports using JSON instead of the XML-based AtomPub format for transferring table data.</span></span> <span data-ttu-id="9ebaa-505">Cela permet de réduire la taille de la charge utile de quelque 75 % et d’améliorer sensiblement les performances de votre application.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-505">This can reduce payload sizes by as much as 75% and can significantly improve the performance of your application.</span></span>

<span data-ttu-id="9ebaa-506">Pour plus d’informations, consultez [Tables Microsoft Azure : présentation de JSON](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx) et [Format de charge utile pour les opérations du service de Table](http://msdn.microsoft.com/library/azure/dn535600.aspx).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-506">For more information, see the post [Microsoft Azure Tables: Introducing JSON](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx) and [Payload Format for Table Service Operations](http://msdn.microsoft.com/library/azure/dn535600.aspx).</span></span>

#### <span data-ttu-id="9ebaa-507"><a name="subheading26"></a>Désactivation de Nagle</span><span class="sxs-lookup"><span data-stu-id="9ebaa-507"><a name="subheading26"></a>Nagle Off</span></span>
<span data-ttu-id="9ebaa-508">L’algorithme de Nagle est utilisé à grande échelle sur les réseaux TCP/IP en vue d’améliorer les performances du réseau.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-508">Nagle's algorithm is widely implemented across TCP/IP networks as a means to improve network performance.</span></span> <span data-ttu-id="9ebaa-509">Cependant, il n’est pas idéal dans toutes les situations (c’est le cas, par exemple, dans les environnements très interactifs).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-509">However, it is not optimal in all circumstances (such as highly interactive environments).</span></span> <span data-ttu-id="9ebaa-510">Pour le stockage Azure, l’algorithme de Nagle a un impact négatif sur les performances des demandes adressées aux services de table et de file d’attente. Vous devez donc le désactiver si cela s’avère possible.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-510">For Azure Storage, Nagle's algorithm has a negative impact on the performance of requests to the table and queue services, and you should disable it if possible.</span></span>  

<span data-ttu-id="9ebaa-511">Pour plus d’informations, voir le billet de blog [Algorithme Nagle et petites demandes : des rapports peu amicaux](http://blogs.msdn.com/b/windowsazurestorage/archive/2010/06/25/nagle-s-algorithm-is-not-friendly-towards-small-requests.aspx) qui explique les problèmes d’interaction entre l’algorithme de Nagle et les demandes de table et de file d’attente. Vous y apprendrez également comment le désactiver dans votre application cliente.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-511">For more information, see our blog post [Nagle's Algorithm is Not Friendly towards Small Requests](http://blogs.msdn.com/b/windowsazurestorage/archive/2010/06/25/nagle-s-algorithm-is-not-friendly-towards-small-requests.aspx), which explains why Nagle's algorithm interacts poorly with table and queue requests, and shows how to disable it in your client application.</span></span>  

### <a name="schema"></a><span data-ttu-id="9ebaa-512">Schéma</span><span class="sxs-lookup"><span data-stu-id="9ebaa-512">Schema</span></span>
<span data-ttu-id="9ebaa-513">Le mode de représentation et d’interrogation de vos données constitue le principal facteur ayant une incidence sur les performances du service de Table.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-513">How you represent and query your data is the biggest single factor that affects the performance of the table service.</span></span> <span data-ttu-id="9ebaa-514">Bien que chaque application soit différente, cette section énumère quelques pratiques générales concernant les points suivants :</span><span class="sxs-lookup"><span data-stu-id="9ebaa-514">While every application is different, this section outlines some general proven practices that relate to:</span></span>  

* <span data-ttu-id="9ebaa-515">Conception de tables</span><span class="sxs-lookup"><span data-stu-id="9ebaa-515">Table design</span></span>
* <span data-ttu-id="9ebaa-516">Requêtes efficaces</span><span class="sxs-lookup"><span data-stu-id="9ebaa-516">Efficient queries</span></span>
* <span data-ttu-id="9ebaa-517">Mises à jour de données efficaces</span><span class="sxs-lookup"><span data-stu-id="9ebaa-517">Efficient data updates</span></span>  

#### <span data-ttu-id="9ebaa-518"><a name="subheading27"></a>Tables et partitions</span><span class="sxs-lookup"><span data-stu-id="9ebaa-518"><a name="subheading27"></a>Tables and partitions</span></span>
<span data-ttu-id="9ebaa-519">Les tables sont divisées en partitions.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-519">Tables are divided into partitions.</span></span> <span data-ttu-id="9ebaa-520">Toutes les entités stockées dans une partition partagent la même clé de partition et sont associées à une clé de ligne pour les identifier dans cette partition.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-520">Every entity stored in a partition shares the same partition key and has a unique row key to identify it within that partition.</span></span> <span data-ttu-id="9ebaa-521">Les partitions offrent des avantages, mais elles s’accompagnent également de limites d’extensibilité.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-521">Partitions provide benefits but also introduce scalability limits.</span></span>  

* <span data-ttu-id="9ebaa-522">Avantages : vous pouvez mettre à jour des entités d’une même partition au cours d’une seule transaction atomique par lots pouvant contenir jusqu’à 100 opérations de stockage distinctes (taille totale limite de 4 Mo).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-522">Benefits: You can update entities in the same partition in a single, atomic, batch transaction that contains up to 100 separate storage operations (limit of 4MB total size).</span></span> <span data-ttu-id="9ebaa-523">En partant du principe que le même nombre d’entités doit être récupéré, vous pouvez également interroger plus efficacement les données d’une seule partition que celles qui couvrent plusieurs partitions (vous trouverez d’autres conseils sur l’interrogation des données de table dans la suite de ce document).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-523">Assuming the same number of entities to be retrieved, you can also query data within a single partition more efficiently than data that spans partitions (though read on for further recommendations on querying table data).</span></span>
* <span data-ttu-id="9ebaa-524">Limite d’extensibilité : l’accès aux entités stockées dans une seule partition ne peut pas faire l’objet d’un équilibrage de la charge, car les partitions prennent en charge les transactions atomiques par lots.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-524">Scalability limit: Access to entities stored in a single partition cannot be load-balanced because partitions support atomic batch transactions.</span></span> <span data-ttu-id="9ebaa-525">C’est pourquoi l’objectif d’extensibilité d’une partition de table individuelle est inférieur à celui du service de Table dans son ensemble.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-525">For this reason, the scalability target for an individual table partition is lower than for the table service as a whole.</span></span>  

<span data-ttu-id="9ebaa-526">Compte tenu des caractéristiques des tables et des partitions, il est conseillé d’adopter les principes de conception suivants :</span><span class="sxs-lookup"><span data-stu-id="9ebaa-526">Because of these characteristics of tables and partitions, you should adopt the following design principles:</span></span>  

* <span data-ttu-id="9ebaa-527">Les données que votre application cliente a fréquemment mises à jour ou interrogées dans la même unité de travail logique doivent être situées dans la même partition.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-527">Data that your client application frequently updated or queried in the same logical unit of work should be located in the same partition.</span></span>  <span data-ttu-id="9ebaa-528">Cela peut être dû au fait que votre application agrège les écritures ou que vous souhaitiez tirer parti d’opérations atomiques par lots.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-528">This may be because your application is aggregating writes, or because you want to take advantage of atomic batch operations.</span></span>  <span data-ttu-id="9ebaa-529">Ajoutons encore que les données d’une seule partition peuvent être interrogées plus efficacement dans une seule requête que les données de plusieurs partitions.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-529">Also, data in a single partition can be more efficiently queried in a single query than data across partitions.</span></span>
* <span data-ttu-id="9ebaa-530">Les données que votre application cliente n’insère pas, ne met pas à jour ou n’interroge pas dans la même unité de travail logique (requête unique ou mise à jour par lots) doivent être situées dans des partitions distinctes.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-530">Data that your client application does not insert/update or query in the same logical unit of work (single query or batch update) should be located in separate partitions.</span></span>  <span data-ttu-id="9ebaa-531">Notez que le nombre de clés de partition dans une seule table n’est pas limité. Le fait qu’il y ait plusieurs millions de clés de partition ne constitue donc pas un problème et n’a aucune incidence sur les performances.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-531">One important note is that there is no limit to the number of partition keys in a single table, so having millions of partition keys is not a problem and will not impact performance.</span></span>  <span data-ttu-id="9ebaa-532">Par exemple, si votre application est un site web populaire auquel les utilisateurs doivent se connecter, il peut être judicieux de choisir l’ID utilisateur comme clé de partition.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-532">For example, if your application is a popular website with user login, using the User Id as the partition key could be a good choice.</span></span>  

#### <a name="hot-partitions"></a><span data-ttu-id="9ebaa-533">Partitions actives</span><span class="sxs-lookup"><span data-stu-id="9ebaa-533">Hot Partitions</span></span>
<span data-ttu-id="9ebaa-534">On appelle « partition active » une partition qui reçoit un pourcentage disproportionné du trafic vers un compte et qui ne peut pas faire l’objet d’un équilibrage de la charge, car il s’agit d’une partition unique.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-534">A hot partition is one that is receiving a disproportionate percentage of the traffic to an account, and cannot be load balanced because it is a single partition.</span></span>  <span data-ttu-id="9ebaa-535">En règle générale, la création des partitions actives s’effectue de l’une des façons suivantes :</span><span class="sxs-lookup"><span data-stu-id="9ebaa-535">In general, hot partitions are created one of two ways:</span></span>  

##### <span data-ttu-id="9ebaa-536"><a name="subheading28"></a>Modèles « Ajouter après uniquement » et « Ajouter avant uniquement »</span><span class="sxs-lookup"><span data-stu-id="9ebaa-536"><a name="subheading28"></a>Append Only and Prepend Only patterns</span></span>
<span data-ttu-id="9ebaa-537">Avec le modèle « Ajouter après uniquement », l’intégralité (ou la grande majorité) du trafic à destination d’une clé de partition donnée augmente et diminue en fonction de l’heure.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-537">The "Append Only" pattern is one where all (or nearly all) of the traffic to a given PK increases and decreases according to the current time.</span></span>  <span data-ttu-id="9ebaa-538">Par exemple, si votre application utilise la date du jour comme clé de partition pour les données de journal.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-538">An example is if your application used the current date as a partition key for log data.</span></span>  <span data-ttu-id="9ebaa-539">Par conséquent, toutes les insertions sont placées dans la dernière partition de votre table et le système ne peut pas équilibrer la charge, car l’ensemble des écritures va en fin de table.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-539">This results in all of the inserts going to the last partition in your table, and the system cannot load balance because all of the writes are going to the end of your table.</span></span>  <span data-ttu-id="9ebaa-540">Si le trafic à destination de cette partition dépasse l’objectif d’extensibilité au niveau de la partition, cela se traduit par une limitation.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-540">If the volume of traffic to that partition exceeds the partition-level scalability target, then it will result in throttling.</span></span>  <span data-ttu-id="9ebaa-541">Il est préférable de s’assurer que le trafic est envoyé vers plusieurs partitions, afin de permettre l’équilibrage de la charge des demandes sur votre table.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-541">It's better to ensure that traffic is sent to multiple partitions, to enable load balance the requests across your table.</span></span>  

##### <span data-ttu-id="9ebaa-542"><a name="subheading29"></a>Données à trafic élevé</span><span class="sxs-lookup"><span data-stu-id="9ebaa-542"><a name="subheading29"></a>High-Traffic Data</span></span>
<span data-ttu-id="9ebaa-543">Si votre schéma de partitionnement donne lieu à une seule partition qui comporte simplement les données qui sont beaucoup plus utilisées que d’autres partitions, le phénomène de limitation risque également de se présenter à mesure que cette partition unique s’approche de son objectif d’extensibilité.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-543">If your partitioning scheme results in a single partition that just has data that is far more used than other partitions, you may also see throttling as that partition approaches the scalability target for a single partition.</span></span>  <span data-ttu-id="9ebaa-544">Il est conseillé de faire en sorte que votre schéma de partitionnement ne génère pas une partition unique qui s’approche des objectifs d’extensibilité.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-544">It's better to make sure that your partition scheme results in no single partition approaching the scalability targets.</span></span>  

#### <a name="querying"></a><span data-ttu-id="9ebaa-545">Interrogation</span><span class="sxs-lookup"><span data-stu-id="9ebaa-545">Querying</span></span>
<span data-ttu-id="9ebaa-546">Cette section décrit les pratiques éprouvées concernant l’interrogation du service de Table.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-546">This section describes proven practices for querying the table service.</span></span>  

##### <span data-ttu-id="9ebaa-547"><a name="subheading30"></a>Étendue de requête</span><span class="sxs-lookup"><span data-stu-id="9ebaa-547"><a name="subheading30"></a>Query Scope</span></span>
<span data-ttu-id="9ebaa-548">Pour spécifier la plage des entités à interroger, vous pouvez procéder de plusieurs façons.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-548">There are several ways to specify the range of entities to query.</span></span>  <span data-ttu-id="9ebaa-549">Vous trouverez, ci-dessous, une brève description de chaque méthode.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-549">The following is a discussion of the uses of each.</span></span>  

<span data-ttu-id="9ebaa-550">En règle générale, il est conseillé d’éviter les analyses (requêtes d’une taille supérieure à une seule entité). Cependant, si vous devez procéder de la sorte, tâchez d’organiser vos données de façon à ce que les analyses les récupèrent sans qu’il faille examiner ou renvoyer de grandes quantités d’entités dont vous n’avez pas besoin.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-550">In general, avoid scans (queries larger than a single entity), but if you must scan, try to organize your data so that your scans retrieve the data you need without scanning or returning significant amounts of entities you don't need.</span></span>  

###### <a name="point-queries"></a><span data-ttu-id="9ebaa-551">Requêtes de point</span><span class="sxs-lookup"><span data-stu-id="9ebaa-551">Point Queries</span></span>
<span data-ttu-id="9ebaa-552">Une requête de point récupère exactement une entité.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-552">A point query retrieves exactly one entity.</span></span> <span data-ttu-id="9ebaa-553">Pour ce faire, elle spécifie la clé de partition et la clé de ligne de l’entité à récupérer.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-553">It does this by specifying both the partition key and row key of the entity to retrieve.</span></span> <span data-ttu-id="9ebaa-554">Ces requêtes s’avèrent particulièrement efficaces et il est conseillé de les utiliser autant que possible.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-554">These queries are very efficient, and you should use them wherever possible.</span></span>  

###### <a name="partition-queries"></a><span data-ttu-id="9ebaa-555">Requêtes de partition</span><span class="sxs-lookup"><span data-stu-id="9ebaa-555">Partition Queries</span></span>
<span data-ttu-id="9ebaa-556">Une requête de partition récupère un jeu de données qui partagent une clé de partition commune.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-556">A partition query is a query that retrieves a set of data that shares a common partition key.</span></span> <span data-ttu-id="9ebaa-557">En règle générale, cette requête spécifie une plage de valeurs de clé de ligne ou une plage de valeurs pour une propriété d’entité, en plus d’une clé de partition.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-557">Typically, the query specifies a range of row key values or a range of values for some entity property in addition to a partition key.</span></span> <span data-ttu-id="9ebaa-558">Les requêtes de partition sont moins efficaces que les requêtes de point et doivent être utilisées avec modération.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-558">These are less efficient than point queries, and should be used sparingly.</span></span>  

###### <a name="table-queries"></a><span data-ttu-id="9ebaa-559">Requêtes de table</span><span class="sxs-lookup"><span data-stu-id="9ebaa-559">Table Queries</span></span>
<span data-ttu-id="9ebaa-560">Une requête de table récupère un jeu d’entités ne partageant pas une clé de partition commune.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-560">A table query is a query that retrieves a set of entities that does not share a common partition key.</span></span> <span data-ttu-id="9ebaa-561">Les requêtes de ce type ne sont pas efficaces et il est conseillé de les éviter dans la mesure du possible.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-561">These queries are not efficient and you should avoid them if possible.</span></span>  

##### <span data-ttu-id="9ebaa-562"><a name="subheading31"></a>Densité des requêtes</span><span class="sxs-lookup"><span data-stu-id="9ebaa-562"><a name="subheading31"></a>Query Density</span></span>
<span data-ttu-id="9ebaa-563">S’agissant de l’efficacité des requêtes, un autre facteur important est le nombre d’entités renvoyées par rapport au nombre d’entités analysées pour obtenir le jeu renvoyé.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-563">Another key factor in query efficiency is the number of entities returned as compared to the number of entities scanned to find the returned set.</span></span> <span data-ttu-id="9ebaa-564">Si votre application effectue une requête de table avec un filtre pour une valeur de propriété partagée par seulement 1 % des données, la requête analyse 100 entités pour chaque entité renvoyée.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-564">If your application performs a table query with a filter for a property value that only 1% of the data shares, the query will scan 100 entities for every one entity it returns.</span></span> <span data-ttu-id="9ebaa-565">Les objectifs d’extensibilité de table abordés précédemment sont liés au nombre d’entités analysées et non au nombre d’entités retournées : une densité de requête faible peut facilement générer un service de table qui limite votre application, car il convient d’analyser de nombreuses entités pour récupérer l’entité que vous recherchez.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-565">The table scalability targets discussed previously all relate to the number of entities scanned, and not the number of entities returned: a low query density can easily cause the table service to throttle your application because it must scan so many entities to retrieve the entity you are looking for.</span></span>  <span data-ttu-id="9ebaa-566">Pour savoir comment éviter ce problème, consultez la section traitant de la [dénormalisation](#subheading34) ci-après.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-566">See the section below on [denormalization](#subheading34) for more information on how to avoid this.</span></span>  

##### <a name="limiting-the-amount-of-data-returned"></a><span data-ttu-id="9ebaa-567">Limitation du volume de données renvoyé</span><span class="sxs-lookup"><span data-stu-id="9ebaa-567">Limiting the Amount of Data Returned</span></span>
###### <span data-ttu-id="9ebaa-568"><a name="subheading32"></a>Filtrage</span><span class="sxs-lookup"><span data-stu-id="9ebaa-568"><a name="subheading32"></a>Filtering</span></span>
<span data-ttu-id="9ebaa-569">Lorsque vous savez qu’une requête va renvoyer des entités dont vous n’avez pas besoin dans l’application cliente, pensez à utiliser un filtre afin de réduire la taille du jeu renvoyé.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-569">Where you know that a query will return entities that you don't need in the client application, consider using a filter to reduce the size of the returned set.</span></span> <span data-ttu-id="9ebaa-570">Bien que les entités non renvoyées au client soient comptabilisées dans les limites d’extensibilité, les performances de votre application s’en trouveront améliorées, compte tenu de la taille réduite de charge utile du réseau et de la réduction du nombre d’entités traitées par votre application cliente.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-570">While the entities not returned to the client still count toward the scalability limits, your application performance will improve because of the reduced network payload size and the reduced number of entities that your client application must process.</span></span>  <span data-ttu-id="9ebaa-571">Voir la remarque ci-dessus concernant la [densité des requêtes](#subheading31). Les objectifs d’extensibilité faisant référence au nombre d’entités analysées, il se peut qu’une requête qui exclut de nombreuses entités donne toujours lieu à une limitation, même si le nombre d’entités renvoyées est faible.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-571">See above note on [Query Density](#subheading31), however – the scalability targets relate to the number of entities scanned, so a query that filters out many entities may still result in throttling, even if few entities are returned.</span></span>  

###### <span data-ttu-id="9ebaa-572"><a name="subheading33"></a>Projection</span><span class="sxs-lookup"><span data-stu-id="9ebaa-572"><a name="subheading33"></a>Projection</span></span>
<span data-ttu-id="9ebaa-573">Si votre application cliente nécessite seulement un jeu limité de propriétés des entités de votre table, vous pouvez utiliser la projection pour limiter la taille du jeu de données renvoyé.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-573">If your client application needs only a limited set of properties from the entities in your table, you can use projection to limit the size of the returned data set.</span></span> <span data-ttu-id="9ebaa-574">Comme c’est le cas avec le filtrage, cela permet de réduire la charge réseau et le traitement du client.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-574">As with filtering, this helps to reduce network load and client processing.</span></span>  

##### <span data-ttu-id="9ebaa-575"><a name="subheading34"></a>Dénormalisation</span><span class="sxs-lookup"><span data-stu-id="9ebaa-575"><a name="subheading34"></a>Denormalization</span></span>
<span data-ttu-id="9ebaa-576">Contrairement à l’utilisation des bases de données relationnelles, les pratiques éprouvées pour interroger efficacement des données de table entraînent leur dénormalisation.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-576">Unlike working with relational databases, the proven practices for efficiently querying table data lead to denormalizing your data.</span></span> <span data-ttu-id="9ebaa-577">Cette opération consiste à dupliquer les mêmes données dans plusieurs entités (une pour chaque clé utilisable pour rechercher les données) afin de réduire le nombre d’entités qu’une requête doit analyser pour rechercher les données dont le client a besoin, plutôt que d’analyser de grandes quantités d’entités pour rechercher les données dont votre application a besoin.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-577">That is, duplicating the same data in multiple entities (one for each key you may use to find the data) to minimize the number of entities that a query must scan to find the data the client needs, rather than having to scan large numbers of entities to find the data your application needs.</span></span>  <span data-ttu-id="9ebaa-578">Sur un site web de commerce électronique, par exemple, vous pouvez rechercher une commande en fonction de l’ID du client (rechercher les commandes de ce client) et de la date (rechercher les commandes passées à une date donnée).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-578">For example, in an e-commerce website, you may want to find an order both by the customer ID (give me this customer's orders) and by the date (give me orders on a date).</span></span>  <span data-ttu-id="9ebaa-579">Dans le stockage de tables, il est préférable de stocker l’entité (ou une référence à celle-ci) à deux reprises : une fois avec le nom de la table, la clé de partition et la clé de ligne afin de faciliter la recherche en fonction de l’ID de client, et une fois pour faciliter la recherche en fonction de la date.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-579">In Table Storage, it is best to store the entity (or a reference to it) twice – once with Table Name, PK, and RK to facilitate finding by customer ID, once to facilitate finding it by the date.</span></span>  

#### <a name="insertupdatedelete"></a><span data-ttu-id="9ebaa-580">Insertion/Mise à jour/Suppression</span><span class="sxs-lookup"><span data-stu-id="9ebaa-580">Insert/Update/Delete</span></span>
<span data-ttu-id="9ebaa-581">Cette section décrit les pratiques éprouvées concernant la modification des entités stockées dans le service de Table.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-581">This section describes proven practices for modifying entities stored in the table service.</span></span>  

##### <span data-ttu-id="9ebaa-582"><a name="subheading35"></a>Traitement par lot</span><span class="sxs-lookup"><span data-stu-id="9ebaa-582"><a name="subheading35"></a>Batching</span></span>
<span data-ttu-id="9ebaa-583">Dans Azure Storage, les transactions par lots sont connues sous le nom de transactions de groupe d’entités (ETG) ; toutes les opérations d’une ETG doivent être effectuées dans une partition unique d’une seule table.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-583">Batch transactions are known as Entity Group Transactions (ETG) in Azure Storage; all the operations within an ETG must be on a single partition in a single table.</span></span> <span data-ttu-id="9ebaa-584">Lorsque cela s’avère possible, utilisez des ETG pour effectuer des opérations d’insertion, de mise à jour et de suppression par lots.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-584">Where possible, use ETGs to perform inserts, updates, and deletes in batches.</span></span> <span data-ttu-id="9ebaa-585">Cela réduit le nombre d’allers-retours entre votre application cliente et le serveur, ainsi que le nombre de transactions facturables (une ETG est comptabilisée comme une seule transaction à des fins de facturation et peut contenir 100 opérations de stockage), et autorise les mises à jour atomiques (dans une ETG, toutes les opérations réussissent ou échouent).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-585">This reduces the number of round trips from your client application to the server, reduces the number of billable transactions (an ETG counts as a single transaction for billing purposes and can contain up to 100 storage operations), and enables atomic updates (all operations succeed or all fail within an ETG).</span></span> <span data-ttu-id="9ebaa-586">L’utilisation des ETG peut apporter des avantages non négligeables dans les environnements où les temps de latence sont élevés, tels que les appareils mobiles.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-586">Environments with high latencies such as mobile devices will benefit greatly from using ETGs.</span></span>  

##### <span data-ttu-id="9ebaa-587"><a name="subheading36"></a>Opération Upsert</span><span class="sxs-lookup"><span data-stu-id="9ebaa-587"><a name="subheading36"></a>Upsert</span></span>
<span data-ttu-id="9ebaa-588">Lorsque cela s'avère possible, il est conseillé d'utiliser des opérations de table **Upsert** .</span><span class="sxs-lookup"><span data-stu-id="9ebaa-588">Use table **Upsert** operations wherever possible.</span></span> <span data-ttu-id="9ebaa-589">Il existe deux types d’opération **Upsert** ; tous deux peuvent se révéler plus efficaces que les opérations **Insert** et **Update** classiques :</span><span class="sxs-lookup"><span data-stu-id="9ebaa-589">There are two types of **Upsert**, both of which can be more efficient than a traditional **Insert** and **Update** operations:</span></span>  

* <span data-ttu-id="9ebaa-590">**InsertOrMerge** : utilisez cette opération lorsque vous souhaitez télécharger un sous-ensemble des propriétés de l’entité, mais ne savez pas si cette dernière existe déjà.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-590">**InsertOrMerge**: Use this when you want to upload a subset of the entity's properties, but aren't sure whether the entity already exists.</span></span> <span data-ttu-id="9ebaa-591">Si elle existe, cet appel met à jour les propriétés incluses dans l’opération **Upsert** et laisse toutes les propriétés existantes en l’état. Si elle n’existe pas, cet appel insère la nouvelle entité.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-591">If the entity exists, this call updates the properties included in the **Upsert** operation, and leaves all existing properties as they are, if the entity does not exist, it inserts the new entity.</span></span> <span data-ttu-id="9ebaa-592">Cela revient à utiliser la projection dans une requête, en ce sens que vous devez simplement télécharger les propriétés qui sont modifiées.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-592">This is similar to using projection in a query, in that you only need to upload the properties that are changing.</span></span>
* <span data-ttu-id="9ebaa-593">**InsertOrReplace** : utilisez cette opération lorsque vous souhaitez télécharger une toute nouvelle entité, mais ne savez pas si cette dernière existe déjà.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-593">**InsertOrReplace**: Use this when you want to upload an entirely new entity, but you aren't sure whether it already exists.</span></span> <span data-ttu-id="9ebaa-594">Ne l’utilisez que lorsque vous n’avez aucun doute quant à la qualité de la nouvelle entité téléchargée, car elle écrase complètement l’ancienne entité.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-594">You should only use this when you know that the newly uploaded entity is entirely correct because it completely overwrites the old entity.</span></span> <span data-ttu-id="9ebaa-595">Vous souhaitez, par exemple, mettre à jour l’entité qui stocke l’emplacement actuel d’un utilisateur et ce, que l’application ait déjà stocké ou non des données d’emplacement pour cet utilisateur ; la nouvelle entité d’emplacement est complète et vous n’avez besoin d’aucune information d’une entité précédente.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-595">For example, you want to update the entity that stores a user's current location regardless of whether or not the application has previously stored location data for the user; the new location entity is complete, and you do not need any information from any previous entity.</span></span>

##### <span data-ttu-id="9ebaa-596"><a name="subheading37"></a>Stockage de séries de données dans une seule entité</span><span class="sxs-lookup"><span data-stu-id="9ebaa-596"><a name="subheading37"></a>Storing Data Series in a Single Entity</span></span>
<span data-ttu-id="9ebaa-597">Parfois, une application stocke une série de données fréquemment nécessaires pour tout récupérer à la fois : par exemple, une application peut suivre l’utilisation du processeur au fil du temps pour tracer un graphique propagée des données à partir des dernières 24 heures.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-597">Sometimes, an application stores a series of data that it frequently needs to retrieve all at once: for example, an application might track CPU usage over time in order to plot a rolling chart of the data from the last 24 hours.</span></span> <span data-ttu-id="9ebaa-598">Une méthode consiste à disposer d’une entité de table par heure, chaque entité représentant alors une heure donnée et stockant l’utilisation du processeur au cours de cette période.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-598">One approach is to have one table entity per hour, with each entity representing a specific hour and storing the CPU usage for that hour.</span></span> <span data-ttu-id="9ebaa-599">Pour représenter ces données sur un graphique, l’application doit récupérer les entités qui contiennent les données des 24 dernières heures.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-599">To plot this data, the application needs to retrieve the entities holding the data from the 24 most recent hours.</span></span>  

<span data-ttu-id="9ebaa-600">Sinon, votre application peut stocker l'utilisation du processeur pour chaque heure sous la forme d'une propriété distincte d'une entité unique : pour mettre à jour chaque heure, votre application peut utiliser un seul appel **InsertOrMerge Upsert** pour mettre à jour la valeur de la dernière heure.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-600">Alternatively, your application could store the CPU usage for each hour as a separate property of a single entity: to update each hour, your application can use a single **InsertOrMerge Upsert** call to update the value for the most recent hour.</span></span> <span data-ttu-id="9ebaa-601">Pour représenter les données sur un graphique, l’application doit récupérer une seule entité au lieu de 24, générant ainsi une requête très efficace (reportez-vous à la section traitant de l’ [étendue de requête](#subheading30)ci-dessus).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-601">To plot the data, the application only needs to retrieve a single entity instead of 24, making for a very efficient query (see above discussion on [query scope](#subheading30)).</span></span>

##### <span data-ttu-id="9ebaa-602"><a name="subheading38"></a>Stockage de données structurées dans des objets blob</span><span class="sxs-lookup"><span data-stu-id="9ebaa-602"><a name="subheading38"></a>Storing structured data in blobs</span></span>
<span data-ttu-id="9ebaa-603">Les données structurées donnent parfois l’impression qu’elles devraient être placées dans les tables. Cependant, les plages d’entités sont toujours récupérées ensemble et peuvent être insérées par lots.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-603">Sometimes structured data feels like it should go in tables, but ranges of entities are always retrieved together and can be batch inserted.</span></span>  <span data-ttu-id="9ebaa-604">À cet égard, un fichier journal constitue un parfait exemple.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-604">A good example of this is a log file.</span></span>  <span data-ttu-id="9ebaa-605">Dans ce cas, vous pouvez regrouper plusieurs minutes de journalisation et les insérer. Vous récupérez alors plusieurs minutes de journalisation à la fois.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-605">In this case, you can batch several minutes of logs, insert them, and then you are always retrieving several minutes of logs at a time as well.</span></span>  <span data-ttu-id="9ebaa-606">Dans une optique de performances, il est préférable d’utiliser des objets blob plutôt que des tables, dans la mesure où vous pouvez réduire de manière significative le nombre d’objets écrits/renvoyés, ainsi que, généralement, le nombre de demandes qui doivent être effectuées.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-606">In this case, for performance, it's better to use blobs instead of tables, since you can significantly reduce the number of objects written/returned, as well as usually the number of requests that need made.</span></span>  

## <a name="queues"></a><span data-ttu-id="9ebaa-607">Files d’attente</span><span class="sxs-lookup"><span data-stu-id="9ebaa-607">Queues</span></span>
<span data-ttu-id="9ebaa-608">Outre les pratiques éprouvées pour [Tous les services](#allservices) décrites précédemment, les pratiques ci-dessous s'appliquent spécifiquement au service de file d’attente.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-608">In addition to the proven practices for [All Services](#allservices) described previously, the following proven practices apply specifically to the queue service.</span></span>  

### <span data-ttu-id="9ebaa-609"><a name="subheading39"></a>Limites d’extensibilité</span><span class="sxs-lookup"><span data-stu-id="9ebaa-609"><a name="subheading39"></a>Scalability Limits</span></span>
<span data-ttu-id="9ebaa-610">Une seule file d’attente peut traiter environ 2 000 messages (1 Ko chacun) par seconde (chaque AddMessage, GetMessage et DeleteMessage compte pour un message).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-610">A single queue can process approximately 2,000 messages (1KB each) per second (each AddMessage, GetMessage, and DeleteMessage count as a message here).</span></span> <span data-ttu-id="9ebaa-611">Si cela est insuffisant pour votre application, utilisez plusieurs files d’attente et répartissez les messages entre elles.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-611">If this is insufficient for your application, you should use multiple queues and spread the messages across them.</span></span>  

<span data-ttu-id="9ebaa-612">consultez les objectifs d’extensibilité actuels dans [Objectifs de performance et d’extensibilité d’Azure Storage](storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-612">View current scalability targets at [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span>  

### <span data-ttu-id="9ebaa-613"><a name="subheading40"></a>Désactivation de Nagle</span><span class="sxs-lookup"><span data-stu-id="9ebaa-613"><a name="subheading40"></a>Nagle Off</span></span>
<span data-ttu-id="9ebaa-614">Voir la section relative à la configuration de table qui traite de l’algorithme Nagle ; en règle générale, cet algorithme dégrade les performances des demandes de file d’attente et, de ce fait, vous devez le désactiver.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-614">See the section on table configuration that discusses the Nagle algorithm — the Nagle algorithm is generally bad for the performance of queue requests, and you should disable it.</span></span>  

### <span data-ttu-id="9ebaa-615"><a name="subheading41"></a>Taille des messages</span><span class="sxs-lookup"><span data-stu-id="9ebaa-615"><a name="subheading41"></a>Message Size</span></span>
<span data-ttu-id="9ebaa-616">Les performances et l’extensibilité des files d’attente diminuent quand la taille de message augmente.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-616">Queue performance and scalability decreases as message size increases.</span></span> <span data-ttu-id="9ebaa-617">Dans un message, placez uniquement les informations dont le destinataire a besoin.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-617">You should place only the information the receiver needs in a message.</span></span>  

### <span data-ttu-id="9ebaa-618"><a name="subheading42"></a>Récupération par lots</span><span class="sxs-lookup"><span data-stu-id="9ebaa-618"><a name="subheading42"></a>Batch Retrieval</span></span>
<span data-ttu-id="9ebaa-619">Vous pouvez récupérer jusqu’à 32 messages d’une file d’attente en une seule opération.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-619">You can retrieve up to 32 messages from a queue in a single operation.</span></span> <span data-ttu-id="9ebaa-620">Cela contribue à réduire le nombre d’allers-retours avec l’application cliente, ce qui s’avère particulièrement utile pour les environnements où les temps de latence sont élevés, tels que les appareils mobiles.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-620">This can reduce the number of roundtrips from the client application, which is especially useful for environments, such as mobile devices, with high latency.</span></span>  

### <span data-ttu-id="9ebaa-621"><a name="subheading43"></a>Intervalle d'interrogation de file d'attente</span><span class="sxs-lookup"><span data-stu-id="9ebaa-621"><a name="subheading43"></a>Queue Polling Interval</span></span>
<span data-ttu-id="9ebaa-622">La plupart des applications interrogent une file d’attente pour les messages, ce qui peut représenter l’une des plus grandes sources de transactions pour cette application.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-622">Most applications poll for messages from a queue, which can be one of the largest sources of transactions for that application.</span></span> <span data-ttu-id="9ebaa-623">Sélectionnez votre intervalle d’interrogation avec soin : une interrogation trop fréquente pourrait entraîner un rapprochement des objectifs d’extensibilité pour la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-623">Select your polling interval wisely: polling too frequently could cause your application to approach the scalability targets for the queue.</span></span> <span data-ttu-id="9ebaa-624">Toutefois, à 200 000 transactions à 0,01 $ (au moment de la rédaction), un seul processeur interrogeant une fois par seconde pendant un mois reviendrait à moins de 15 cents. Le prix n’est donc généralement pas un facteur qui affecte le choix de l’intervalle d’interrogation.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-624">However, at 200,000 transactions for $0.01 (at the time of writing), a single processor polling once every second for a month would cost less than 15 cents so cost is not typically a factor that affects your choice of polling interval.</span></span>  

<span data-ttu-id="9ebaa-625">Pour plus d’informations relatives au coût, consultez [Tarification Azure Storage](https://azure.microsoft.com/pricing/details/storage/).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-625">For up-to-date cost information, see [Azure Storage Pricing](https://azure.microsoft.com/pricing/details/storage/).</span></span>  

### <span data-ttu-id="9ebaa-626"><a name="subheading44"></a>UpdateMessage</span><span class="sxs-lookup"><span data-stu-id="9ebaa-626"><a name="subheading44"></a>UpdateMessage</span></span>
<span data-ttu-id="9ebaa-627">Vous pouvez utiliser l'opération **UpdateMessage** pour augmenter le délai d'expiration de l'invisibilité ou pour mettre à jour les informations d'état d'un message.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-627">You can use **UpdateMessage** to increase the invisibility timeout or to update state information of a message.</span></span> <span data-ttu-id="9ebaa-628">Bien que l'opération **UpdateMessage** soit particulièrement puissante, n'oubliez pas que chacune d'elles est comptabilisée dans le cadre de l'objectif d'évolutivité.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-628">While this is powerful, remember that each **UpdateMessage** operation counts towards the scalability target.</span></span> <span data-ttu-id="9ebaa-629">Cependant, cela peut constituer une méthode beaucoup plus efficace qu’un flux de travail qui transmet une tâche d’une file d’attente à la suivante, une fois chaque étape terminée.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-629">However, this can be a much more efficient approach than having a workflow that passes a job from one queue to the next, as each step of the job is completed.</span></span> <span data-ttu-id="9ebaa-630">L’utilisation de l’opération **UpdateMessage** permet à votre application d’enregistrer l’état de la tâche dans le message, puis de poursuivre le traitement, au lieu de replacer à chaque fois le message en file d’attente pour l’étape suivante.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-630">Using the **UpdateMessage** operation allows your application to save the job state to the message and then continue working, instead of re-queuing the message for the next step of the job every time a step completes.</span></span>  

<span data-ttu-id="9ebaa-631">Pour plus d’informations, voir l’article [Modification du contenu d’un message en file d’attente](../queues/storage-dotnet-how-to-use-queues.md#change-the-contents-of-a-queued-message).</span><span class="sxs-lookup"><span data-stu-id="9ebaa-631">For more information, see the article [How to: Change the contents of a queued message](../queues/storage-dotnet-how-to-use-queues.md#change-the-contents-of-a-queued-message).</span></span>  

### <span data-ttu-id="9ebaa-632"><a name="subheading45"></a>Architecture de l’application</span><span class="sxs-lookup"><span data-stu-id="9ebaa-632"><a name="subheading45"></a>Application architecture</span></span>
<span data-ttu-id="9ebaa-633">Il est conseillé d’utiliser des files d’attente pour rendre l’architecture de votre application extensible.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-633">You should use queues to make your application architecture scalable.</span></span> <span data-ttu-id="9ebaa-634">Vous trouverez, dans les listes suivantes, les méthodes applicables pour accroître l’extensibilité de votre application :</span><span class="sxs-lookup"><span data-stu-id="9ebaa-634">The following lists some ways you can use queues to make your application more scalable:</span></span>  

* <span data-ttu-id="9ebaa-635">Vous pouvez utiliser des files d’attente pour créer des journaux de travaux en souffrance à traiter et éliminer des charges de travail de votre application.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-635">You can use queues to create backlogs of work for processing and smooth out workloads in your application.</span></span> <span data-ttu-id="9ebaa-636">Vous pouvez, par exemple, placer en file d’attente des demandes d’utilisateurs portant sur l’exécution de tâches exigeant d’importantes ressources processeur, telles que le redimensionnement d’images téléchargées.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-636">For example, you could queue up requests from users to perform processor intensive work such as resizing uploaded images.</span></span>
* <span data-ttu-id="9ebaa-637">Vous pouvez utiliser des files d’attente pour dissocier des parties de votre application, de manière à pouvoir les faire évoluer séparément.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-637">You can use queues to decouple parts of your application so that you can scale them independently.</span></span> <span data-ttu-id="9ebaa-638">Un serveur web frontal peut, par exemple, placer les résultats d’une enquête en file d’attente en vue de les stocker et de les analyser ultérieurement.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-638">For example, a web front-end could place survey results from users into a queue for later analysis and storage.</span></span> <span data-ttu-id="9ebaa-639">Vous pouvez ajouter des instances du rôle de travail afin de traiter les données de file d’attente suivant les besoins.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-639">You could add more worker role instances to process the queue data as required.</span></span>  

## <a name="conclusion"></a><span data-ttu-id="9ebaa-640">Conclusion</span><span class="sxs-lookup"><span data-stu-id="9ebaa-640">Conclusion</span></span>
<span data-ttu-id="9ebaa-641">Dans cet article, nous avons passé en revue quelques-unes des pratiques utilisées le plus couramment pour optimiser les performances lors de l’utilisation d’Azure Storage.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-641">This article discussed some of the most common, proven practices for optimizing performance when using Azure Storage.</span></span> <span data-ttu-id="9ebaa-642">Nous invitons tous les développeurs d’applications à évaluer chacune d’elles et à prendre en compte les recommandations énoncées afin de bénéficier de performances optimales pour les applications qui utilisent Azure Storage.</span><span class="sxs-lookup"><span data-stu-id="9ebaa-642">We encourage every application developer to assess their application against each of the above practices and consider acting on the recommendations to get great performance for their applications that use Azure Storage.</span></span>