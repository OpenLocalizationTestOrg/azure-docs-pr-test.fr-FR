---
title: aaaOverview de hello du cycle de vie des Services fiables de Azure Service Fabric | Documents Microsoft
description: "En savoir plus sur les événements de cycle de vie différent hello dans les services fiables Service Fabric"
services: Service-Fabric
documentationcenter: java
author: PavanKunapareddyMSFT
manager: timlt
ms.assetid: 
ms.service: Service-Fabric
ms.devlang: java
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/30/2017
ms.author: pakunapa;
ms.openlocfilehash: 6d48c217d12bc5248c2da57b544aac747cecd872
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/06/2017
---
# <a name="reliable-services-lifecycle-overview"></a><span data-ttu-id="ebea4-103">Vue d’ensemble du cycle de vie de Reliable Services</span><span class="sxs-lookup"><span data-stu-id="ebea4-103">Reliable services lifecycle overview</span></span>
> [!div class="op_single_selector"]
> * [<span data-ttu-id="ebea4-104">C# sur Windows</span><span class="sxs-lookup"><span data-stu-id="ebea4-104">C# on Windows</span></span>](service-fabric-reliable-services-lifecycle.md)
> * [<span data-ttu-id="ebea4-105">Java sur Linux</span><span class="sxs-lookup"><span data-stu-id="ebea4-105">Java on Linux</span></span>](service-fabric-reliable-services-lifecycle-java.md)
>
>

<span data-ttu-id="ebea4-106">Quand vous réfléchissez à hello de cycles de vie des Services fiables, principes de base hello du cycle de vie hello sont hello plus importante.</span><span class="sxs-lookup"><span data-stu-id="ebea4-106">When thinking about hello lifecycles of Reliable Services, hello basics of hello lifecycle are hello most important.</span></span> <span data-ttu-id="ebea4-107">En général :</span><span class="sxs-lookup"><span data-stu-id="ebea4-107">In general:</span></span>

* <span data-ttu-id="ebea4-108">Lors du démarrage</span><span class="sxs-lookup"><span data-stu-id="ebea4-108">During Startup</span></span>
  * <span data-ttu-id="ebea4-109">Les services sont construits</span><span class="sxs-lookup"><span data-stu-id="ebea4-109">Services are constructed</span></span>
  * <span data-ttu-id="ebea4-110">Ils ont une tooconstruct opportunité et retournent zéro ou plusieurs écouteurs</span><span class="sxs-lookup"><span data-stu-id="ebea4-110">They have an opportunity tooconstruct and return zero or more listeners</span></span>
  * <span data-ttu-id="ebea4-111">Tous les écouteurs retournés sont ouverte, ce qui permet la communication avec le service hello</span><span class="sxs-lookup"><span data-stu-id="ebea4-111">Any returned listeners are opened, allowing communication with hello service</span></span>
  * <span data-ttu-id="ebea4-112">du Service Hello runAsync est appelée, permettant de hello toodo de service à long terme ou de travail d’arrière-plan</span><span class="sxs-lookup"><span data-stu-id="ebea4-112">hello Service's runAsync method is called, allowing hello service toodo long running or background work</span></span>
* <span data-ttu-id="ebea4-113">Lors de l’arrêt</span><span class="sxs-lookup"><span data-stu-id="ebea4-113">During shutdown</span></span>
  * <span data-ttu-id="ebea4-114">toorunAsync passé jeton d’annulation Hello est annulée et les écouteurs hello sont fermées.</span><span class="sxs-lookup"><span data-stu-id="ebea4-114">hello cancellation token passed toorunAsync is canceled, and hello listeners are closed</span></span>
  * <span data-ttu-id="ebea4-115">Une fois cette opération terminée, objet de service hello lui-même est détruite</span><span class="sxs-lookup"><span data-stu-id="ebea4-115">Once that is complete, hello service object itself is destructed</span></span>

<span data-ttu-id="ebea4-116">Il n’y a plus d’informations sur hello exact de classement de ces événements.</span><span class="sxs-lookup"><span data-stu-id="ebea4-116">There are details around hello exact ordering of these events.</span></span> <span data-ttu-id="ebea4-117">En particulier, commande hello d’événements peut varier légèrement selon que hello Service fiable est sans état ou avec état.</span><span class="sxs-lookup"><span data-stu-id="ebea4-117">In particular, hello order of events may change slightly depending on whether hello Reliable Service is Stateless or Stateful.</span></span> <span data-ttu-id="ebea4-118">En outre, pour les services avec état, nous avons toodeal avec le scénario principal swap hello.</span><span class="sxs-lookup"><span data-stu-id="ebea4-118">In addition, for stateful services, we have toodeal with hello Primary swap scenario.</span></span> <span data-ttu-id="ebea4-119">Au cours de cette séquence, rôle hello des principaux est transféré tooanother réplica (ou est restauré) sans arrêt du service hello.</span><span class="sxs-lookup"><span data-stu-id="ebea4-119">During this sequence, hello role of Primary is transferred tooanother replica (or comes back) without hello service shutting down.</span></span> <span data-ttu-id="ebea4-120">Enfin, nous avons toothink sur les conditions d’erreur ou d’échec.</span><span class="sxs-lookup"><span data-stu-id="ebea4-120">Finally, we have toothink about error or failure conditions.</span></span>

## <a name="stateless-service-startup"></a><span data-ttu-id="ebea4-121">Démarrage de service sans état</span><span class="sxs-lookup"><span data-stu-id="ebea4-121">Stateless service startup</span></span>
<span data-ttu-id="ebea4-122">Hello de cycle de vie d’un service sans état est assez simple.</span><span class="sxs-lookup"><span data-stu-id="ebea4-122">hello lifecycle of a stateless service is fairly straightforward.</span></span> <span data-ttu-id="ebea4-123">Voici l’ordre hello des événements :</span><span class="sxs-lookup"><span data-stu-id="ebea4-123">Here's hello order of events:</span></span>

1. <span data-ttu-id="ebea4-124">Hello Service est construit</span><span class="sxs-lookup"><span data-stu-id="ebea4-124">hello Service is constructed</span></span>
2. <span data-ttu-id="ebea4-125">Ensuite, deux choses se produisent en parallèle :</span><span class="sxs-lookup"><span data-stu-id="ebea4-125">Then, in parallel two things happen:</span></span>
    - <span data-ttu-id="ebea4-126">`StatelessService.createServiceInstanceListeners()` est appelée et les écouteurs retournés sont ouverts (`CommunicationListener.openAsync()` est appelée sur chaque écouteur)</span><span class="sxs-lookup"><span data-stu-id="ebea4-126">`StatelessService.createServiceInstanceListeners()` is invoked and any returned listeners are Opened (`CommunicationListener.openAsync()` is called on each listener)</span></span>
    - <span data-ttu-id="ebea4-127">méthode de runAsync du service de Hello (`StatelessService.runAsync()`) est appelé</span><span class="sxs-lookup"><span data-stu-id="ebea4-127">hello service's runAsync method (`StatelessService.runAsync()`) is called</span></span>
3. <span data-ttu-id="ebea4-128">Le cas échéant, méthode d’onOpenAsync hello du service est appelée (plus précisément, `StatelessService.onOpenAsync()` est appelée.</span><span class="sxs-lookup"><span data-stu-id="ebea4-128">If present, hello service's own onOpenAsync method is called (Specifically, `StatelessService.onOpenAsync()` is called.</span></span> <span data-ttu-id="ebea4-129">Il s’agit d’un remplacement rare, mais il est disponible).</span><span class="sxs-lookup"><span data-stu-id="ebea4-129">This is an uncommon override but it is available).</span></span>

<span data-ttu-id="ebea4-130">Il est important toonote qu’il n’existe aucun classement entre hello appels toocreate et les écouteurs hello ouvert et runAsync.</span><span class="sxs-lookup"><span data-stu-id="ebea4-130">It is important toonote that there is no ordering between hello calls toocreate and open hello listeners and runAsync.</span></span> <span data-ttu-id="ebea4-131">les écouteurs Hello peut s’ouvrir avant le démarrage de runAsync.</span><span class="sxs-lookup"><span data-stu-id="ebea4-131">hello listeners may open before runAsync is started.</span></span> <span data-ttu-id="ebea4-132">De même, runAsync peut finir appelé avant que les écouteurs de communication hello sont ouverts, ou même ont été construits.</span><span class="sxs-lookup"><span data-stu-id="ebea4-132">Similarly, runAsync may end up invoked before hello communication listeners are open or have even been constructed.</span></span> <span data-ttu-id="ebea4-133">Si aucune synchronisation n’est requise, elle est considérée comme un implémenteur de toohello exercice.</span><span class="sxs-lookup"><span data-stu-id="ebea4-133">If any synchronization is required, it is left as an exercise toohello implementer.</span></span> <span data-ttu-id="ebea4-134">Solutions courantes :</span><span class="sxs-lookup"><span data-stu-id="ebea4-134">Common solutions:</span></span>

* <span data-ttu-id="ebea4-135">Parfois, les écouteurs ne peuvent pas fonctionner avant que d’autres informations ne soient créées ou un travail effectué.</span><span class="sxs-lookup"><span data-stu-id="ebea4-135">Sometimes listeners can't function until some other information is created or work done.</span></span> <span data-ttu-id="ebea4-136">Pour les services sans état qui travail peut se faire dans le constructeur du service hello pendant hello `createServiceInstanceListeners()` appeler, ou dans le cadre de la construction de hello d’écouteur hello lui-même.</span><span class="sxs-lookup"><span data-stu-id="ebea4-136">For stateless services that work can usually be done in hello service's constructor, during hello `createServiceInstanceListeners()` call, or as a part of hello construction of hello listener itself.</span></span>
* <span data-ttu-id="ebea4-137">Parfois hello code dans runAsync ne veut pas toostart jusqu'à ce que les écouteurs hello sont ouverts.</span><span class="sxs-lookup"><span data-stu-id="ebea4-137">Sometimes hello code in runAsync does not want toostart until hello listeners are open.</span></span> <span data-ttu-id="ebea4-138">Dans ce cas, une coordination supplémentaire est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="ebea4-138">In this case additional coordination is necessary.</span></span> <span data-ttu-id="ebea4-139">Une solution courante consiste à certains indicateur dans les écouteurs hello indiquant quand ils ont terminé, qui est sélectionné dans runAsync avant de poursuivre le travail de tooactual.</span><span class="sxs-lookup"><span data-stu-id="ebea4-139">One common solution is some flag within hello listeners indicating when they have completed, which is checked in runAsync before continuing tooactual work.</span></span>

## <a name="stateless-service-shutdown"></a><span data-ttu-id="ebea4-140">Arrêt de service sans état</span><span class="sxs-lookup"><span data-stu-id="ebea4-140">Stateless service shutdown</span></span>
<span data-ttu-id="ebea4-141">Lorsque vous arrêtez un service sans état, hello même modèle est suivi, dans le sens inverse :</span><span class="sxs-lookup"><span data-stu-id="ebea4-141">When shutting down a stateless service, hello same pattern is followed, just in reverse:</span></span>

1. <span data-ttu-id="ebea4-142">En parallèle</span><span class="sxs-lookup"><span data-stu-id="ebea4-142">In parallel</span></span>
    - <span data-ttu-id="ebea4-143">Les écouteurs ouverts sont fermés (`CommunicationListener.closeAsync()` est appelée sur chaque écouteur)</span><span class="sxs-lookup"><span data-stu-id="ebea4-143">Any open listeners are Closed (`CommunicationListener.closeAsync()` is called on each listener)</span></span>
    - <span data-ttu-id="ebea4-144">jeton d’annulation Hello passé trop`runAsync()` est annulée (vérification du jeton d’annulation hello `isCancelled` propriété retourne la valeur est true et si elle est appelée du jeton hello `throwIfCancellationRequested` méthode lève une exception un `CancellationException`)</span><span class="sxs-lookup"><span data-stu-id="ebea4-144">hello cancellation token passed too`runAsync()` is canceled (checking hello cancellation token's `isCancelled` property returns true, and if called hello token's `throwIfCancellationRequested` method throws a `CancellationException`)</span></span>
2. <span data-ttu-id="ebea4-145">Une fois `closeAsync()` se termine sur chaque port d’écoute et `runAsync()` termine également du service hello `StatelessService.onCloseAsync()` méthode est appelée, le cas échéant (c’est à nouveau un remplacement rare).</span><span class="sxs-lookup"><span data-stu-id="ebea4-145">Once `closeAsync()` completes on each listener and `runAsync()` also completes, hello service's `StatelessService.onCloseAsync()` method is called, if present (again this is an uncommon override).</span></span>
3. <span data-ttu-id="ebea4-146">Après avoir `StatelessService.onCloseAsync()` terminée, objet de service hello est détruite.</span><span class="sxs-lookup"><span data-stu-id="ebea4-146">After `StatelessService.onCloseAsync()` completes, hello service object is destructed</span></span>

## <a name="notes-on-service-lifecycle"></a><span data-ttu-id="ebea4-147">Remarques sur le cycle de vie du service</span><span class="sxs-lookup"><span data-stu-id="ebea4-147">Notes on service lifecycle</span></span>
* <span data-ttu-id="ebea4-148">Les deux hello `runAsync()` méthode et hello `createServiceInstanceListeners` appels sont facultatifs.</span><span class="sxs-lookup"><span data-stu-id="ebea4-148">Both hello `runAsync()` method and hello `createServiceInstanceListeners` calls are optional.</span></span> <span data-ttu-id="ebea4-149">Un service peut avoir l’un des deux, les deux ou aucun.</span><span class="sxs-lookup"><span data-stu-id="ebea4-149">A service may have one of them, both, or neither.</span></span> <span data-ttu-id="ebea4-150">Par exemple, si le service de hello ne tout le travail dans les appels de toouser de réponse, il est inutile pour qu’il tooimplement `runAsync()`.</span><span class="sxs-lookup"><span data-stu-id="ebea4-150">For example, if hello service does all its work in response toouser calls, there is no need for it tooimplement `runAsync()`.</span></span> <span data-ttu-id="ebea4-151">Que les écouteurs de communication hello et son code associé sont nécessaires.</span><span class="sxs-lookup"><span data-stu-id="ebea4-151">Only hello communication listeners and their associated code are necessary.</span></span> <span data-ttu-id="ebea4-152">De même, créer et de retourner des écouteurs de communication sont facultative, comme hello service devra peut-être uniquement en arrière-plan toodo de travail et seulement doit tooimplement`runAsync()`</span><span class="sxs-lookup"><span data-stu-id="ebea4-152">Similarly, creating and returning communication listeners is optional, as hello service may have only background work toodo, and so only needs tooimplement `runAsync()`</span></span>
* <span data-ttu-id="ebea4-153">Il n’est valide pour un service toocomplete `runAsync()` avec succès et le retour à partir de celui-ci.</span><span class="sxs-lookup"><span data-stu-id="ebea4-153">It is valid for a service toocomplete `runAsync()` successfully and return from it.</span></span> <span data-ttu-id="ebea4-154">Cela n’est pas considéré comme une condition d’échec et représente le travail d’arrière-plan hello de fin de service hello.</span><span class="sxs-lookup"><span data-stu-id="ebea4-154">This is not considered a failure condition and would represent hello background work of hello service completing.</span></span> <span data-ttu-id="ebea4-155">Pour les services fiables avec état `runAsync()` serait être rappelée si le service de hello ont été rétrogradé du serveur principal et ensuite promu tooprimary précédent.</span><span class="sxs-lookup"><span data-stu-id="ebea4-155">For stateful reliable services `runAsync()` would be called again if hello service were demoted from primary and then promoted back tooprimary.</span></span>
* <span data-ttu-id="ebea4-156">Si un service s’arrête de `runAsync()` en levant une exception inattendue, il s’agit d’une défaillance et objet de service hello est arrêté et une erreur d’intégrité est signalée.</span><span class="sxs-lookup"><span data-stu-id="ebea4-156">If a service exits from `runAsync()` by throwing some unexpected exception, this is a failure and hello service object is shut down and a health error reported.</span></span>
* <span data-ttu-id="ebea4-157">Il n’existe aucune limite de temps au retour de ces méthodes, vous immédiatement perdez hello capacité toowrite et par conséquent ne peut pas se terminer tout travail réel.</span><span class="sxs-lookup"><span data-stu-id="ebea4-157">While there is no time limit on returning from these methods, you immediately lose hello ability toowrite and therefore cannot complete any real work.</span></span> <span data-ttu-id="ebea4-158">Il est recommandé de retourner aussi rapidement que possible lors de la réception de demande d’annulation hello.</span><span class="sxs-lookup"><span data-stu-id="ebea4-158">It is recommended that you return as quickly as possible upon receiving hello cancellation request.</span></span> <span data-ttu-id="ebea4-159">Si votre service ne répond pas les appels d’API de toothese dans un délai raisonnable que service Fabric peut forcer mettre fin à votre service.</span><span class="sxs-lookup"><span data-stu-id="ebea4-159">If your service does not respond toothese API calls in a reasonable amount of time Service Fabric may forcibly terminate your service.</span></span> <span data-ttu-id="ebea4-160">En général, cela se produit uniquement lors de mises à niveau d’application ou lorsqu’un service est en cours de suppression.</span><span class="sxs-lookup"><span data-stu-id="ebea4-160">Usually this only happens during application upgrades or when a service is being deleted.</span></span> <span data-ttu-id="ebea4-161">Par défaut, ce délai d’attente est de 15 minutes.</span><span class="sxs-lookup"><span data-stu-id="ebea4-161">This timeout is 15 minutes by default.</span></span>
* <span data-ttu-id="ebea4-162">Échecs Bonjour `onCloseAsync()` résultat du chemin d’accès dans `onAbort()` appelée qui est une opportunité de meilleur effort dernière chance pour hello service tooclean des et libérer toutes les ressources qu’ils ont demandé.</span><span class="sxs-lookup"><span data-stu-id="ebea4-162">Failures in hello `onCloseAsync()` path result in `onAbort()` being called which is a last-chance best-effort opportunity for hello service tooclean up and release any resources that they have claimed.</span></span>

> [!NOTE]
> <span data-ttu-id="ebea4-163">Les services fiables avec état ne sont pas encore pris en charge par Java.</span><span class="sxs-lookup"><span data-stu-id="ebea4-163">Stateful reliable services are not supported in java yet.</span></span>
>
>

## <a name="next-steps"></a><span data-ttu-id="ebea4-164">Étapes suivantes</span><span class="sxs-lookup"><span data-stu-id="ebea4-164">Next steps</span></span>
* [<span data-ttu-id="ebea4-165">Introduction tooReliable Services</span><span class="sxs-lookup"><span data-stu-id="ebea4-165">Introduction tooReliable Services</span></span>](service-fabric-reliable-services-introduction.md)
* [<span data-ttu-id="ebea4-166">Démarrage rapide de Reliable Services</span><span class="sxs-lookup"><span data-stu-id="ebea4-166">Reliable Services quick start</span></span>](service-fabric-reliable-services-quick-start.md)
* [<span data-ttu-id="ebea4-167">Utilisation avancée de Reliable Services</span><span class="sxs-lookup"><span data-stu-id="ebea4-167">Reliable Services advanced usage</span></span>](service-fabric-reliable-services-advanced-usage.md)
