---
title: "Vue d’ensemble du cycle de vie de Reliable Services dans Azure Service Fabric | Microsoft Docs"
description: "En savoir plus sur les différents événements de cycle de vie de Reliable Services dans Service Fabric"
services: Service-Fabric
documentationcenter: java
author: PavanKunapareddyMSFT
manager: timlt
ms.assetid: 
ms.service: Service-Fabric
ms.devlang: java
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/30/2017
ms.author: pakunapa;
ms.openlocfilehash: 80eb68346dd05c256c60725eb082aa0651fe7cbd
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/18/2017
---
# <a name="reliable-services-lifecycle-overview"></a><span data-ttu-id="66fb0-103">Vue d’ensemble du cycle de vie de Reliable Services</span><span class="sxs-lookup"><span data-stu-id="66fb0-103">Reliable services lifecycle overview</span></span>
> [!div class="op_single_selector"]
> * [<span data-ttu-id="66fb0-104">C# sur Windows</span><span class="sxs-lookup"><span data-stu-id="66fb0-104">C# on Windows</span></span>](service-fabric-reliable-services-lifecycle.md)
> * [<span data-ttu-id="66fb0-105">Java sur Linux</span><span class="sxs-lookup"><span data-stu-id="66fb0-105">Java on Linux</span></span>](service-fabric-reliable-services-lifecycle-java.md)
>
>

<span data-ttu-id="66fb0-106">Lorsque l’on songe aux cycles de vie de Reliable Services, les principes de base du cycle de vie sont les plus importants.</span><span class="sxs-lookup"><span data-stu-id="66fb0-106">When thinking about the lifecycles of Reliable Services, the basics of the lifecycle are the most important.</span></span> <span data-ttu-id="66fb0-107">En général :</span><span class="sxs-lookup"><span data-stu-id="66fb0-107">In general:</span></span>

* <span data-ttu-id="66fb0-108">Lors du démarrage</span><span class="sxs-lookup"><span data-stu-id="66fb0-108">During Startup</span></span>
  * <span data-ttu-id="66fb0-109">Les services sont construits</span><span class="sxs-lookup"><span data-stu-id="66fb0-109">Services are constructed</span></span>
  * <span data-ttu-id="66fb0-110">Ils ont l’opportunité de se construire et de renvoyer zéro ou plusieurs écouteurs</span><span class="sxs-lookup"><span data-stu-id="66fb0-110">They have an opportunity to construct and return zero or more listeners</span></span>
  * <span data-ttu-id="66fb0-111">Les écouteurs retournés sont ouverts, ce qui permet la communication avec le service</span><span class="sxs-lookup"><span data-stu-id="66fb0-111">Any returned listeners are opened, allowing communication with the service</span></span>
  * <span data-ttu-id="66fb0-112">La méthode runAsync du service est appelée, ce qui permet au service d’exécuter des tâches de longue durée ou d’arrière-plan</span><span class="sxs-lookup"><span data-stu-id="66fb0-112">The Service's runAsync method is called, allowing the service to do long running or background work</span></span>
* <span data-ttu-id="66fb0-113">Lors de l’arrêt</span><span class="sxs-lookup"><span data-stu-id="66fb0-113">During shutdown</span></span>
  * <span data-ttu-id="66fb0-114">Le jeton d’annulation passé à runAsync est annulé et les écouteurs sont fermés</span><span class="sxs-lookup"><span data-stu-id="66fb0-114">The cancellation token passed to runAsync is canceled, and the listeners are closed</span></span>
  * <span data-ttu-id="66fb0-115">Une fois cette opération terminée, l’objet de service lui-même est détruit</span><span class="sxs-lookup"><span data-stu-id="66fb0-115">Once that is complete, the service object itself is destructed</span></span>

<span data-ttu-id="66fb0-116">Il existe plus d’informations sur l’ordre exact de ces événements.</span><span class="sxs-lookup"><span data-stu-id="66fb0-116">There are details around the exact ordering of these events.</span></span> <span data-ttu-id="66fb0-117">En particulier, l’ordre des événements peut varier légèrement selon que le Reliable Service est un service sans état ou avec état.</span><span class="sxs-lookup"><span data-stu-id="66fb0-117">In particular, the order of events may change slightly depending on whether the Reliable Service is Stateless or Stateful.</span></span> <span data-ttu-id="66fb0-118">En outre, pour les services avec état, nous devons gérer le scénario d’échange principal.</span><span class="sxs-lookup"><span data-stu-id="66fb0-118">In addition, for stateful services, we have to deal with the Primary swap scenario.</span></span> <span data-ttu-id="66fb0-119">Au cours de cette séquence, le rôle principal est transféré vers un autre réplica (ou revient) sans que le service ne s’arrête.</span><span class="sxs-lookup"><span data-stu-id="66fb0-119">During this sequence, the role of Primary is transferred to another replica (or comes back) without the service shutting down.</span></span> <span data-ttu-id="66fb0-120">Enfin, nous devons penser aux conditions d’erreur ou d’échec.</span><span class="sxs-lookup"><span data-stu-id="66fb0-120">Finally, we have to think about error or failure conditions.</span></span>

## <a name="stateless-service-startup"></a><span data-ttu-id="66fb0-121">Démarrage de service sans état</span><span class="sxs-lookup"><span data-stu-id="66fb0-121">Stateless service startup</span></span>
<span data-ttu-id="66fb0-122">Le cycle de vie d’un service sans état est assez simple.</span><span class="sxs-lookup"><span data-stu-id="66fb0-122">The lifecycle of a stateless service is fairly straightforward.</span></span> <span data-ttu-id="66fb0-123">Voici l’ordre des événements :</span><span class="sxs-lookup"><span data-stu-id="66fb0-123">Here's the order of events:</span></span>

1. <span data-ttu-id="66fb0-124">Le service est construit</span><span class="sxs-lookup"><span data-stu-id="66fb0-124">The Service is constructed</span></span>
2. <span data-ttu-id="66fb0-125">Ensuite, deux choses se produisent en parallèle :</span><span class="sxs-lookup"><span data-stu-id="66fb0-125">Then, in parallel two things happen:</span></span>
    - <span data-ttu-id="66fb0-126">`StatelessService.createServiceInstanceListeners()` est appelée et les écouteurs retournés sont ouverts (`CommunicationListener.openAsync()` est appelée sur chaque écouteur)</span><span class="sxs-lookup"><span data-stu-id="66fb0-126">`StatelessService.createServiceInstanceListeners()` is invoked and any returned listeners are Opened (`CommunicationListener.openAsync()` is called on each listener)</span></span>
    - <span data-ttu-id="66fb0-127">La méthode runAsync (`StatelessService.runAsync()`) du service est appelée</span><span class="sxs-lookup"><span data-stu-id="66fb0-127">The service's runAsync method (`StatelessService.runAsync()`) is called</span></span>
3. <span data-ttu-id="66fb0-128">Si elle est présente, la méthode onOpenAsync propre au service est appelée (en l’occurrence, c’est `StatelessService.onOpenAsync()` qui est appelée).</span><span class="sxs-lookup"><span data-stu-id="66fb0-128">If present, the service's own onOpenAsync method is called (Specifically, `StatelessService.onOpenAsync()` is called.</span></span> <span data-ttu-id="66fb0-129">Il s’agit d’un remplacement rare, mais il est disponible).</span><span class="sxs-lookup"><span data-stu-id="66fb0-129">This is an uncommon override but it is available).</span></span>

<span data-ttu-id="66fb0-130">Il est important de noter qu’il n’existe pas d’ordre particulier entre les appels pour créer et ouvrir les écouteurs, et runAsync.</span><span class="sxs-lookup"><span data-stu-id="66fb0-130">It is important to note that there is no ordering between the calls to create and open the listeners and runAsync.</span></span> <span data-ttu-id="66fb0-131">Les écouteurs peuvent s’ouvrir avant que la méthode runAsync ne soit démarrée.</span><span class="sxs-lookup"><span data-stu-id="66fb0-131">The listeners may open before runAsync is started.</span></span> <span data-ttu-id="66fb0-132">De même, runAsync peut être appelée avant que les écouteurs de communication ne soient ouverts ou même construits.</span><span class="sxs-lookup"><span data-stu-id="66fb0-132">Similarly, runAsync may end up invoked before the communication listeners are open or have even been constructed.</span></span> <span data-ttu-id="66fb0-133">Si une synchronisation est nécessaire, elle est considérée comme un exercice à exécuter par le responsable d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="66fb0-133">If any synchronization is required, it is left as an exercise to the implementer.</span></span> <span data-ttu-id="66fb0-134">Solutions courantes :</span><span class="sxs-lookup"><span data-stu-id="66fb0-134">Common solutions:</span></span>

* <span data-ttu-id="66fb0-135">Parfois, les écouteurs ne peuvent pas fonctionner avant que d’autres informations ne soient créées ou un travail effectué.</span><span class="sxs-lookup"><span data-stu-id="66fb0-135">Sometimes listeners can't function until some other information is created or work done.</span></span> <span data-ttu-id="66fb0-136">Pour les services sans état, ce travail peut généralement s’exécuter dans le constructeur du service, au cours de l’appel `createServiceInstanceListeners()`, ou dans le cadre de la construction de l’écouteur lui-même.</span><span class="sxs-lookup"><span data-stu-id="66fb0-136">For stateless services that work can usually be done in the service's constructor, during the `createServiceInstanceListeners()` call, or as a part of the construction of the listener itself.</span></span>
* <span data-ttu-id="66fb0-137">Parfois, le code de runAsync ne démarre pas tant que les écouteurs ne sont pas ouverts.</span><span class="sxs-lookup"><span data-stu-id="66fb0-137">Sometimes the code in runAsync does not want to start until the listeners are open.</span></span> <span data-ttu-id="66fb0-138">Dans ce cas, une coordination supplémentaire est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="66fb0-138">In this case additional coordination is necessary.</span></span> <span data-ttu-id="66fb0-139">Une solution courante consiste à utiliser un indicateur dans les écouteurs, indiquant quand ceux-ci ont terminé, ce qui est vérifié dans runAsync avant de poursuivre le travail réel.</span><span class="sxs-lookup"><span data-stu-id="66fb0-139">One common solution is some flag within the listeners indicating when they have completed, which is checked in runAsync before continuing to actual work.</span></span>

## <a name="stateless-service-shutdown"></a><span data-ttu-id="66fb0-140">Arrêt de service sans état</span><span class="sxs-lookup"><span data-stu-id="66fb0-140">Stateless service shutdown</span></span>
<span data-ttu-id="66fb0-141">Lorsque vous arrêtez un service sans état, le même modèle est suivi dans l’ordre inverse :</span><span class="sxs-lookup"><span data-stu-id="66fb0-141">When shutting down a stateless service, the same pattern is followed, just in reverse:</span></span>

1. <span data-ttu-id="66fb0-142">En parallèle</span><span class="sxs-lookup"><span data-stu-id="66fb0-142">In parallel</span></span>
    - <span data-ttu-id="66fb0-143">Les écouteurs ouverts sont fermés (`CommunicationListener.closeAsync()` est appelée sur chaque écouteur)</span><span class="sxs-lookup"><span data-stu-id="66fb0-143">Any open listeners are Closed (`CommunicationListener.closeAsync()` is called on each listener)</span></span>
    - <span data-ttu-id="66fb0-144">Le jeton d’annulation passé à `runAsync()` est annulé (en vérifiant que la propriété `isCancelled` du jeton d’annulation retourne la valeur true et que, si elle est appelée, la méthode `throwIfCancellationRequested` du jeton lève une `CancellationException`).</span><span class="sxs-lookup"><span data-stu-id="66fb0-144">The cancellation token passed to `runAsync()` is canceled (checking the cancellation token's `isCancelled` property returns true, and if called the token's `throwIfCancellationRequested` method throws a `CancellationException`)</span></span>
2. <span data-ttu-id="66fb0-145">Lorsque `closeAsync()` se termine sur chaque écouteur et que `runAsync()` se termine également, la méthode `StatelessService.onCloseAsync()` du service est appelée, le cas échéant (il s’agit à nouveau d’un remplacement rare).</span><span class="sxs-lookup"><span data-stu-id="66fb0-145">Once `closeAsync()` completes on each listener and `runAsync()` also completes, the service's `StatelessService.onCloseAsync()` method is called, if present (again this is an uncommon override).</span></span>
3. <span data-ttu-id="66fb0-146">Lorsque `StatelessService.onCloseAsync()` se termine, l’objet de service est détruit</span><span class="sxs-lookup"><span data-stu-id="66fb0-146">After `StatelessService.onCloseAsync()` completes, the service object is destructed</span></span>

## <a name="notes-on-service-lifecycle"></a><span data-ttu-id="66fb0-147">Remarques sur le cycle de vie du service</span><span class="sxs-lookup"><span data-stu-id="66fb0-147">Notes on service lifecycle</span></span>
* <span data-ttu-id="66fb0-148">La méthode `runAsync()` et l’appel `createServiceInstanceListeners` sont facultatifs.</span><span class="sxs-lookup"><span data-stu-id="66fb0-148">Both the `runAsync()` method and the `createServiceInstanceListeners` calls are optional.</span></span> <span data-ttu-id="66fb0-149">Un service peut avoir l’un des deux, les deux ou aucun.</span><span class="sxs-lookup"><span data-stu-id="66fb0-149">A service may have one of them, both, or neither.</span></span> <span data-ttu-id="66fb0-150">Par exemple, si le service effectue tout son travail en réponse aux appels d’utilisateur, il est inutile d’implémenter `runAsync()`.</span><span class="sxs-lookup"><span data-stu-id="66fb0-150">For example, if the service does all its work in response to user calls, there is no need for it to implement `runAsync()`.</span></span> <span data-ttu-id="66fb0-151">Seuls les écouteurs de communication et le code associé sont nécessaires.</span><span class="sxs-lookup"><span data-stu-id="66fb0-151">Only the communication listeners and their associated code are necessary.</span></span> <span data-ttu-id="66fb0-152">De même, la création et le renvoi d’écouteurs de communication sont facultatifs, car le service peut n’avoir que du travail en arrière-plan à exécuter et n’a donc besoin d’implémenter que `runAsync()`</span><span class="sxs-lookup"><span data-stu-id="66fb0-152">Similarly, creating and returning communication listeners is optional, as the service may have only background work to do, and so only needs to implement `runAsync()`</span></span>
* <span data-ttu-id="66fb0-153">Il est valide pour un service de terminer `runAsync()` correctement et d’en revenir.</span><span class="sxs-lookup"><span data-stu-id="66fb0-153">It is valid for a service to complete `runAsync()` successfully and return from it.</span></span> <span data-ttu-id="66fb0-154">Cela n’est pas considéré comme une condition d’échec et correspond à la fin du travail en arrière-plan du service.</span><span class="sxs-lookup"><span data-stu-id="66fb0-154">This is not considered a failure condition and would represent the background work of the service completing.</span></span> <span data-ttu-id="66fb0-155">Pour les Reliable Services avec état, `runAsync()` est appelée à nouveau si le service a été rétrogradé depuis la fonction principale, puis promu de nouveau à la fonction principale.</span><span class="sxs-lookup"><span data-stu-id="66fb0-155">For stateful reliable services `runAsync()` would be called again if the service were demoted from primary and then promoted back to primary.</span></span>
* <span data-ttu-id="66fb0-156">Si un service quitte `runAsync()` en levant une exception inattendue, il s’agit d’un échec, l’objet de service est arrêté et une erreur d’intégrité est signalée.</span><span class="sxs-lookup"><span data-stu-id="66fb0-156">If a service exits from `runAsync()` by throwing some unexpected exception, this is a failure and the service object is shut down and a health error reported.</span></span>
* <span data-ttu-id="66fb0-157">S’il n’existe pas de limite de temps sur le retour de ces méthodes, vous perdez immédiatement la possibilité d’écrire, et vous ne pouvez donc pas effectuer de travail réel.</span><span class="sxs-lookup"><span data-stu-id="66fb0-157">While there is no time limit on returning from these methods, you immediately lose the ability to write and therefore cannot complete any real work.</span></span> <span data-ttu-id="66fb0-158">Il est recommandé de procéder au renvoi aussi rapidement que possible dès la réception de la demande d’annulation.</span><span class="sxs-lookup"><span data-stu-id="66fb0-158">It is recommended that you return as quickly as possible upon receiving the cancellation request.</span></span> <span data-ttu-id="66fb0-159">Si votre service ne répond pas à ces appels d’API dans un délai raisonnable, Service Fabric peut mettre fin à votre service.</span><span class="sxs-lookup"><span data-stu-id="66fb0-159">If your service does not respond to these API calls in a reasonable amount of time Service Fabric may forcibly terminate your service.</span></span> <span data-ttu-id="66fb0-160">En général, cela se produit uniquement lors de mises à niveau d’application ou lorsqu’un service est en cours de suppression.</span><span class="sxs-lookup"><span data-stu-id="66fb0-160">Usually this only happens during application upgrades or when a service is being deleted.</span></span> <span data-ttu-id="66fb0-161">Par défaut, ce délai d’attente est de 15 minutes.</span><span class="sxs-lookup"><span data-stu-id="66fb0-161">This timeout is 15 minutes by default.</span></span>
* <span data-ttu-id="66fb0-162">Les échecs dans le chemin d’accès `onCloseAsync()` entraînent l’appel de `onAbort()` qui constitue une opportunité de dernière chance pour le service de nettoyer et de libérer les ressources demandées.</span><span class="sxs-lookup"><span data-stu-id="66fb0-162">Failures in the `onCloseAsync()` path result in `onAbort()` being called which is a last-chance best-effort opportunity for the service to clean up and release any resources that they have claimed.</span></span>

> [!NOTE]
> <span data-ttu-id="66fb0-163">Les services fiables avec état ne sont pas encore pris en charge par Java.</span><span class="sxs-lookup"><span data-stu-id="66fb0-163">Stateful reliable services are not supported in java yet.</span></span>
>
>

## <a name="next-steps"></a><span data-ttu-id="66fb0-164">Étapes suivantes</span><span class="sxs-lookup"><span data-stu-id="66fb0-164">Next steps</span></span>
* [<span data-ttu-id="66fb0-165">Présentation de Reliable Services</span><span class="sxs-lookup"><span data-stu-id="66fb0-165">Introduction to Reliable Services</span></span>](service-fabric-reliable-services-introduction.md)
* [<span data-ttu-id="66fb0-166">Démarrage rapide de Reliable Services</span><span class="sxs-lookup"><span data-stu-id="66fb0-166">Reliable Services quick start</span></span>](service-fabric-reliable-services-quick-start.md)
* [<span data-ttu-id="66fb0-167">Utilisation avancée de Reliable Services</span><span class="sxs-lookup"><span data-stu-id="66fb0-167">Reliable Services advanced usage</span></span>](service-fabric-reliable-services-advanced-usage.md)
