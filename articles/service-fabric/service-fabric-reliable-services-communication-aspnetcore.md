---
title: communication aaaService avec hello ASP.NET Core | Documents Microsoft
description: "Découvrez comment toouse ASP.NET de base dans les Services fiables et sans état."
services: service-fabric
documentationcenter: .net
author: vturecek
manager: timlt
editor: 
ms.assetid: 8aa4668d-cbb6-4225-bd2d-ab5925a868f2
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: required
ms.date: 05/02/2017
ms.author: vturecek
ms.openlocfilehash: 6e6a83ab04390150292f63de5d9b51d290284e50
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/06/2017
---
# <a name="aspnet-core-in-service-fabric-reliable-services"></a><span data-ttu-id="0a143-103">ASP.NET Core dans le modèle Reliable Services de Service Fabric</span><span class="sxs-lookup"><span data-stu-id="0a143-103">ASP.NET Core in Service Fabric Reliable Services</span></span>

<span data-ttu-id="0a143-104">ASP.NET Core est une nouvelle infrastructure open source et multiplateforme destinée à générer des applications modernes connectées à Internet basées sur le cloud, comme des applications web, des applications IoT et des serveurs principaux mobiles.</span><span class="sxs-lookup"><span data-stu-id="0a143-104">ASP.NET Core is a new open-source and cross-platform framework for building modern cloud-based Internet-connected applications, such as web apps, IoT apps, and mobile backends.</span></span> 

<span data-ttu-id="0a143-105">Cet article est un toohosting guide détaillé des services ASP.NET Core dans Service Fabric des Services fiables à l’aide de hello **Microsoft.ServiceFabric.AspNetCore.** * ensemble des packages NuGet.</span><span class="sxs-lookup"><span data-stu-id="0a143-105">This article is an in-depth guide toohosting ASP.NET Core services in Service Fabric Reliable Services using hello **Microsoft.ServiceFabric.AspNetCore.*** set of NuGet packages.</span></span>

<span data-ttu-id="0a143-106">Pour un didacticiel de présentation d’ASP.NET Core dans Service Fabric et pour des instructions de configuration de votre environnement de développement, voir [Création d’un serveur web frontal pour votre application à l’aide d’ASP.NET Core](service-fabric-add-a-web-frontend.md).</span><span class="sxs-lookup"><span data-stu-id="0a143-106">For an introductory tutorial on ASP.NET Core in Service Fabric and instructions on getting your development environment set up, see [Building a web front-end for your application using ASP.NET Core](service-fabric-add-a-web-frontend.md).</span></span>

<span data-ttu-id="0a143-107">reste Hello de cet article suppose que vous connaissez déjà ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="0a143-107">hello rest of this article assumes you are already familiar with ASP.NET Core.</span></span> <span data-ttu-id="0a143-108">Si non, nous vous conseillons de lire hello [notions de base ASP.NET Core](https://docs.microsoft.com/aspnet/core/fundamentals/index).</span><span class="sxs-lookup"><span data-stu-id="0a143-108">If not, we recommend reading through hello [ASP.NET Core fundamentals](https://docs.microsoft.com/aspnet/core/fundamentals/index).</span></span>

## <a name="aspnet-core-in-hello-service-fabric-environment"></a><span data-ttu-id="0a143-109">ASP.NET Core dans un environnement de Service Fabric hello</span><span class="sxs-lookup"><span data-stu-id="0a143-109">ASP.NET Core in hello Service Fabric environment</span></span>

<span data-ttu-id="0a143-110">Alors que les applications ASP.NET Core peuvent exécuter sur .NET Core ou sur hello sur que .NET Framework complet, actuellement les services de Fabric de Service peut s’exécuter uniquement hello .NET Framework complet.</span><span class="sxs-lookup"><span data-stu-id="0a143-110">While ASP.NET Core apps can run on .NET Core or on hello full .NET Framework, Service Fabric services currently can only run on hello full .NET Framework.</span></span> <span data-ttu-id="0a143-111">Cela signifie que lorsque vous générez un service ASP.NET Core pour Service Fabric, vous devez toujours cibler hello .NET Framework complet.</span><span class="sxs-lookup"><span data-stu-id="0a143-111">This means when you build an ASP.NET  Core Service Fabric service, you must still target hello full .NET Framework.</span></span>

<span data-ttu-id="0a143-112">L’infrastructure ASP.NET Core peut être utilisée de deux manières dans Service Fabric :</span><span class="sxs-lookup"><span data-stu-id="0a143-112">ASP.NET Core can be used in two different ways in Service Fabric:</span></span>
 - <span data-ttu-id="0a143-113">**Hébergée en tant qu’exécutable invité**.</span><span class="sxs-lookup"><span data-stu-id="0a143-113">**Hosted as a guest executable**.</span></span> <span data-ttu-id="0a143-114">Il s’agit principalement utilisé toorun ASP.NET Core applications existantes sur l’infrastructure de Service sans aucune modification de code.</span><span class="sxs-lookup"><span data-stu-id="0a143-114">This is primarily used toorun existing ASP.NET Core applications on Service Fabric with no code changes.</span></span>
 - <span data-ttu-id="0a143-115">**Exécutée dans un service Reliable Service**.</span><span class="sxs-lookup"><span data-stu-id="0a143-115">**Run inside a Reliable Service**.</span></span> <span data-ttu-id="0a143-116">Cela permet une meilleure intégration avec le runtime du Service Fabric hello et avec état ASP.NET Core services.</span><span class="sxs-lookup"><span data-stu-id="0a143-116">This allows better integration with hello Service Fabric runtime and allows stateful ASP.NET Core services.</span></span>

<span data-ttu-id="0a143-117">reste Hello de cet article explique comment toouse ASP.NET Core à l’intérieur d’un Service fiable à l’aide de hello des composants d’intégration ASP.NET Core fournis avec hello SDK de l’infrastructure de Service.</span><span class="sxs-lookup"><span data-stu-id="0a143-117">hello rest of this article explains how toouse ASP.NET Core inside a Reliable Service using hello ASP.NET Core integration components that ship with hello Service Fabric SDK.</span></span> 

## <a name="service-fabric-service-hosting"></a><span data-ttu-id="0a143-118">Hébergement du service Service Fabric</span><span class="sxs-lookup"><span data-stu-id="0a143-118">Service Fabric service hosting</span></span>

<span data-ttu-id="0a143-119">Dans Service Fabric, une ou plusieurs instances et/ou un ou plusieurs réplicas de votre service s’exécutent dans un *processus hôte de service*, un fichier exécutable qui exécute le code de votre service.</span><span class="sxs-lookup"><span data-stu-id="0a143-119">In Service Fabric, one or more instances and/or replicas of your service run in a *service host process*, an executable file that runs your service code.</span></span> <span data-ttu-id="0a143-120">Vous, en tant qu’auteur de service, propre processus hôte de service hello et Service Fabric active et il surveille.</span><span class="sxs-lookup"><span data-stu-id="0a143-120">You, as a service author, own hello service host process and Service Fabric activates and monitors it for you.</span></span>

<span data-ttu-id="0a143-121">ASP.NET traditionnel (haut tooMVC 5) est étroitement couplées tooIIS via System.Web.dll.</span><span class="sxs-lookup"><span data-stu-id="0a143-121">Traditional ASP.NET (up tooMVC 5) is tightly coupled tooIIS through System.Web.dll.</span></span> <span data-ttu-id="0a143-122">ASP.NET Core fournit une séparation entre le serveur web de hello et votre application web.</span><span class="sxs-lookup"><span data-stu-id="0a143-122">ASP.NET Core provides a separation between hello web server and your web application.</span></span> <span data-ttu-id="0a143-123">Cela permet toobe d’applications web portable entre les différents serveurs web et également toobe de serveurs web *auto-hébergé*, ce qui signifie que vous pouvez démarrer un serveur web dans votre propre processus, en tant que processus tooa opposés détenu par le web dédié logiciel serveur telles que IIS.</span><span class="sxs-lookup"><span data-stu-id="0a143-123">This allows web applications toobe portable between different web servers and also allows web servers toobe *self-hosted*, which means you can start a web server in your own process, as opposed tooa process that is owned by dedicated web server software such as IIS.</span></span> 

<span data-ttu-id="0a143-124">Dans l’ordre toocombine un service Service Fabric et ASP.NET, comme un exécutable invité ou dans un Service fiable, vous devez être en mesure de toostart ASP.NET à l’intérieur de votre processus hôte de service.</span><span class="sxs-lookup"><span data-stu-id="0a143-124">In order toocombine a Service Fabric service and ASP.NET, either as a guest executable or in a Reliable Service, you must be able toostart ASP.NET inside your service host process.</span></span> <span data-ttu-id="0a143-125">ASP.NET Core auto-hébergement vous permet de toodo cela.</span><span class="sxs-lookup"><span data-stu-id="0a143-125">ASP.NET Core self-hosting allows you toodo this.</span></span>

## <a name="hosting-aspnet-core-in-a-reliable-service"></a><span data-ttu-id="0a143-126">Hébergement d’ASP.NET Core dans un service Reliable Service</span><span class="sxs-lookup"><span data-stu-id="0a143-126">Hosting ASP.NET Core in a Reliable Service</span></span>
<span data-ttu-id="0a143-127">En règle générale, les applications ASP.NET Core auto-hébergé créent WebHost dans le point d’entrée d’une application, par exemple hello `static void Main()` méthode dans `Program.cs`.</span><span class="sxs-lookup"><span data-stu-id="0a143-127">Typically, self-hosted ASP.NET Core applications create a WebHost in an application's entry point, such as hello `static void Main()` method in `Program.cs`.</span></span> <span data-ttu-id="0a143-128">Dans ce cas, le cycle de vie de hello Hello WebHost est lié toohello le cycle de vie du processus de hello.</span><span class="sxs-lookup"><span data-stu-id="0a143-128">In this case, hello lifecycle of hello WebHost is bound toohello lifecycle of hello process.</span></span>

![Hébergement d’ASP.NET Core dans un processus][0]

<span data-ttu-id="0a143-130">Toutefois, point d’entrée application hello n’est pas hello bon endroit toocreate WebHost dans un Service fiable, parce que le point d’entrée application hello est utilisée uniquement tooregister un service de type avec le runtime du Service Fabric hello, afin qu’il peut créer des instances de ce service type.</span><span class="sxs-lookup"><span data-stu-id="0a143-130">However, hello application entry point is not hello right place toocreate a WebHost in a Reliable Service, because hello application entry point is only used tooregister a service type with hello Service Fabric runtime, so that it may create instances of that service type.</span></span> <span data-ttu-id="0a143-131">Hello WebHost doit être créé dans un Service fiable lui-même.</span><span class="sxs-lookup"><span data-stu-id="0a143-131">hello WebHost should be created in a Reliable Service itself.</span></span> <span data-ttu-id="0a143-132">Dans le processus hôte de service hello, instances de service et/ou de réplicas peuvent subir plusieurs cycles de vie.</span><span class="sxs-lookup"><span data-stu-id="0a143-132">Within hello service host process, service instances and/or replicas can go through multiple lifecycles.</span></span> 

<span data-ttu-id="0a143-133">Une instance du service Reliable Service est représentée par votre classe de service dérivant de `StatelessService` ou `StatefulService`.</span><span class="sxs-lookup"><span data-stu-id="0a143-133">A Reliable Service instance is represented by your service class deriving from `StatelessService` or `StatefulService`.</span></span> <span data-ttu-id="0a143-134">pile de communication Hello pour un service est contenue dans un `ICommunicationListener` mise en œuvre dans votre classe de service.</span><span class="sxs-lookup"><span data-stu-id="0a143-134">hello communication stack for a service is contained in an `ICommunicationListener` implementation in your service class.</span></span> <span data-ttu-id="0a143-135">Hello `Microsoft.ServiceFabric.Services.AspNetCore.*` les packages NuGet contiennent des implémentations de `ICommunicationListener` que Démarrer et gérer hello ASP.NET Core WebHost pour Kestrel ou WebListener dans un Service fiable.</span><span class="sxs-lookup"><span data-stu-id="0a143-135">hello `Microsoft.ServiceFabric.Services.AspNetCore.*` NuGet packages contain implementations of `ICommunicationListener` that start and manage hello ASP.NET Core WebHost for either Kestrel or WebListener in a Reliable Service.</span></span>

![Hébergement d’ASP.NET Core dans un service Reliable Service][1]

## <a name="aspnet-core-icommunicationlisteners"></a><span data-ttu-id="0a143-137">Écouteurs ICommunicationListeners d’ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="0a143-137">ASP.NET Core ICommunicationListeners</span></span>
<span data-ttu-id="0a143-138">Hello `ICommunicationListener` implémentations pour Kestrel et WebListener Bonjour `Microsoft.ServiceFabric.Services.AspNetCore.*` les packages NuGet ont des modèles d’utilisation similaires mais effectuer légèrement différentes actions spécifiques tooeach web server.</span><span class="sxs-lookup"><span data-stu-id="0a143-138">hello `ICommunicationListener` implementations for Kestrel and WebListener in hello  `Microsoft.ServiceFabric.Services.AspNetCore.*` NuGet packages have similar use patterns but perform slightly different actions specific tooeach web server.</span></span> 

<span data-ttu-id="0a143-139">Les deux écouteurs de communication fournissent un constructeur qui accepte hello arguments suivants :</span><span class="sxs-lookup"><span data-stu-id="0a143-139">Both communication listeners provide a constructor that takes hello following arguments:</span></span>
 - <span data-ttu-id="0a143-140">**`ServiceContext serviceContext`**: hello `ServiceContext` objet qui contient des informations sur hello service en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="0a143-140">**`ServiceContext serviceContext`**: hello `ServiceContext` object that contains information about hello running service.</span></span>
 - <span data-ttu-id="0a143-141">**`string endpointName`**: nom hello d’un `Endpoint` configuration dans ServiceManifest.xml.</span><span class="sxs-lookup"><span data-stu-id="0a143-141">**`string endpointName`**: hello name of an `Endpoint` configuration in ServiceManifest.xml.</span></span> <span data-ttu-id="0a143-142">Il s’agit principalement où diffèrent des écouteurs de communication hello deux : WebListener **requiert** un `Endpoint` configuration, n’est pas le cas de Kestrel.</span><span class="sxs-lookup"><span data-stu-id="0a143-142">This is primarily where hello two communication listeners differ: WebListener **requires** an `Endpoint` configuration, while Kestrel does not.</span></span>
 - <span data-ttu-id="0a143-143">**`Func<string, AspNetCoreCommunicationListener, IWebHost> build`** : expression lambda que vous implémentez dans laquelle vous créez et retournez un `IWebHost`.</span><span class="sxs-lookup"><span data-stu-id="0a143-143">**`Func<string, AspNetCoreCommunicationListener, IWebHost> build`**: a lambda that you implement in which you create and return an `IWebHost`.</span></span> <span data-ttu-id="0a143-144">Cela vous permet de tooconfigure `IWebHost` moyen hello vous le feriez normalement dans une application ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="0a143-144">This allows you tooconfigure `IWebHost` hello way you normally would in an ASP.NET Core application.</span></span> <span data-ttu-id="0a143-145">Hello lambda fournit une URL qui est générée pour vous en fonction de l’intégration de Service Fabric hello options que vous utilisez et hello `Endpoint` configuration que vous fournissez.</span><span class="sxs-lookup"><span data-stu-id="0a143-145">hello lambda provides a URL which is generated for you depending on hello Service Fabric integration options you use and hello `Endpoint` configuration you provide.</span></span> <span data-ttu-id="0a143-146">Que URL puis peut être modifié ou utilisé en tant que-est le serveur web de hello toostart.</span><span class="sxs-lookup"><span data-stu-id="0a143-146">That URL can then be modified or used as-is toostart hello web server.</span></span>

## <a name="service-fabric-integration-middleware"></a><span data-ttu-id="0a143-147">Intergiciel (middleware) d’intégration à Service Fabric</span><span class="sxs-lookup"><span data-stu-id="0a143-147">Service Fabric integration middleware</span></span>
<span data-ttu-id="0a143-148">Hello `Microsoft.ServiceFabric.Services.AspNetCore` package NuGet inclut hello `UseServiceFabricIntegration` méthode d’extension sur `IWebHostBuilder` qui ajoute l’intergiciel (middleware) Service Fabric prenant en charge.</span><span class="sxs-lookup"><span data-stu-id="0a143-148">hello `Microsoft.ServiceFabric.Services.AspNetCore` NuGet package includes hello `UseServiceFabricIntegration` extension method on `IWebHostBuilder` that adds Service Fabric-aware middleware.</span></span> <span data-ttu-id="0a143-149">Cet intergiciel (middleware) configure hello Kestrel ou WebListener `ICommunicationListener` tooregister une URL de service unique avec hello l’infrastructure de Service d’affectation de noms de Service, puis valide les clients tooensure de demandes de clients se connectent toohello bon service.</span><span class="sxs-lookup"><span data-stu-id="0a143-149">This middleware configures hello Kestrel or WebListener `ICommunicationListener` tooregister a unique service URL with hello Service Fabric Naming Service and then validates client requests tooensure clients are connecting toohello right service.</span></span> <span data-ttu-id="0a143-150">Cela est nécessaire dans un environnement hôte partagés tels que l’infrastructure de Service, où plusieurs applications web peuvent exécuter sur hello même physique ou virtuel, mais n’utilisent pas de nom d’hôte unique, tooprevent clients par erreur connexion toohello un mauvais service.</span><span class="sxs-lookup"><span data-stu-id="0a143-150">This is necessary in a shared-host environment such as Service Fabric, where multiple web applications can run on hello same physical or virtual machine but do not use unique host names, tooprevent clients from mistakenly connecting toohello wrong service.</span></span> <span data-ttu-id="0a143-151">Ce scénario est décrit plus en détail dans la section suivante de hello.</span><span class="sxs-lookup"><span data-stu-id="0a143-151">This scenario is described in more detail in hello next section.</span></span>

### <a name="a-case-of-mistaken-identity"></a><span data-ttu-id="0a143-152">Cas d’erreur d’identité</span><span class="sxs-lookup"><span data-stu-id="0a143-152">A case of mistaken identity</span></span>
<span data-ttu-id="0a143-153">Quel que soit le protocole utilisé, les réplicas de service écoutent sur une combinaison IP:port unique.</span><span class="sxs-lookup"><span data-stu-id="0a143-153">Service replicas, regardless of protocol, listen on a unique IP:port combination.</span></span> <span data-ttu-id="0a143-154">Une fois qu’un réplica de service a démarré à l’écoute sur un point de terminaison IP : port, il signale cette toohello d’adresse de point de terminaison Service Service Fabric d’affectation de noms dans lequel il peut être détecté par les clients ou d’autres services.</span><span class="sxs-lookup"><span data-stu-id="0a143-154">Once a service replica has started listening on an IP:port endpoint, it reports that endpoint address toohello Service Fabric Naming Service where it can be discovered by clients or other services.</span></span> <span data-ttu-id="0a143-155">Si les services utilisent des ports affectés dynamiquement une application, un réplica de service peuvent utiliser par coïncidence hello même point de terminaison IP : port d’un autre service qui a été précédemment sur hello même physique ou virtuel.</span><span class="sxs-lookup"><span data-stu-id="0a143-155">If services use dynamically-assigned application ports, a service replica may coincidentally use hello same IP:port endpoint of another service that was previously on hello same physical or virtual machine.</span></span> <span data-ttu-id="0a143-156">Cela peut entraîner un client toomistakely connecter toohello un mauvais service.</span><span class="sxs-lookup"><span data-stu-id="0a143-156">This can cause a client toomistakely connect toohello wrong service.</span></span> <span data-ttu-id="0a143-157">Cela peut se produire si hello suivant la séquence d’événements se produire :</span><span class="sxs-lookup"><span data-stu-id="0a143-157">This can happen if hello following sequence of events occur:</span></span>

 1. <span data-ttu-id="0a143-158">Le service A écoute sur 10.0.0.1:30000 via HTTP.</span><span class="sxs-lookup"><span data-stu-id="0a143-158">Service A listens on 10.0.0.1:30000 over HTTP.</span></span> 
 2. <span data-ttu-id="0a143-159">Le client résout le service A et obtient l’adresse 10.0.0.1:30000.</span><span class="sxs-lookup"><span data-stu-id="0a143-159">Client resolves Service A and gets address 10.0.0.1:30000</span></span>
 3. <span data-ttu-id="0a143-160">Un nœud différent du tooa se déplace du service.</span><span class="sxs-lookup"><span data-stu-id="0a143-160">Service A moves tooa different node.</span></span>
 4. <span data-ttu-id="0a143-161">Service B est placé sur 10.0.0.1 et par coïncidence utilise hello même port 30000.</span><span class="sxs-lookup"><span data-stu-id="0a143-161">Service B is placed on 10.0.0.1 and coincidentally uses hello same port 30000.</span></span>
 5. <span data-ttu-id="0a143-162">Client tente de tooconnect tooservice A avec l’adresse mise en cache 10.0.0.1:30000.</span><span class="sxs-lookup"><span data-stu-id="0a143-162">Client attempts tooconnect tooservice A with cached address 10.0.0.1:30000.</span></span>
 6. <span data-ttu-id="0a143-163">Client est maintenant connecté tooservice B ne pas vous en rendre compte est connecté toohello un mauvais service.</span><span class="sxs-lookup"><span data-stu-id="0a143-163">Client is now successfully connected tooservice B not realizing it is connected toohello wrong service.</span></span>

<span data-ttu-id="0a143-164">Cela peut provoquer des bogues à des moments aléatoires qui peuvent être difficile toodiagnose.</span><span class="sxs-lookup"><span data-stu-id="0a143-164">This can cause bugs at random times that can be difficult toodiagnose.</span></span> 

### <a name="using-unique-service-urls"></a><span data-ttu-id="0a143-165">Utilisation d’URL de service uniques</span><span class="sxs-lookup"><span data-stu-id="0a143-165">Using unique service URLs</span></span>
<span data-ttu-id="0a143-166">tooprevent, services peut valider un toohello de point de terminaison Service d’affectation de noms avec un identificateur unique et puis vérifiez que l’identificateur unique lors des demandes de client.</span><span class="sxs-lookup"><span data-stu-id="0a143-166">tooprevent this, services can post an endpoint toohello Naming Service with a unique identifier, and then validate that unique identifier during client requests.</span></span> <span data-ttu-id="0a143-167">Il s’agit d’une action de coopération entre les services dans un environnement approuvé de client non hostile.</span><span class="sxs-lookup"><span data-stu-id="0a143-167">This is a cooperative action between services in a non-hostile-tenant trusted environment.</span></span> <span data-ttu-id="0a143-168">Cette action ne permet pas d’authentification de service sécurisée dans un environnement de client hostile.</span><span class="sxs-lookup"><span data-stu-id="0a143-168">This does not provide secure service authentication in a hostile-tenant environment.</span></span>

<span data-ttu-id="0a143-169">Dans un environnement approuvé, hello intergiciel (middleware) qui est ajouté par hello `UseServiceFabricIntegration` méthode ajoute automatiquement une adresse de toohello identificateur unique qui est validée toohello d’affectation de noms Service et vérifie que l’identificateur à chaque demande.</span><span class="sxs-lookup"><span data-stu-id="0a143-169">In a trusted environment, hello middleware that's added by hello `UseServiceFabricIntegration` method automatically appends a unique identifier toohello address that is posted toohello Naming Service and validates that identifier on each request.</span></span> <span data-ttu-id="0a143-170">Si l’identificateur de hello ne correspond pas, hello intergiciel (middleware) retourne immédiatement une réponse HTTP 410 supprimé.</span><span class="sxs-lookup"><span data-stu-id="0a143-170">If hello identifier does not match, hello middleware immediately returns an HTTP 410 Gone response.</span></span>

<span data-ttu-id="0a143-171">Les services qui utilisent un port attribué dynamiquement doivent avoir recours à cet intergiciel (middleware).</span><span class="sxs-lookup"><span data-stu-id="0a143-171">Services that use a dynamically-assigned port should make use of this middleware.</span></span>

<span data-ttu-id="0a143-172">Les services qui utilisent un port unique fixe ne connaissent pas ce problème dans un environnement coopératif.</span><span class="sxs-lookup"><span data-stu-id="0a143-172">Services that use a fixed unique port do not have this problem in a cooperative environment.</span></span> <span data-ttu-id="0a143-173">Un port unique fixe est généralement utilisé pour externe services nécessitant un port bien connu pour tooconnect d’applications client à.</span><span class="sxs-lookup"><span data-stu-id="0a143-173">A fixed unique port is typically used for externally-facing services that need a well-known port for client applications tooconnect to.</span></span> <span data-ttu-id="0a143-174">Par exemple, la plupart des applications web accessibles sur Internet utilisent les ports 80 ou 443 pour les connexions de navigateur web.</span><span class="sxs-lookup"><span data-stu-id="0a143-174">For example, most Internet-facing web applications will use port 80 or 443 for web browser connections.</span></span> <span data-ttu-id="0a143-175">Dans ce cas, identificateur hello ne doit pas être activée.</span><span class="sxs-lookup"><span data-stu-id="0a143-175">In this case, hello unique identifier should not be enabled.</span></span>

<span data-ttu-id="0a143-176">Hello diagramme suivant montre les flux de demandes hello avec intergiciel (middleware) hello activé :</span><span class="sxs-lookup"><span data-stu-id="0a143-176">hello following diagram shows hello request flow with hello middleware enabled:</span></span>

![Intégration d’ASP.NET Core à Service Fabric][2]

<span data-ttu-id="0a143-178">Kestrel et WebListener `ICommunicationListener` implémentations utilisent ce mécanisme Bonjour exactement identique.</span><span class="sxs-lookup"><span data-stu-id="0a143-178">Both Kestrel and WebListener `ICommunicationListener` implementations use this mechanism in exactly hello same way.</span></span> <span data-ttu-id="0a143-179">Bien que WebListener pouvez différencier en interne les demandes en fonction des chemins d’accès URL uniques à l’aide de hello sous-jacent *http.sys* la fonctionnalité, qui est de la fonctionnalité de partage de port *pas* utilisé par hello WebListener `ICommunicationListener` implémentation car qui entraînerait des codes d’état erreur HTTP 503 et HTTP 404 dans scénario hello décrits précédemment.</span><span class="sxs-lookup"><span data-stu-id="0a143-179">Although WebListener can internally differentiate requests based on unique URL paths using hello underlying *http.sys* port sharing feature, that functionality is *not* used by hello WebListener `ICommunicationListener` implementation because that will result in HTTP 503 and HTTP 404 error status codes in hello scenario described earlier.</span></span> <span data-ttu-id="0a143-180">Qui à son tour rend très difficile pour intention de hello clients toodetermine d’erreur de hello, comme HTTP 503 et HTTP 404 sont déjà tooindicate couramment utilisé autres erreurs.</span><span class="sxs-lookup"><span data-stu-id="0a143-180">That in turn makes it very difficult for clients toodetermine hello intent of hello error, as HTTP 503 and HTTP 404 are already commonly used tooindicate other errors.</span></span> <span data-ttu-id="0a143-181">Par conséquent, à la fois Kestrel et WebListener `ICommunicationListener` normaliser les implémentations sur un intergiciel (middleware) hello fournie par hello `UseServiceFabricIntegration` méthode d’extension pour que les clients doivent uniquement tooperform un point de terminaison de résoudre l’action sur les réponses HTTP 410.</span><span class="sxs-lookup"><span data-stu-id="0a143-181">Thus, both Kestrel and WebListener `ICommunicationListener` implementations standardize on hello middleware provided by hello `UseServiceFabricIntegration` extension method so that clients only need tooperform a service endpoint re-resolve action on HTTP 410 responses.</span></span>

## <a name="weblistener-in-reliable-services"></a><span data-ttu-id="0a143-182">WebListener dans Reliable Services</span><span class="sxs-lookup"><span data-stu-id="0a143-182">WebListener in Reliable Services</span></span>
<span data-ttu-id="0a143-183">WebListener peut être utilisé dans un Service fiable en important hello **Microsoft.ServiceFabric.AspNetCore.WebListener** package NuGet.</span><span class="sxs-lookup"><span data-stu-id="0a143-183">WebListener can be used in a Reliable Service by importing hello **Microsoft.ServiceFabric.AspNetCore.WebListener** NuGet package.</span></span> <span data-ttu-id="0a143-184">Ce package contient `WebListenerCommunicationListener`, une implémentation de `ICommunicationListener`, qui vous permet de toocreate un WebHost de noyaux de ASP.NET à l’intérieur d’un Service fiable à l’aide de WebListener en tant que serveur web de hello.</span><span class="sxs-lookup"><span data-stu-id="0a143-184">This package contains `WebListenerCommunicationListener`, an implementation of `ICommunicationListener`, that allows you toocreate an ASP.NET Core WebHost inside a Reliable Service using WebListener as hello web server.</span></span>

<span data-ttu-id="0a143-185">WebListener repose sur hello [API du serveur HTTP Windows](https://msdn.microsoft.com/library/windows/desktop/aa364510(v=vs.85).aspx).</span><span class="sxs-lookup"><span data-stu-id="0a143-185">WebListener is built on hello [Windows HTTP Server API](https://msdn.microsoft.com/library/windows/desktop/aa364510(v=vs.85).aspx).</span></span> <span data-ttu-id="0a143-186">Cette méthode utilise hello *http.sys* pilote du noyau utilisé par IIS tooprocess HTTP demande et acheminer tooprocesses les applications web en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="0a143-186">This uses hello *http.sys* kernel driver used by IIS tooprocess HTTP requests and route them tooprocesses running web applications.</span></span> <span data-ttu-id="0a143-187">Cela permet à plusieurs processus sur hello même ordinateur physique ou virtuel toohost web applications sur hello même port, par un chemin d’URL unique ou un nom d’hôte de lever l’ambiguïté.</span><span class="sxs-lookup"><span data-stu-id="0a143-187">This allows multiple processes on hello same physical or virtual machine toohost web applications on hello same port, disambiguated by either a unique URL path or hostname.</span></span> <span data-ttu-id="0a143-188">Ces fonctionnalités sont utiles dans l’infrastructure de Service pour l’hébergement de plusieurs sites Web Bonjour même cluster.</span><span class="sxs-lookup"><span data-stu-id="0a143-188">These features are useful in Service Fabric for hosting multiple websites in hello same cluster.</span></span>

<span data-ttu-id="0a143-189">Hello diagramme suivant illustre comment WebListener utilise hello *http.sys* pilote du noyau de Windows pour le partage de port :</span><span class="sxs-lookup"><span data-stu-id="0a143-189">hello following diagram illustrates how WebListener uses hello *http.sys* kernel driver on Windows for port sharing:</span></span>

![http.sys][3]

### <a name="weblistener-in-a-stateless-service"></a><span data-ttu-id="0a143-191">WebListener dans un service sans état</span><span class="sxs-lookup"><span data-stu-id="0a143-191">WebListener in a stateless service</span></span>
<span data-ttu-id="0a143-192">toouse `WebListener` dans un service sans état, substituez hello `CreateServiceInstanceListeners` méthode et retournez un `WebListenerCommunicationListener` instance :</span><span class="sxs-lookup"><span data-stu-id="0a143-192">toouse `WebListener` in a stateless service, override hello `CreateServiceInstanceListeners` method and return a `WebListenerCommunicationListener` instance:</span></span>

```csharp
protected override IEnumerable<ServiceInstanceListener> CreateServiceInstanceListeners()
{
    return new ServiceInstanceListener[]
    {
        new ServiceInstanceListener(serviceContext =>
            new WebListenerCommunicationListener(serviceContext, "ServiceEndpoint", (url, listener) =>
                new WebHostBuilder()
                    .UseWebListener()
                    .ConfigureServices(
                        services => services
                            .AddSingleton<StatelessServiceContext>(serviceContext))
                    .UseContentRoot(Directory.GetCurrentDirectory())
                    .UseServiceFabricIntegration(listener, ServiceFabricIntegrationOptions.None)
                    .UseStartup<Startup>()
                    .UseUrls(url)
                    .Build()))
    };
}
```

### <a name="weblistener-in-a-stateful-service"></a><span data-ttu-id="0a143-193">WebListener dans un service avec état</span><span class="sxs-lookup"><span data-stu-id="0a143-193">WebListener in a stateful service</span></span>

<span data-ttu-id="0a143-194">`WebListenerCommunicationListener`n’est actuellement pas conçu pour une utilisation dans les services avec état échéance toocomplications avec hello sous-jacent *http.sys* la fonctionnalité de partage de port.</span><span class="sxs-lookup"><span data-stu-id="0a143-194">`WebListenerCommunicationListener` is currently not designed for use in stateful services due toocomplications with hello underlying *http.sys* port sharing feature.</span></span> <span data-ttu-id="0a143-195">Pour plus d’informations, consultez hello suivant la section sur l’allocation de port dynamique avec WebListener.</span><span class="sxs-lookup"><span data-stu-id="0a143-195">For more information, see hello following section on dynamic port allocation with WebListener.</span></span> <span data-ttu-id="0a143-196">Pour les services avec état, Kestrel est hello recommandé de serveur web.</span><span class="sxs-lookup"><span data-stu-id="0a143-196">For stateful services, Kestrel is hello recommended web server.</span></span>

### <a name="endpoint-configuration"></a><span data-ttu-id="0a143-197">Configuration du point de terminaison</span><span class="sxs-lookup"><span data-stu-id="0a143-197">Endpoint configuration</span></span>

<span data-ttu-id="0a143-198">Un `Endpoint` configuration est requise pour les serveurs web qui utilisent hello API de serveur HTTP de Windows, y compris WebListener.</span><span class="sxs-lookup"><span data-stu-id="0a143-198">An `Endpoint` configuration is required for web servers that use hello Windows HTTP Server API, including WebListener.</span></span> <span data-ttu-id="0a143-199">Serveurs Web qui utilisent hello Windows HTTP Server API doivent réserver tout d’abord leur URL avec *http.sys* (cela se produit généralement avec hello [netsh](https://msdn.microsoft.com/library/windows/desktop/cc307236(v=vs.85).aspx) outil).</span><span class="sxs-lookup"><span data-stu-id="0a143-199">Web servers that use hello Windows HTTP Server API must first reserve their URL with *http.sys* (this is normally accomplished with hello [netsh](https://msdn.microsoft.com/library/windows/desktop/cc307236(v=vs.85).aspx) tool).</span></span> <span data-ttu-id="0a143-200">Cette action requiert des privilèges élevés dont vos services sont dépourvus par défaut.</span><span class="sxs-lookup"><span data-stu-id="0a143-200">This action requires elevated privileges that your services by default do not have.</span></span> <span data-ttu-id="0a143-201">Hello options « http » ou « https » pour hello `Protocol` propriété Hello `Endpoint` configuration dans *ServiceManifest.xml* sont utilisées spécifiquement tooinstruct hello Service Fabric runtime tooregister une URL avec *http.sys* à votre place à l’aide de hello [ *caractère générique fort* ](https://msdn.microsoft.com/library/windows/desktop/aa364698(v=vs.85).aspx) préfixe d’URL.</span><span class="sxs-lookup"><span data-stu-id="0a143-201">hello "http" or "https" options for hello `Protocol` property of hello `Endpoint` configuration in *ServiceManifest.xml* are used specifically tooinstruct hello Service Fabric runtime tooregister a URL with *http.sys* on your behalf using hello [*strong wildcard*](https://msdn.microsoft.com/library/windows/desktop/aa364698(v=vs.85).aspx) URL prefix.</span></span>

<span data-ttu-id="0a143-202">Par exemple, tooreserve `http://+:80` pour un service, hello configuration suivante doit être utilisée dans ServiceManifest.xml :</span><span class="sxs-lookup"><span data-stu-id="0a143-202">For example, tooreserve `http://+:80` for a service, hello following configuration should be used in ServiceManifest.xml:</span></span>

```xml
<ServiceManifest ... >
    ...
    <Resources>
        <Endpoints>
            <Endpoint Name="ServiceEndpoint" Protocol="http" Port="80" />
        </Endpoints>
    </Resources>

</ServiceManifest>
```

<span data-ttu-id="0a143-203">Et le nom du point de terminaison hello doit être passé toohello `WebListenerCommunicationListener` constructeur :</span><span class="sxs-lookup"><span data-stu-id="0a143-203">And hello endpoint name must be passed toohello `WebListenerCommunicationListener` constructor:</span></span>

```csharp
 new WebListenerCommunicationListener(serviceContext, "ServiceEndpoint", (url, listener) =>
 {
     return new WebHostBuilder()
         .UseWebListener()
         .UseServiceFabricIntegration(listener, ServiceFabricIntegrationOptions.None)
         .UseUrls(url)
         .Build();
 })
```

#### <a name="use-weblistener-with-a-static-port"></a><span data-ttu-id="0a143-204">Utiliser WebListener avec un port statique</span><span class="sxs-lookup"><span data-stu-id="0a143-204">Use WebListener with a static port</span></span>
<span data-ttu-id="0a143-205">toouse un port statique avec WebListener, indiquez le numéro de port de hello Bonjour `Endpoint` configuration :</span><span class="sxs-lookup"><span data-stu-id="0a143-205">toouse a static port with WebListener, provide hello port number in hello `Endpoint` configuration:</span></span>

```xml
  <Resources>
    <Endpoints>
      <Endpoint Protocol="http" Name="ServiceEndpoint" Port="80" />
    </Endpoints>
  </Resources>
```

#### <a name="use-weblistener-with-a-dynamic-port"></a><span data-ttu-id="0a143-206">Utiliser WebListener avec un port dynamique</span><span class="sxs-lookup"><span data-stu-id="0a143-206">Use WebListener with a dynamic port</span></span>
<span data-ttu-id="0a143-207">toouse un port affecté dynamiquement avec WebListener, omettez hello `Port` propriété Bonjour `Endpoint` configuration :</span><span class="sxs-lookup"><span data-stu-id="0a143-207">toouse a dynamically assigned port with WebListener, omit hello `Port` property in hello `Endpoint` configuration:</span></span>

```xml
  <Resources>
    <Endpoints>
      <Endpoint Protocol="http" Name="ServiceEndpoint" />
    </Endpoints>
  </Resources>
```

<span data-ttu-id="0a143-208">Notez qu’un port dynamique alloué par une configuration `Endpoint` fournit un seul port *par processus hôte*.</span><span class="sxs-lookup"><span data-stu-id="0a143-208">Note that a dynamic port allocated by an `Endpoint` configuration only provides one port *per host process*.</span></span> <span data-ttu-id="0a143-209">Hello actuel Service Fabric modèle d’hébergement permet à plusieurs toobe d’instances et/ou des réplicas de service hébergé dans hello même processus, ce qui signifie que chacun d’eux sera partagent hello même port lors de l’allocation via hello `Endpoint` configuration.</span><span class="sxs-lookup"><span data-stu-id="0a143-209">hello current Service Fabric hosting model allows multiple service instances and/or replicas toobe hosted in hello same process, meaning that each one will share hello same port when allocated through hello `Endpoint` configuration.</span></span> <span data-ttu-id="0a143-210">Plusieurs instances de WebListener peuvent partager un port à l’aide de hello sous-jacent *http.sys* port partage de la fonctionnalité, mais qui n’est pas pris en charge par `WebListenerCommunicationListener` en raison de complications toohello elle introduit pour les demandes du client.</span><span class="sxs-lookup"><span data-stu-id="0a143-210">Multiple WebListener instances can share a port using hello underlying *http.sys* port sharing feature, but that is not supported by `WebListenerCommunicationListener` due toohello complications it introduces for client requests.</span></span> <span data-ttu-id="0a143-211">Pour l’utilisation de ports dynamiques, Kestrel est hello recommandé de serveur web.</span><span class="sxs-lookup"><span data-stu-id="0a143-211">For dynamic port usage, Kestrel is hello recommended web server.</span></span>

## <a name="kestrel-in-reliable-services"></a><span data-ttu-id="0a143-212">Kestrel dans Reliable Services</span><span class="sxs-lookup"><span data-stu-id="0a143-212">Kestrel in Reliable Services</span></span>
<span data-ttu-id="0a143-213">Kestrel peut être utilisé dans un Service fiable en important hello **Microsoft.ServiceFabric.AspNetCore.Kestrel** package NuGet.</span><span class="sxs-lookup"><span data-stu-id="0a143-213">Kestrel can be used in a Reliable Service by importing hello **Microsoft.ServiceFabric.AspNetCore.Kestrel** NuGet package.</span></span> <span data-ttu-id="0a143-214">Ce package contient `KestrelCommunicationListener`, une implémentation de `ICommunicationListener`, qui vous permet de toocreate un WebHost de noyaux de ASP.NET à l’intérieur d’un Service fiable à l’aide de Kestrel en tant que serveur web de hello.</span><span class="sxs-lookup"><span data-stu-id="0a143-214">This package contains `KestrelCommunicationListener`, an implementation of `ICommunicationListener`, that allows you toocreate an ASP.NET Core WebHost inside a Reliable Service using Kestrel as hello web server.</span></span>

<span data-ttu-id="0a143-215">Kestrel est un serveur web multiplateforme pour ASP.NET Core basé sur libuv, une bibliothèque d’E/S asynchrone multiplateforme.</span><span class="sxs-lookup"><span data-stu-id="0a143-215">Kestrel is a cross-platform web server for ASP.NET Core based on libuv, a cross-platform asynchronous I/O library.</span></span> <span data-ttu-id="0a143-216">Contrairement à WebListener, Kestrel n’utilise pas de gestionnaire de points de terminaison centralisé comme *http.sys*.</span><span class="sxs-lookup"><span data-stu-id="0a143-216">Unlike WebListener, Kestrel does not use a centralized endpoint manager such as *http.sys*.</span></span> <span data-ttu-id="0a143-217">Et contrairement à WebListener, Kestrel ne prend pas en charge le partage de port entre plusieurs processus.</span><span class="sxs-lookup"><span data-stu-id="0a143-217">And unlike WebListener, Kestrel does not support port sharing between multiple processes.</span></span> <span data-ttu-id="0a143-218">Chaque instance de Kestrel doit utiliser un port unique.</span><span class="sxs-lookup"><span data-stu-id="0a143-218">Each instance of Kestrel must use a unique port.</span></span>

![kestrel][4]

### <a name="kestrel-in-a-stateless-service"></a><span data-ttu-id="0a143-220">Kestrel dans un service sans état</span><span class="sxs-lookup"><span data-stu-id="0a143-220">Kestrel in a stateless service</span></span>
<span data-ttu-id="0a143-221">toouse `Kestrel` dans un service sans état, substituez hello `CreateServiceInstanceListeners` méthode et retournez un `KestrelCommunicationListener` instance :</span><span class="sxs-lookup"><span data-stu-id="0a143-221">toouse `Kestrel` in a stateless service, override hello `CreateServiceInstanceListeners` method and return a `KestrelCommunicationListener` instance:</span></span>

```csharp
protected override IEnumerable<ServiceInstanceListener> CreateServiceInstanceListeners()
{
    return new ServiceInstanceListener[]
    {
        new ServiceInstanceListener(serviceContext =>
            new KestrelCommunicationListener(serviceContext, "ServiceEndpoint", (url, listener) =>
                new WebHostBuilder()
                    .UseKestrel()
                    .ConfigureServices(
                        services => services
                            .AddSingleton<StatelessServiceContext>(serviceContext))
                    .UseContentRoot(Directory.GetCurrentDirectory())
                    .UseServiceFabricIntegration(listener, ServiceFabricIntegrationOptions.UseUniqueServiceUrl)
                    .UseStartup<Startup>()
                    .UseUrls(url)
                    .Build();
            ))
    };
}
```

### <a name="kestrel-in-a-stateful-service"></a><span data-ttu-id="0a143-222">Kestrel dans un service avec état</span><span class="sxs-lookup"><span data-stu-id="0a143-222">Kestrel in a stateful service</span></span>
<span data-ttu-id="0a143-223">toouse `Kestrel` dans un service avec état, substituez hello `CreateServiceReplicaListeners` méthode et retournez un `KestrelCommunicationListener` instance :</span><span class="sxs-lookup"><span data-stu-id="0a143-223">toouse `Kestrel` in a stateful service, override hello `CreateServiceReplicaListeners` method and return a `KestrelCommunicationListener` instance:</span></span>

```csharp
protected override IEnumerable<ServiceReplicaListener> CreateServiceReplicaListeners()
{
    return new ServiceReplicaListener[]
    {
        new ServiceReplicaListener(serviceContext =>
            new KestrelCommunicationListener(serviceContext, (url, listener) =>
                new WebHostBuilder()
                    .UseKestrel()
                    .ConfigureServices(
                         services => services
                             .AddSingleton<StatefulServiceContext>(serviceContext)
                             .AddSingleton<IReliableStateManager>(this.StateManager))
                    .UseContentRoot(Directory.GetCurrentDirectory())
                    .UseServiceFabricIntegration(listener, ServiceFabricIntegrationOptions.UseUniqueServiceUrl)
                    .UseStartup<Startup>()
                    .UseUrls(url)
                    .Build();
            ))
    };
}
```

<span data-ttu-id="0a143-224">Dans cet exemple, une instance de singleton `IReliableStateManager` est fournie de conteneur d’injection de dépendance toohello WebHost.</span><span class="sxs-lookup"><span data-stu-id="0a143-224">In this example, a singleton instance of `IReliableStateManager` is provided toohello WebHost dependency injection container.</span></span> <span data-ttu-id="0a143-225">Cela n’est pas strictement nécessaire, mais il vous permet de toouse `IReliableStateManager` et fiable de Collections dans vos méthodes d’action de contrôleur MVC.</span><span class="sxs-lookup"><span data-stu-id="0a143-225">This is not strictly necessary, but it allows you toouse `IReliableStateManager` and Reliable Collections in your MVC controller action methods.</span></span>

<span data-ttu-id="0a143-226">Notez qu’un `Endpoint` nom de configuration est **pas** fourni trop`KestrelCommunicationListener` dans un service avec état.</span><span class="sxs-lookup"><span data-stu-id="0a143-226">Note that an `Endpoint` configuration name is **not** provided too`KestrelCommunicationListener` in a stateful service.</span></span> <span data-ttu-id="0a143-227">Cela est expliqué en détail dans hello suivant la section.</span><span class="sxs-lookup"><span data-stu-id="0a143-227">This is explained in more detail in hello following section.</span></span>

### <a name="endpoint-configuration"></a><span data-ttu-id="0a143-228">Configuration du point de terminaison</span><span class="sxs-lookup"><span data-stu-id="0a143-228">Endpoint configuration</span></span>
<span data-ttu-id="0a143-229">Un `Endpoint` configuration n’est pas requis toouse Kestrel.</span><span class="sxs-lookup"><span data-stu-id="0a143-229">An `Endpoint` configuration is not required toouse Kestrel.</span></span> 

<span data-ttu-id="0a143-230">Kestrel est un serveur web autonome simple ; Contrairement à WebListener (ou HttpListener), il n’a pas besoin une `Endpoint` configuration dans *ServiceManifest.xml* , car il ne nécessite pas de toostarting préalable de URL d’inscription.</span><span class="sxs-lookup"><span data-stu-id="0a143-230">Kestrel is a simple stand-alone web server; unlike WebListener (or HttpListener), it does not need an `Endpoint` configuration in *ServiceManifest.xml* because it does not require URL registration prior toostarting.</span></span> 

#### <a name="use-kestrel-with-a-static-port"></a><span data-ttu-id="0a143-231">Utiliser Kestrel avec un port statique</span><span class="sxs-lookup"><span data-stu-id="0a143-231">Use Kestrel with a static port</span></span>
<span data-ttu-id="0a143-232">Un port statique peut être configuré dans hello `Endpoint` configuration de ServiceManifest.xml pour une utilisation avec Kestrel.</span><span class="sxs-lookup"><span data-stu-id="0a143-232">A static port can be configured in hello `Endpoint` configuration of ServiceManifest.xml for use with Kestrel.</span></span> <span data-ttu-id="0a143-233">Même si cela n’est pas rigoureusement nécessaire, cela confère deux avantages potentiels :</span><span class="sxs-lookup"><span data-stu-id="0a143-233">Although this is not strictly necessary, it provides two potential benefits:</span></span>
 1. <span data-ttu-id="0a143-234">Si le port de hello n’est pas comprise dans la plage de ports d’application hello, il est ouvert via le pare-feu du système d’exploitation hello par l’infrastructure de Service.</span><span class="sxs-lookup"><span data-stu-id="0a143-234">If hello port does not fall in hello application port range, it is opened through hello OS firewall by Service Fabric.</span></span>
 2. <span data-ttu-id="0a143-235">tooyou URL fournie par le biais de Hello `KestrelCommunicationListener` utilise ce port.</span><span class="sxs-lookup"><span data-stu-id="0a143-235">hello URL provided tooyou through `KestrelCommunicationListener` will use this port.</span></span>

```xml
  <Resources>
    <Endpoints>
      <Endpoint Protocol="http" Name="ServiceEndpoint" Port="80" />
    </Endpoints>
  </Resources>
```

<span data-ttu-id="0a143-236">Si un `Endpoint` est configuré, son nom doit être passé dans hello `KestrelCommunicationListener` constructeur :</span><span class="sxs-lookup"><span data-stu-id="0a143-236">If an `Endpoint` is configured, its name must be passed into hello `KestrelCommunicationListener` constructor:</span></span> 

```csharp
new KestrelCommunicationListener(serviceContext, "ServiceEndpoint", (url, listener) => ...
```

<span data-ttu-id="0a143-237">Si un `Endpoint` configuration n’est pas utilisée, omettez le nom hello Bonjour `KestrelCommunicationListener` constructeur.</span><span class="sxs-lookup"><span data-stu-id="0a143-237">If an `Endpoint` configuration is not used, omit hello name in hello `KestrelCommunicationListener` constructor.</span></span> <span data-ttu-id="0a143-238">Dans ce cas, un port dynamique est utilisé.</span><span class="sxs-lookup"><span data-stu-id="0a143-238">In this case, a dynamic port will be used.</span></span> <span data-ttu-id="0a143-239">Consultez la section suivante de hello pour plus d’informations.</span><span class="sxs-lookup"><span data-stu-id="0a143-239">See hello next section for more information.</span></span>

#### <a name="use-kestrel-with-a-dynamic-port"></a><span data-ttu-id="0a143-240">Utiliser Kestrel avec un port dynamique</span><span class="sxs-lookup"><span data-stu-id="0a143-240">Use Kestrel with a dynamic port</span></span>
<span data-ttu-id="0a143-241">Kestrel ne peut pas utiliser l’attribution automatique du port hello de hello `Endpoint` configuration dans ServiceManifest.xml, car l’attribution automatique du port d’un `Endpoint` configuration affecte un port unique par *processus hôte de* , et un processus hôte unique peut contenir plusieurs instances de Kestrel.</span><span class="sxs-lookup"><span data-stu-id="0a143-241">Kestrel cannot use hello automatic port assignment from hello `Endpoint` configuration in ServiceManifest.xml, because automatic port assignment from an `Endpoint` configuration assigns a unique port per *host process*, and a single host process can contain multiple Kestrel instances.</span></span> <span data-ttu-id="0a143-242">Comme Kestrel ne prend pas en charge le partage de port, cela ne fonctionne pas, car chaque instance de Kestrel doit être ouverte sur un port unique.</span><span class="sxs-lookup"><span data-stu-id="0a143-242">Since Kestrel does not support port sharing, this does not work as each Kestrel instance must be opened on a unique port.</span></span>

<span data-ttu-id="0a143-243">attribution de port dynamique toouse avec Kestrel, omettez simplement hello `Endpoint` configuration dans ServiceManifest.xml et vous ne passez pas un toohello de nom de point de terminaison `KestrelCommunicationListener` constructeur :</span><span class="sxs-lookup"><span data-stu-id="0a143-243">toouse dynamic port assignment with Kestrel, simply omit hello `Endpoint` configuration in ServiceManifest.xml entirely, and do not pass an endpoint name toohello `KestrelCommunicationListener` constructor:</span></span>

```csharp
new KestrelCommunicationListener(serviceContext, (url, listener) => ...
```

<span data-ttu-id="0a143-244">Dans cette configuration, `KestrelCommunicationListener` sélectionne automatiquement un port inutilisé à partir de la plage de ports d’application hello.</span><span class="sxs-lookup"><span data-stu-id="0a143-244">In this configuration, `KestrelCommunicationListener` will automatically select an unused port from hello application port range.</span></span>

## <a name="scenarios-and-configurations"></a><span data-ttu-id="0a143-245">Scénarios et configurations</span><span class="sxs-lookup"><span data-stu-id="0a143-245">Scenarios and configurations</span></span>
<span data-ttu-id="0a143-246">Cette section décrit les scénarios suivants de hello ainsi hello recommandé de combinaison de serveur web, la configuration de port, les options d’intégration de Service Fabric et divers paramètres tooachieve un service fonctionne correctement :</span><span class="sxs-lookup"><span data-stu-id="0a143-246">This section describes hello following scenarios and provides hello recommended combination of web server, port configuration, Service Fabric integration options, and miscellaneous settings tooachieve a properly functioning service:</span></span>
 - <span data-ttu-id="0a143-247">Service sans état d’ASP.NET Core exposé en externe</span><span class="sxs-lookup"><span data-stu-id="0a143-247">Externally exposed ASP.NET Core stateless service</span></span>
 - <span data-ttu-id="0a143-248">Service sans état d’ASP.NET Core interne uniquement</span><span class="sxs-lookup"><span data-stu-id="0a143-248">Internal-only ASP.NET Core stateless service</span></span>
 - <span data-ttu-id="0a143-249">Service avec état d’ASP.NET Core interne uniquement</span><span class="sxs-lookup"><span data-stu-id="0a143-249">Internal-only ASP.NET Core stateful service</span></span>

<span data-ttu-id="0a143-250">Un **exposé en externe** service est une tâche qui expose un point de terminaison accessible à partir de hors cluster hello, généralement par le biais d’un équilibreur de charge.</span><span class="sxs-lookup"><span data-stu-id="0a143-250">An **externally exposed** service is one that exposes an endpoint reachable from outside hello cluster, usually through a load balancer.</span></span>

<span data-ttu-id="0a143-251">Un **interne uniquement** service est un point de terminaison de dont est accessible uniquement à partir d’au sein du cluster de hello.</span><span class="sxs-lookup"><span data-stu-id="0a143-251">An **internal-only** service is one whose endpoint is only reachable from within hello cluster.</span></span>

> [!NOTE]
> <span data-ttu-id="0a143-252">Points de terminaison généralement ne doivent pas être un service avec état exposé toohello Internet.</span><span class="sxs-lookup"><span data-stu-id="0a143-252">Stateful service endpoints generally should not be exposed toohello Internet.</span></span> <span data-ttu-id="0a143-253">Clusters qui se trouvent derrière des équilibreurs de charge qui ne sont pas conscients de résolution de service Service Fabric, par exemple hello équilibrage de charge Azure, seront les services avec état tooexpose impossible, car l’équilibrage de charge hello ne sera pas en mesure de toolocate et acheminer le trafic toohello réplica de service avec état approprié.</span><span class="sxs-lookup"><span data-stu-id="0a143-253">Clusters that are behind load balancers that are unaware of Service Fabric service resolution, such as hello Azure Load Balancer, will be unable tooexpose stateful services because hello load balancer will not be able toolocate and route traffic toohello appropriate stateful service replica.</span></span> 

### <a name="externally-exposed-aspnet-core-stateless-services"></a><span data-ttu-id="0a143-254">Services sans état d’ASP.NET Core exposés en externe</span><span class="sxs-lookup"><span data-stu-id="0a143-254">Externally exposed ASP.NET Core stateless services</span></span>
<span data-ttu-id="0a143-255">WebListener est hello recommandé de serveur web pour les services frontaux qui exposent des points de terminaison externes, connecté à Internet HTTP sur Windows.</span><span class="sxs-lookup"><span data-stu-id="0a143-255">WebListener is hello recommended web server for front-end services that expose external, Internet-facing HTTP endpoints on Windows.</span></span> <span data-ttu-id="0a143-256">Il offre une meilleure protection contre les attaques et prend en charge les fonctionnalités non gérées par Kestrel, par exemple l’authentification Windows et le partage de port.</span><span class="sxs-lookup"><span data-stu-id="0a143-256">It provides better protection against attacks and supports features that Kestrel does not, such as Windows Authentication and port sharing.</span></span> 

<span data-ttu-id="0a143-257">Pour le moment, Kestrel n’est pas pris en charge en tant que serveur Edge (accessible sur Internet).</span><span class="sxs-lookup"><span data-stu-id="0a143-257">Kestrel is not supported as an edge (Internet-facing) server at this time.</span></span> <span data-ttu-id="0a143-258">Un serveur proxy inverse tels que IIS ou Nginx doit être utilisé toohandle trafic hello Internet public.</span><span class="sxs-lookup"><span data-stu-id="0a143-258">A reverse proxy server such as IIS or Nginx must be used toohandle traffic from hello public Internet.</span></span>
 
<span data-ttu-id="0a143-259">Lorsque toohello exposé Internet, un service sans état doit utiliser un point de terminaison connu et stable qui est accessible via un équilibrage de charge.</span><span class="sxs-lookup"><span data-stu-id="0a143-259">When exposed toohello Internet, a stateless service should use a well-known and stable endpoint that is reachable through a load balancer.</span></span> <span data-ttu-id="0a143-260">Il s’agit d’URL de hello vous fournira toousers de votre application.</span><span class="sxs-lookup"><span data-stu-id="0a143-260">This is hello URL you will provide toousers of your application.</span></span> <span data-ttu-id="0a143-261">Hello configuration suivante est recommandée :</span><span class="sxs-lookup"><span data-stu-id="0a143-261">hello following configuration is recommended:</span></span>

|  |  | <span data-ttu-id="0a143-262">**Remarques**</span><span class="sxs-lookup"><span data-stu-id="0a143-262">**Notes**</span></span> |
| --- | --- | --- |
| <span data-ttu-id="0a143-263">Serveur web</span><span class="sxs-lookup"><span data-stu-id="0a143-263">Web server</span></span> | <span data-ttu-id="0a143-264">WebListener</span><span class="sxs-lookup"><span data-stu-id="0a143-264">WebListener</span></span> | <span data-ttu-id="0a143-265">Si le service de hello est uniquement exposé tooa réseau approuvé, un intranet Kestrel peut être utilisé.</span><span class="sxs-lookup"><span data-stu-id="0a143-265">If hello service is only exposed tooa trusted network, such an intranet, Kestrel may be used.</span></span> <span data-ttu-id="0a143-266">Dans le cas contraire, WebListener avère hello préféré.</span><span class="sxs-lookup"><span data-stu-id="0a143-266">Otherwise, WebListener is hello preferred option.</span></span> |
| <span data-ttu-id="0a143-267">Configuration du port</span><span class="sxs-lookup"><span data-stu-id="0a143-267">Port configuration</span></span> | <span data-ttu-id="0a143-268">statique</span><span class="sxs-lookup"><span data-stu-id="0a143-268">static</span></span> | <span data-ttu-id="0a143-269">Un port statique connu doit être configuré dans hello `Endpoints` configuration de ServiceManifest.xml, par exemple 80 pour HTTP et 443 pour HTTPS.</span><span class="sxs-lookup"><span data-stu-id="0a143-269">A well-known static port should be configured in hello `Endpoints` configuration of ServiceManifest.xml, such as 80 for HTTP or 443 for HTTPS.</span></span> |
| <span data-ttu-id="0a143-270">ServiceFabricIntegrationOptions</span><span class="sxs-lookup"><span data-stu-id="0a143-270">ServiceFabricIntegrationOptions</span></span> | <span data-ttu-id="0a143-271">Aucun</span><span class="sxs-lookup"><span data-stu-id="0a143-271">None</span></span> | <span data-ttu-id="0a143-272">Hello `ServiceFabricIntegrationOptions.None` option doit être utilisée lors de la configuration d’intergiciel (middleware) de l’infrastructure de Service intégration afin que le service de hello ne tente pas de toovalidate les demandes entrantes pour un identificateur unique.</span><span class="sxs-lookup"><span data-stu-id="0a143-272">hello `ServiceFabricIntegrationOptions.None` option should be used when configuring Service Fabric integration middleware so that hello service does not attempt toovalidate incoming requests for a unique identifier.</span></span> <span data-ttu-id="0a143-273">Les utilisateurs externes de votre application ne saura pas hello ses informations d’identification utilisées par l’intergiciel (middleware) hello.</span><span class="sxs-lookup"><span data-stu-id="0a143-273">External users of your application will not know hello unique identifying information used by hello middleware.</span></span> |
| <span data-ttu-id="0a143-274">Nombre d'instances</span><span class="sxs-lookup"><span data-stu-id="0a143-274">Instance Count</span></span> | <span data-ttu-id="0a143-275">-1</span><span class="sxs-lookup"><span data-stu-id="0a143-275">-1</span></span> | <span data-ttu-id="0a143-276">En cas d’usage typique, nombre d’instances hello définition doit être défini trop « -1 » afin qu’une instance soit disponible sur tous les nœuds qui reçoivent le trafic à partir d’un équilibreur de charge.</span><span class="sxs-lookup"><span data-stu-id="0a143-276">In typical use cases, hello instance count setting should be set too"-1" so that an instance is available on all nodes that receive traffic from a load balancer.</span></span> |

<span data-ttu-id="0a143-277">Si plusieurs services exposés en externe partagent hello même ensemble de nœuds, un chemin d’accès URL unique mais stable doit être utilisé.</span><span class="sxs-lookup"><span data-stu-id="0a143-277">If multiple externally exposed services share hello same set of nodes, a unique but stable URL path should be used.</span></span> <span data-ttu-id="0a143-278">Cela est possible en modifiant les URL de hello fournie lors de la configuration IWebHost.</span><span class="sxs-lookup"><span data-stu-id="0a143-278">This can be accomplished by modifying hello URL provided when configuring IWebHost.</span></span> <span data-ttu-id="0a143-279">Notez que cela s’applique tooWebListener uniquement.</span><span class="sxs-lookup"><span data-stu-id="0a143-279">Note this applies tooWebListener only.</span></span>

 ```csharp
 new WebListenerCommunicationListener(serviceContext, "ServiceEndpoint", (url, listener) =>
 {
     url += "/MyUniqueServicePath";
 
     return new WebHostBuilder()
         .UseWebListener()
         ...
         .UseUrls(url)
         .Build();
 })
 ```

### <a name="internal-only-stateless-aspnet-core-service"></a><span data-ttu-id="0a143-280">Service d’ASP.NET Core sans état interne uniquement</span><span class="sxs-lookup"><span data-stu-id="0a143-280">Internal-only stateless ASP.NET Core service</span></span>
<span data-ttu-id="0a143-281">Les services sans état qui sont appelées uniquement à partir de cluster de hello doivent utiliser des URL uniques et attribué dynamiquement des ports tooensure une coopération entre plusieurs services.</span><span class="sxs-lookup"><span data-stu-id="0a143-281">Stateless services that are only called from within hello cluster should use unique URLs and dynamically assigned ports tooensure cooperation between multiple services.</span></span> <span data-ttu-id="0a143-282">Hello configuration suivante est recommandée :</span><span class="sxs-lookup"><span data-stu-id="0a143-282">hello following configuration is recommended:</span></span>

|  |  | <span data-ttu-id="0a143-283">**Remarques**</span><span class="sxs-lookup"><span data-stu-id="0a143-283">**Notes**</span></span> |
| --- | --- | --- |
| <span data-ttu-id="0a143-284">Serveur web</span><span class="sxs-lookup"><span data-stu-id="0a143-284">Web server</span></span> | <span data-ttu-id="0a143-285">Kestrel</span><span class="sxs-lookup"><span data-stu-id="0a143-285">Kestrel</span></span> | <span data-ttu-id="0a143-286">Bien que WebListener peut être utilisé pour les services sans état internes, Kestrel est hello recommandé server tooallow tooshare d’instances multiples service un ordinateur hôte.</span><span class="sxs-lookup"><span data-stu-id="0a143-286">Although WebListener may be used for internal stateless services, Kestrel is hello recommended server tooallow multiple service instances tooshare a host.</span></span>  |
| <span data-ttu-id="0a143-287">Configuration du port</span><span class="sxs-lookup"><span data-stu-id="0a143-287">Port configuration</span></span> | <span data-ttu-id="0a143-288">affecté de manière dynamique</span><span class="sxs-lookup"><span data-stu-id="0a143-288">dynamically assigned</span></span> | <span data-ttu-id="0a143-289">Plusieurs réplicas d’un service avec état peuvent partager un processus hôte ou un système d’exploitation hôte, et nécessitent donc des ports uniques.</span><span class="sxs-lookup"><span data-stu-id="0a143-289">Multiple replicas of a stateful service may share a host process or host operating system and thus will need unique ports.</span></span> |
| <span data-ttu-id="0a143-290">ServiceFabricIntegrationOptions</span><span class="sxs-lookup"><span data-stu-id="0a143-290">ServiceFabricIntegrationOptions</span></span> | <span data-ttu-id="0a143-291">UseUniqueServiceUrl</span><span class="sxs-lookup"><span data-stu-id="0a143-291">UseUniqueServiceUrl</span></span> | <span data-ttu-id="0a143-292">Avec l’attribution de port dynamique, ce paramètre empêche le problème de l’identité hello à tort comme décrit précédemment.</span><span class="sxs-lookup"><span data-stu-id="0a143-292">With dynamic port assignment, this setting prevents hello mistaken identity issue described earlier.</span></span> |
| <span data-ttu-id="0a143-293">InstanceCount</span><span class="sxs-lookup"><span data-stu-id="0a143-293">InstanceCount</span></span> | <span data-ttu-id="0a143-294">any</span><span class="sxs-lookup"><span data-stu-id="0a143-294">any</span></span> | <span data-ttu-id="0a143-295">nombre d’instances Hello définition peut être défini service hello de tooany valeur toooperate nécessaire.</span><span class="sxs-lookup"><span data-stu-id="0a143-295">hello instance count setting can be set tooany value necessary toooperate hello service.</span></span> |

### <a name="internal-only-stateful-aspnet-core-service"></a><span data-ttu-id="0a143-296">Service d’ASP.NET Core avec état interne uniquement</span><span class="sxs-lookup"><span data-stu-id="0a143-296">Internal-only stateful ASP.NET Core service</span></span>
<span data-ttu-id="0a143-297">Les services avec état qui sont appelées uniquement à partir de cluster de hello doivent utiliser des ports affectés dynamiquement tooensure une coopération entre plusieurs services.</span><span class="sxs-lookup"><span data-stu-id="0a143-297">Stateful services that are only called from within hello cluster should use dynamically assigned ports tooensure cooperation between multiple services.</span></span> <span data-ttu-id="0a143-298">Hello configuration suivante est recommandée :</span><span class="sxs-lookup"><span data-stu-id="0a143-298">hello following configuration is recommended:</span></span>

|  |  | <span data-ttu-id="0a143-299">**Remarques**</span><span class="sxs-lookup"><span data-stu-id="0a143-299">**Notes**</span></span> |
| --- | --- | --- |
| <span data-ttu-id="0a143-300">Serveur web</span><span class="sxs-lookup"><span data-stu-id="0a143-300">Web server</span></span> | <span data-ttu-id="0a143-301">Kestrel</span><span class="sxs-lookup"><span data-stu-id="0a143-301">Kestrel</span></span> | <span data-ttu-id="0a143-302">Hello `WebListenerCommunicationListener` n’est pas conçu pour une utilisation par les services avec état dans lequel les réplicas partagent un processus hôte.</span><span class="sxs-lookup"><span data-stu-id="0a143-302">hello `WebListenerCommunicationListener` is not designed for use by stateful services in which replicas share a host process.</span></span> |
| <span data-ttu-id="0a143-303">Configuration du port</span><span class="sxs-lookup"><span data-stu-id="0a143-303">Port configuration</span></span> | <span data-ttu-id="0a143-304">affecté de manière dynamique</span><span class="sxs-lookup"><span data-stu-id="0a143-304">dynamically assigned</span></span> | <span data-ttu-id="0a143-305">Plusieurs réplicas d’un service avec état peuvent partager un processus hôte ou un système d’exploitation hôte, et nécessitent donc des ports uniques.</span><span class="sxs-lookup"><span data-stu-id="0a143-305">Multiple replicas of a stateful service may share a host process or host operating system and thus will need unique ports.</span></span> |
| <span data-ttu-id="0a143-306">ServiceFabricIntegrationOptions</span><span class="sxs-lookup"><span data-stu-id="0a143-306">ServiceFabricIntegrationOptions</span></span> | <span data-ttu-id="0a143-307">UseUniqueServiceUrl</span><span class="sxs-lookup"><span data-stu-id="0a143-307">UseUniqueServiceUrl</span></span> | <span data-ttu-id="0a143-308">Avec l’attribution de port dynamique, ce paramètre empêche le problème de l’identité hello à tort comme décrit précédemment.</span><span class="sxs-lookup"><span data-stu-id="0a143-308">With dynamic port assignment, this setting prevents hello mistaken identity issue described earlier.</span></span> |

## <a name="next-steps"></a><span data-ttu-id="0a143-309">Étapes suivantes</span><span class="sxs-lookup"><span data-stu-id="0a143-309">Next steps</span></span>
[<span data-ttu-id="0a143-310">Débogage de votre application Service Fabric à l’aide de Visual Studio</span><span class="sxs-lookup"><span data-stu-id="0a143-310">Debug your Service Fabric application by using Visual Studio</span></span>](service-fabric-debugging-your-application.md)

<!--Image references-->
[0]:./media/service-fabric-reliable-services-communication-aspnetcore/webhost-standalone.png
[1]:./media/service-fabric-reliable-services-communication-aspnetcore/webhost-servicefabric.png
[2]:./media/service-fabric-reliable-services-communication-aspnetcore/integration.png
[3]:./media/service-fabric-reliable-services-communication-aspnetcore/httpsys.png
[4]:./media/service-fabric-reliable-services-communication-aspnetcore/kestrel.png
