---
title: "Communication de service avec ASP.NET Core | Microsoft Docs"
description: "Découvrez comment utiliser ASP.NET Core dans Reliable Services avec et sans état."
services: service-fabric
documentationcenter: .net
author: vturecek
manager: timlt
editor: 
ms.assetid: 8aa4668d-cbb6-4225-bd2d-ab5925a868f2
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: required
ms.date: 05/02/2017
ms.author: vturecek
ms.openlocfilehash: 8ac4d409f7363e8b4ae98be659a627ac8db8d787
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 07/11/2017
---
# <a name="aspnet-core-in-service-fabric-reliable-services"></a><span data-ttu-id="ac71c-103">ASP.NET Core dans le modèle Reliable Services de Service Fabric</span><span class="sxs-lookup"><span data-stu-id="ac71c-103">ASP.NET Core in Service Fabric Reliable Services</span></span>

<span data-ttu-id="ac71c-104">ASP.NET Core est une nouvelle infrastructure open source et multiplateforme destinée à générer des applications modernes connectées à Internet basées sur le cloud, comme des applications web, des applications IoT et des serveurs principaux mobiles.</span><span class="sxs-lookup"><span data-stu-id="ac71c-104">ASP.NET Core is a new open-source and cross-platform framework for building modern cloud-based Internet-connected applications, such as web apps, IoT apps, and mobile backends.</span></span> 

<span data-ttu-id="ac71c-105">Cet article constitue un guide détaillé pour héberger des services ASP.NET Core dans le modèle Reliable Services de Service Fabric à l’aide de l’ensemble **Microsoft.ServiceFabric.AspNetCore.*** de packages NuGet.</span><span class="sxs-lookup"><span data-stu-id="ac71c-105">This article is an in-depth guide to hosting ASP.NET Core services in Service Fabric Reliable Services using the **Microsoft.ServiceFabric.AspNetCore.*** set of NuGet packages.</span></span>

<span data-ttu-id="ac71c-106">Pour un didacticiel de présentation d’ASP.NET Core dans Service Fabric et pour des instructions de configuration de votre environnement de développement, voir [Création d’un serveur web frontal pour votre application à l’aide d’ASP.NET Core](service-fabric-add-a-web-frontend.md).</span><span class="sxs-lookup"><span data-stu-id="ac71c-106">For an introductory tutorial on ASP.NET Core in Service Fabric and instructions on getting your development environment set up, see [Building a web front-end for your application using ASP.NET Core](service-fabric-add-a-web-frontend.md).</span></span>

<span data-ttu-id="ac71c-107">Pour lire la suite de cet article, vous devez déjà maîtriser ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="ac71c-107">The rest of this article assumes you are already familiar with ASP.NET Core.</span></span> <span data-ttu-id="ac71c-108">Si ce n’est pas le cas, nous vous conseillons de lire les [notions de base d’ASP.NET Core](https://docs.microsoft.com/aspnet/core/fundamentals/index).</span><span class="sxs-lookup"><span data-stu-id="ac71c-108">If not, we recommend reading through the [ASP.NET Core fundamentals](https://docs.microsoft.com/aspnet/core/fundamentals/index).</span></span>

## <a name="aspnet-core-in-the-service-fabric-environment"></a><span data-ttu-id="ac71c-109">ASP.NET Core dans l’environnement Service Fabric</span><span class="sxs-lookup"><span data-stu-id="ac71c-109">ASP.NET Core in the Service Fabric environment</span></span>

<span data-ttu-id="ac71c-110">Si les applications ASP.NET Core peuvent s’exécuter sur .NET Core ou sur l’infrastructure .NET Framework complète, pour le moment, les services Service Fabric ne peuvent s’exécuter que sur l’infrastructure .NET Framework complète.</span><span class="sxs-lookup"><span data-stu-id="ac71c-110">While ASP.NET Core apps can run on .NET Core or on the full .NET Framework, Service Fabric services currently can only run on the full .NET Framework.</span></span> <span data-ttu-id="ac71c-111">Cela signifie que lorsque vous générez un service Service Fabric ASP.NET Core, vous devez toujours cibler l’infrastructure .NET Framework complète.</span><span class="sxs-lookup"><span data-stu-id="ac71c-111">This means when you build an ASP.NET  Core Service Fabric service, you must still target the full .NET Framework.</span></span>

<span data-ttu-id="ac71c-112">L’infrastructure ASP.NET Core peut être utilisée de deux manières dans Service Fabric :</span><span class="sxs-lookup"><span data-stu-id="ac71c-112">ASP.NET Core can be used in two different ways in Service Fabric:</span></span>
 - <span data-ttu-id="ac71c-113">**Hébergée en tant qu’exécutable invité**.</span><span class="sxs-lookup"><span data-stu-id="ac71c-113">**Hosted as a guest executable**.</span></span> <span data-ttu-id="ac71c-114">Cette méthode est principalement utilisée pour exécuter des applications ASP.NET Core existantes sur Service Fabric sans modification de code.</span><span class="sxs-lookup"><span data-stu-id="ac71c-114">This is primarily used to run existing ASP.NET Core applications on Service Fabric with no code changes.</span></span>
 - <span data-ttu-id="ac71c-115">**Exécutée dans un service Reliable Service**.</span><span class="sxs-lookup"><span data-stu-id="ac71c-115">**Run inside a Reliable Service**.</span></span> <span data-ttu-id="ac71c-116">Cette méthode permet des services ASP.NET Core avec état ainsi qu’une meilleure intégration au runtime Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="ac71c-116">This allows better integration with the Service Fabric runtime and allows stateful ASP.NET Core services.</span></span>

<span data-ttu-id="ac71c-117">La suite de cet article explique comment utiliser ASP.NET Core dans un service Reliable Service à l’aide des composants d’intégration ASP.NET Core fournis avec le Kit de développement logiciel (SDK) Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="ac71c-117">The rest of this article explains how to use ASP.NET Core inside a Reliable Service using the ASP.NET Core integration components that ship with the Service Fabric SDK.</span></span> 

## <a name="service-fabric-service-hosting"></a><span data-ttu-id="ac71c-118">Hébergement du service Service Fabric</span><span class="sxs-lookup"><span data-stu-id="ac71c-118">Service Fabric service hosting</span></span>

<span data-ttu-id="ac71c-119">Dans Service Fabric, une ou plusieurs instances et/ou un ou plusieurs réplicas de votre service s’exécutent dans un *processus hôte de service*, un fichier exécutable qui exécute le code de votre service.</span><span class="sxs-lookup"><span data-stu-id="ac71c-119">In Service Fabric, one or more instances and/or replicas of your service run in a *service host process*, an executable file that runs your service code.</span></span> <span data-ttu-id="ac71c-120">En tant que créateur du service, vous possédez le processus hôte de service qui est activé et surveillé par Service Fabric à votre place.</span><span class="sxs-lookup"><span data-stu-id="ac71c-120">You, as a service author, own the service host process and Service Fabric activates and monitors it for you.</span></span>

<span data-ttu-id="ac71c-121">Traditionnellement, ASP.NET (jusqu’à MVC 5) est étroitement lié à IIS via System.Web.dll.</span><span class="sxs-lookup"><span data-stu-id="ac71c-121">Traditional ASP.NET (up to MVC 5) is tightly coupled to IIS through System.Web.dll.</span></span> <span data-ttu-id="ac71c-122">ASP.NET Core fournit une séparation entre le serveur web et votre application web.</span><span class="sxs-lookup"><span data-stu-id="ac71c-122">ASP.NET Core provides a separation between the web server and your web application.</span></span> <span data-ttu-id="ac71c-123">Ce faisant, les applications web peuvent être déplacées entre différents serveurs web, et les serveurs web peuvent être *auto-hébergés*, ce qui signifie que vous pouvez démarrer un serveur web dans votre propre processus, par opposition à un processus appartenant à un logiciel serveur web dédié, par exemple IIS.</span><span class="sxs-lookup"><span data-stu-id="ac71c-123">This allows web applications to be portable between different web servers and also allows web servers to be *self-hosted*, which means you can start a web server in your own process, as opposed to a process that is owned by dedicated web server software such as IIS.</span></span> 

<span data-ttu-id="ac71c-124">Pour combiner un service Service Fabric et ASP.NET en tant qu’exécutable invité ou dans un service Reliable Service, vous devez être en mesure de démarrer ASP.NET dans votre processus hôte de service.</span><span class="sxs-lookup"><span data-stu-id="ac71c-124">In order to combine a Service Fabric service and ASP.NET, either as a guest executable or in a Reliable Service, you must be able to start ASP.NET inside your service host process.</span></span> <span data-ttu-id="ac71c-125">L’auto-hébergement d’ASP.NET Core vous le permet.</span><span class="sxs-lookup"><span data-stu-id="ac71c-125">ASP.NET Core self-hosting allows you to do this.</span></span>

## <a name="hosting-aspnet-core-in-a-reliable-service"></a><span data-ttu-id="ac71c-126">Hébergement d’ASP.NET Core dans un service Reliable Service</span><span class="sxs-lookup"><span data-stu-id="ac71c-126">Hosting ASP.NET Core in a Reliable Service</span></span>
<span data-ttu-id="ac71c-127">En règle générale, les applications ASP.NET Core auto-hébergées créent une méthode WebHost dans le point d’entrée d’une application, par exemple la méthode `static void Main()` dans `Program.cs`.</span><span class="sxs-lookup"><span data-stu-id="ac71c-127">Typically, self-hosted ASP.NET Core applications create a WebHost in an application's entry point, such as the `static void Main()` method in `Program.cs`.</span></span> <span data-ttu-id="ac71c-128">Dans ce cas, le cycle de vie de la méthode WebHost est lié au cycle de vie du processus.</span><span class="sxs-lookup"><span data-stu-id="ac71c-128">In this case, the lifecycle of the WebHost is bound to the lifecycle of the process.</span></span>

![Hébergement d’ASP.NET Core dans un processus][0]

<span data-ttu-id="ac71c-130">Néanmoins, le point d’entrée de l’application n’est pas l’emplacement approprié pour créer une méthode WebHost dans un service Reliable Service, car ce point d’entrée est utilisé uniquement pour inscrire un type de service auprès du runtime Service Fabric afin de pouvoir créer des instances de ce type de service.</span><span class="sxs-lookup"><span data-stu-id="ac71c-130">However, the application entry point is not the right place to create a WebHost in a Reliable Service, because the application entry point is only used to register a service type with the Service Fabric runtime, so that it may create instances of that service type.</span></span> <span data-ttu-id="ac71c-131">La méthode WebHost doit être créée dans un service Reliable Service.</span><span class="sxs-lookup"><span data-stu-id="ac71c-131">The WebHost should be created in a Reliable Service itself.</span></span> <span data-ttu-id="ac71c-132">Dans le processus hôte de service, les instances de service et/ou les réplicas peuvent connaître plusieurs cycles de vie.</span><span class="sxs-lookup"><span data-stu-id="ac71c-132">Within the service host process, service instances and/or replicas can go through multiple lifecycles.</span></span> 

<span data-ttu-id="ac71c-133">Une instance du service Reliable Service est représentée par votre classe de service dérivant de `StatelessService` ou `StatefulService`.</span><span class="sxs-lookup"><span data-stu-id="ac71c-133">A Reliable Service instance is represented by your service class deriving from `StatelessService` or `StatefulService`.</span></span> <span data-ttu-id="ac71c-134">La pile de communication d’un service est contenue dans une implémentation `ICommunicationListener` dans votre classe de service.</span><span class="sxs-lookup"><span data-stu-id="ac71c-134">The communication stack for a service is contained in an `ICommunicationListener` implementation in your service class.</span></span> <span data-ttu-id="ac71c-135">Les paquets NuGet `Microsoft.ServiceFabric.Services.AspNetCore.*` contiennent les implémentations de `ICommunicationListener`, qui démarrent et gèrent la méthode WebHost d’ASP.NET Core pour Kestrel ou WebListener dans un service Reliable Service.</span><span class="sxs-lookup"><span data-stu-id="ac71c-135">The `Microsoft.ServiceFabric.Services.AspNetCore.*` NuGet packages contain implementations of `ICommunicationListener` that start and manage the ASP.NET Core WebHost for either Kestrel or WebListener in a Reliable Service.</span></span>

![Hébergement d’ASP.NET Core dans un service Reliable Service][1]

## <a name="aspnet-core-icommunicationlisteners"></a><span data-ttu-id="ac71c-137">Écouteurs ICommunicationListeners d’ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="ac71c-137">ASP.NET Core ICommunicationListeners</span></span>
<span data-ttu-id="ac71c-138">Les modèles d’utilisation des implémentations `ICommunicationListener` pour Kestrel et WebListener dans les paquets NuGet `Microsoft.ServiceFabric.Services.AspNetCore.*` sont similaires, mais ces implémentations effectuent des actions légèrement différentes propres à chaque serveur web.</span><span class="sxs-lookup"><span data-stu-id="ac71c-138">The `ICommunicationListener` implementations for Kestrel and WebListener in the  `Microsoft.ServiceFabric.Services.AspNetCore.*` NuGet packages have similar use patterns but perform slightly different actions specific to each web server.</span></span> 

<span data-ttu-id="ac71c-139">Les deux écouteurs de communications fournissent un constructeur qui accepte les arguments suivants :</span><span class="sxs-lookup"><span data-stu-id="ac71c-139">Both communication listeners provide a constructor that takes the following arguments:</span></span>
 - <span data-ttu-id="ac71c-140">**`ServiceContext serviceContext`** : objet `ServiceContext` qui contient des informations sur le service en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="ac71c-140">**`ServiceContext serviceContext`**: The `ServiceContext` object that contains information about the running service.</span></span>
 - <span data-ttu-id="ac71c-141">**`string endpointName`** : nom d’une configuration `Endpoint` dans le fichier ServiceManifest.xml.</span><span class="sxs-lookup"><span data-stu-id="ac71c-141">**`string endpointName`**: the name of an `Endpoint` configuration in ServiceManifest.xml.</span></span> <span data-ttu-id="ac71c-142">C’est essentiellement là que les deux écouteurs de communications diffèrent : WebListener **requiert** une configuration `Endpoint`, contrairement à Kestrel.</span><span class="sxs-lookup"><span data-stu-id="ac71c-142">This is primarily where the two communication listeners differ: WebListener **requires** an `Endpoint` configuration, while Kestrel does not.</span></span>
 - <span data-ttu-id="ac71c-143">**`Func<string, AspNetCoreCommunicationListener, IWebHost> build`** : expression lambda que vous implémentez dans laquelle vous créez et retournez un `IWebHost`.</span><span class="sxs-lookup"><span data-stu-id="ac71c-143">**`Func<string, AspNetCoreCommunicationListener, IWebHost> build`**: a lambda that you implement in which you create and return an `IWebHost`.</span></span> <span data-ttu-id="ac71c-144">Vous pouvez ainsi configurer `IWebHost` comme vous le feriez normalement dans une application ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="ac71c-144">This allows you to configure `IWebHost` the way you normally would in an ASP.NET Core application.</span></span> <span data-ttu-id="ac71c-145">L’expression lambda fournit une URL, qui est générée pour vous en fonction des options d’intégration de Service Fabric que vous utilisez et de la configuration `Endpoint` que vous fournissez.</span><span class="sxs-lookup"><span data-stu-id="ac71c-145">The lambda provides a URL which is generated for you depending on the Service Fabric integration options you use and the `Endpoint` configuration you provide.</span></span> <span data-ttu-id="ac71c-146">Cette URL peut ensuite être modifiée ou utilisée telle quelle pour démarrer le serveur web.</span><span class="sxs-lookup"><span data-stu-id="ac71c-146">That URL can then be modified or used as-is to start the web server.</span></span>

## <a name="service-fabric-integration-middleware"></a><span data-ttu-id="ac71c-147">Intergiciel (middleware) d’intégration à Service Fabric</span><span class="sxs-lookup"><span data-stu-id="ac71c-147">Service Fabric integration middleware</span></span>
<span data-ttu-id="ac71c-148">Le paquet NuGet `Microsoft.ServiceFabric.Services.AspNetCore` inclut la méthode d’extension `UseServiceFabricIntegration` sur `IWebHostBuilder` qui ajoute l’intergiciel (middleware) prenant en charge Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="ac71c-148">The `Microsoft.ServiceFabric.Services.AspNetCore` NuGet package includes the `UseServiceFabricIntegration` extension method on `IWebHostBuilder` that adds Service Fabric-aware middleware.</span></span> <span data-ttu-id="ac71c-149">Cet intergiciel (middleware) configure l’élément Kestrel ou WebListener `ICommunicationListener` pour inscrire une URL de service unique auprès de Service Fabric Naming Service, puis valide les demandes des clients pour s’assurer qu’ils se connectent au service approprié.</span><span class="sxs-lookup"><span data-stu-id="ac71c-149">This middleware configures the Kestrel or WebListener `ICommunicationListener` to register a unique service URL with the Service Fabric Naming Service and then validates client requests to ensure clients are connecting to the right service.</span></span> <span data-ttu-id="ac71c-150">Cela est nécessaire dans un environnement hôte partagé comme Service Fabric, où plusieurs applications web peuvent s’exécuter sur une même machine physique ou virtuelle, mais n’utilisent pas de noms d’hôte uniques, pour empêcher les clients de se connecter par erreur à un service incorrect.</span><span class="sxs-lookup"><span data-stu-id="ac71c-150">This is necessary in a shared-host environment such as Service Fabric, where multiple web applications can run on the same physical or virtual machine but do not use unique host names, to prevent clients from mistakenly connecting to the wrong service.</span></span> <span data-ttu-id="ac71c-151">Ce scénario est décrit plus en détail dans la section suivante.</span><span class="sxs-lookup"><span data-stu-id="ac71c-151">This scenario is described in more detail in the next section.</span></span>

### <a name="a-case-of-mistaken-identity"></a><span data-ttu-id="ac71c-152">Cas d’erreur d’identité</span><span class="sxs-lookup"><span data-stu-id="ac71c-152">A case of mistaken identity</span></span>
<span data-ttu-id="ac71c-153">Quel que soit le protocole utilisé, les réplicas de service écoutent sur une combinaison IP:port unique.</span><span class="sxs-lookup"><span data-stu-id="ac71c-153">Service replicas, regardless of protocol, listen on a unique IP:port combination.</span></span> <span data-ttu-id="ac71c-154">Lorsqu’un réplica de service a commencé à écouter sur un point de terminaison IP:port, il indique l’adresse de ce point de terminaison à Service Fabric Naming Service où elle peut être détectée par des clients ou d’autres services.</span><span class="sxs-lookup"><span data-stu-id="ac71c-154">Once a service replica has started listening on an IP:port endpoint, it reports that endpoint address to the Service Fabric Naming Service where it can be discovered by clients or other services.</span></span> <span data-ttu-id="ac71c-155">Si des services utilisent des ports d’application affectés de manière dynamique, un réplica de service peut utiliser par hasard le même point de terminaison IP:port d’un autre service qui existait précédemment sur la même machine physique ou virtuelle.</span><span class="sxs-lookup"><span data-stu-id="ac71c-155">If services use dynamically-assigned application ports, a service replica may coincidentally use the same IP:port endpoint of another service that was previously on the same physical or virtual machine.</span></span> <span data-ttu-id="ac71c-156">Cela peut provoquer la connexion d’un client par erreur à un service incorrect.</span><span class="sxs-lookup"><span data-stu-id="ac71c-156">This can cause a client to mistakely connect to the wrong service.</span></span> <span data-ttu-id="ac71c-157">Cela peut se produire si la séquence d’événements suivante se produit :</span><span class="sxs-lookup"><span data-stu-id="ac71c-157">This can happen if the following sequence of events occur:</span></span>

 1. <span data-ttu-id="ac71c-158">Le service A écoute sur 10.0.0.1:30000 via HTTP.</span><span class="sxs-lookup"><span data-stu-id="ac71c-158">Service A listens on 10.0.0.1:30000 over HTTP.</span></span> 
 2. <span data-ttu-id="ac71c-159">Le client résout le service A et obtient l’adresse 10.0.0.1:30000.</span><span class="sxs-lookup"><span data-stu-id="ac71c-159">Client resolves Service A and gets address 10.0.0.1:30000</span></span>
 3. <span data-ttu-id="ac71c-160">Le service A passe à un autre nœud.</span><span class="sxs-lookup"><span data-stu-id="ac71c-160">Service A moves to a different node.</span></span>
 4. <span data-ttu-id="ac71c-161">Le service B est placé sur 10.0.0.1 et utilise par hasard le même port 30000.</span><span class="sxs-lookup"><span data-stu-id="ac71c-161">Service B is placed on 10.0.0.1 and coincidentally uses the same port 30000.</span></span>
 5. <span data-ttu-id="ac71c-162">Le client essaie de se connecter au service A avec l’adresse mise en cache 10.0.0.1:30000.</span><span class="sxs-lookup"><span data-stu-id="ac71c-162">Client attempts to connect to service A with cached address 10.0.0.1:30000.</span></span>
 6. <span data-ttu-id="ac71c-163">Le client est maintenant connecté au service B, sans détecter qu’il est connecté à un service incorrect.</span><span class="sxs-lookup"><span data-stu-id="ac71c-163">Client is now successfully connected to service B not realizing it is connected to the wrong service.</span></span>

<span data-ttu-id="ac71c-164">Cela peut provoquer des bogues de façon aléatoire qui peuvent être difficiles à diagnostiquer.</span><span class="sxs-lookup"><span data-stu-id="ac71c-164">This can cause bugs at random times that can be difficult to diagnose.</span></span> 

### <a name="using-unique-service-urls"></a><span data-ttu-id="ac71c-165">Utilisation d’URL de service uniques</span><span class="sxs-lookup"><span data-stu-id="ac71c-165">Using unique service URLs</span></span>
<span data-ttu-id="ac71c-166">Pour éviter ce problème, les services peuvent publier un point de terminaison dans Naming Service avec un identificateur unique, puis valider cet identificateur lors des demandes des clients.</span><span class="sxs-lookup"><span data-stu-id="ac71c-166">To prevent this, services can post an endpoint to the Naming Service with a unique identifier, and then validate that unique identifier during client requests.</span></span> <span data-ttu-id="ac71c-167">Il s’agit d’une action de coopération entre les services dans un environnement approuvé de client non hostile.</span><span class="sxs-lookup"><span data-stu-id="ac71c-167">This is a cooperative action between services in a non-hostile-tenant trusted environment.</span></span> <span data-ttu-id="ac71c-168">Cette action ne permet pas d’authentification de service sécurisée dans un environnement de client hostile.</span><span class="sxs-lookup"><span data-stu-id="ac71c-168">This does not provide secure service authentication in a hostile-tenant environment.</span></span>

<span data-ttu-id="ac71c-169">Dans un environnement approuvé, l’intergiciel (middleware) qui est ajouté par la méthode `UseServiceFabricIntegration` ajoute automatiquement un identificateur unique à l’adresse qui est publiée dans Naming Service et valide cet identificateur à chaque demande.</span><span class="sxs-lookup"><span data-stu-id="ac71c-169">In a trusted environment, the middleware that's added by the `UseServiceFabricIntegration` method automatically appends a unique identifier to the address that is posted to the Naming Service and validates that identifier on each request.</span></span> <span data-ttu-id="ac71c-170">Si l’identificateur ne correspond pas, l’intergiciel (middleware) retourne immédiatement une réponse HTTP 410 Supprimé.</span><span class="sxs-lookup"><span data-stu-id="ac71c-170">If the identifier does not match, the middleware immediately returns an HTTP 410 Gone response.</span></span>

<span data-ttu-id="ac71c-171">Les services qui utilisent un port attribué dynamiquement doivent avoir recours à cet intergiciel (middleware).</span><span class="sxs-lookup"><span data-stu-id="ac71c-171">Services that use a dynamically-assigned port should make use of this middleware.</span></span>

<span data-ttu-id="ac71c-172">Les services qui utilisent un port unique fixe ne connaissent pas ce problème dans un environnement coopératif.</span><span class="sxs-lookup"><span data-stu-id="ac71c-172">Services that use a fixed unique port do not have this problem in a cooperative environment.</span></span> <span data-ttu-id="ac71c-173">Un port de ce type est généralement utilisé pour les services externes qui nécessitent un port connu pour que les applications clientes s’y connectent.</span><span class="sxs-lookup"><span data-stu-id="ac71c-173">A fixed unique port is typically used for externally-facing services that need a well-known port for client applications to connect to.</span></span> <span data-ttu-id="ac71c-174">Par exemple, la plupart des applications web accessibles sur Internet utilisent les ports 80 ou 443 pour les connexions de navigateur web.</span><span class="sxs-lookup"><span data-stu-id="ac71c-174">For example, most Internet-facing web applications will use port 80 or 443 for web browser connections.</span></span> <span data-ttu-id="ac71c-175">Dans ce cas, l’identificateur unique ne doit pas être activé.</span><span class="sxs-lookup"><span data-stu-id="ac71c-175">In this case, the unique identifier should not be enabled.</span></span>

<span data-ttu-id="ac71c-176">Le diagramme suivant illustre le flux de demande avec l’intergiciel (middleware) activé :</span><span class="sxs-lookup"><span data-stu-id="ac71c-176">The following diagram shows the request flow with the middleware enabled:</span></span>

![Intégration d’ASP.NET Core à Service Fabric][2]

<span data-ttu-id="ac71c-178">Les implémentations `ICommunicationListener` de Kestrel et WebListener utilisent ce mécanisme de la même façon.</span><span class="sxs-lookup"><span data-stu-id="ac71c-178">Both Kestrel and WebListener `ICommunicationListener` implementations use this mechanism in exactly the same way.</span></span> <span data-ttu-id="ac71c-179">Même si WebListener peut différencier en interne les demandes basées sur les chemins d’accès d’URL uniques à l’aide de la fonctionnalité de partage de port *http.sys* sous-jacente, cette fonctionnalité n’est *pas* utilisée par l’implémentation `ICommunicationListener` de WebListener, car cela entraîne les codes d’état d’erreur HTTP 503 et HTTP 404 dans le scénario décrit précédemment.</span><span class="sxs-lookup"><span data-stu-id="ac71c-179">Although WebListener can internally differentiate requests based on unique URL paths using the underlying *http.sys* port sharing feature, that functionality is *not* used by the WebListener `ICommunicationListener` implementation because that will result in HTTP 503 and HTTP 404 error status codes in the scenario described earlier.</span></span> <span data-ttu-id="ac71c-180">Il est alors très difficile pour les clients de déterminer l’objet de l’erreur, car les codes HTTP 503 et HTTP 404 sont couramment utilisés pour indiquer d’autres erreurs.</span><span class="sxs-lookup"><span data-stu-id="ac71c-180">That in turn makes it very difficult for clients to determine the intent of the error, as HTTP 503 and HTTP 404 are already commonly used to indicate other errors.</span></span> <span data-ttu-id="ac71c-181">Par conséquent, les implémentations `ICommunicationListener` de Kestrel et WebListener sont normalisées dans l’intergiciel (middleware) fourni par la méthode d’extension `UseServiceFabricIntegration` afin que les clients n’aient à effectuer qu’une action de nouvelle résolution de point de terminaison de service sur les réponses HTTP 410.</span><span class="sxs-lookup"><span data-stu-id="ac71c-181">Thus, both Kestrel and WebListener `ICommunicationListener` implementations standardize on the middleware provided by the `UseServiceFabricIntegration` extension method so that clients only need to perform a service endpoint re-resolve action on HTTP 410 responses.</span></span>

## <a name="weblistener-in-reliable-services"></a><span data-ttu-id="ac71c-182">WebListener dans Reliable Services</span><span class="sxs-lookup"><span data-stu-id="ac71c-182">WebListener in Reliable Services</span></span>
<span data-ttu-id="ac71c-183">WebListener peut être utilisé dans un service Reliable Service en important le paquet NuGet **Microsoft.ServiceFabric.AspNetCore.WebListener**.</span><span class="sxs-lookup"><span data-stu-id="ac71c-183">WebListener can be used in a Reliable Service by importing the **Microsoft.ServiceFabric.AspNetCore.WebListener** NuGet package.</span></span> <span data-ttu-id="ac71c-184">Ce paquet contient `WebListenerCommunicationListener`, une implémentation de `ICommunicationListener`, qui vous permet de créer une méthode WebHost d’ASP.NET Core dans un service Reliable Service utilisant WebListener en tant que serveur web.</span><span class="sxs-lookup"><span data-stu-id="ac71c-184">This package contains `WebListenerCommunicationListener`, an implementation of `ICommunicationListener`, that allows you to create an ASP.NET Core WebHost inside a Reliable Service using WebListener as the web server.</span></span>

<span data-ttu-id="ac71c-185">WebListener est basé sur [l’API du serveur HTTP Windows](https://msdn.microsoft.com/library/windows/desktop/aa364510(v=vs.85).aspx).</span><span class="sxs-lookup"><span data-stu-id="ac71c-185">WebListener is built on the [Windows HTTP Server API](https://msdn.microsoft.com/library/windows/desktop/aa364510(v=vs.85).aspx).</span></span> <span data-ttu-id="ac71c-186">Elle utilise le pilote du noyau *http.sys* utilisé par IIS pour traiter les requêtes HTTP et les acheminer vers les processus exécutant les applications web.</span><span class="sxs-lookup"><span data-stu-id="ac71c-186">This uses the *http.sys* kernel driver used by IIS to process HTTP requests and route them to processes running web applications.</span></span> <span data-ttu-id="ac71c-187">De cette façon, plusieurs processus d’une même machine physique ou virtuelle peuvent héberger des applications web sur un même port, dont l’ambiguïté est levée par un chemin d’accès d’URL ou un nom d’hôte unique.</span><span class="sxs-lookup"><span data-stu-id="ac71c-187">This allows multiple processes on the same physical or virtual machine to host web applications on the same port, disambiguated by either a unique URL path or hostname.</span></span> <span data-ttu-id="ac71c-188">Ces fonctionnalités sont utiles dans Service Fabric pour héberger plusieurs sites web dans un même cluster.</span><span class="sxs-lookup"><span data-stu-id="ac71c-188">These features are useful in Service Fabric for hosting multiple websites in the same cluster.</span></span>

<span data-ttu-id="ac71c-189">Le diagramme suivant illustre l’utilisation du pilote de noyau *http.sys* par WebListener sur Windows pour le partage de port :</span><span class="sxs-lookup"><span data-stu-id="ac71c-189">The following diagram illustrates how WebListener uses the *http.sys* kernel driver on Windows for port sharing:</span></span>

![http.sys][3]

### <a name="weblistener-in-a-stateless-service"></a><span data-ttu-id="ac71c-191">WebListener dans un service sans état</span><span class="sxs-lookup"><span data-stu-id="ac71c-191">WebListener in a stateless service</span></span>
<span data-ttu-id="ac71c-192">Pour utiliser `WebListener` dans un service sans état, remplacez la méthode `CreateServiceInstanceListeners` et retournez une instance `WebListenerCommunicationListener` :</span><span class="sxs-lookup"><span data-stu-id="ac71c-192">To use `WebListener` in a stateless service, override the `CreateServiceInstanceListeners` method and return a `WebListenerCommunicationListener` instance:</span></span>

```csharp
protected override IEnumerable<ServiceInstanceListener> CreateServiceInstanceListeners()
{
    return new ServiceInstanceListener[]
    {
        new ServiceInstanceListener(serviceContext =>
            new WebListenerCommunicationListener(serviceContext, "ServiceEndpoint", (url, listener) =>
                new WebHostBuilder()
                    .UseWebListener()
                    .ConfigureServices(
                        services => services
                            .AddSingleton<StatelessServiceContext>(serviceContext))
                    .UseContentRoot(Directory.GetCurrentDirectory())
                    .UseServiceFabricIntegration(listener, ServiceFabricIntegrationOptions.None)
                    .UseStartup<Startup>()
                    .UseUrls(url)
                    .Build()))
    };
}
```

### <a name="weblistener-in-a-stateful-service"></a><span data-ttu-id="ac71c-193">WebListener dans un service avec état</span><span class="sxs-lookup"><span data-stu-id="ac71c-193">WebListener in a stateful service</span></span>

<span data-ttu-id="ac71c-194">Pour le moment, `WebListenerCommunicationListener` n’est pas conçu pour être utilisé dans des services avec état en raison de complications liées à la fonctionnalité de partage de port *http.sys* sous-jacente.</span><span class="sxs-lookup"><span data-stu-id="ac71c-194">`WebListenerCommunicationListener` is currently not designed for use in stateful services due to complications with the underlying *http.sys* port sharing feature.</span></span> <span data-ttu-id="ac71c-195">Pour plus d’informations, consultez la section suivante sur l’allocation de port dynamique avec WebListener.</span><span class="sxs-lookup"><span data-stu-id="ac71c-195">For more information, see the following section on dynamic port allocation with WebListener.</span></span> <span data-ttu-id="ac71c-196">Pour les services avec état, il est recommandé d’utiliser Kestrel comme serveur web.</span><span class="sxs-lookup"><span data-stu-id="ac71c-196">For stateful services, Kestrel is the recommended web server.</span></span>

### <a name="endpoint-configuration"></a><span data-ttu-id="ac71c-197">Configuration du point de terminaison</span><span class="sxs-lookup"><span data-stu-id="ac71c-197">Endpoint configuration</span></span>

<span data-ttu-id="ac71c-198">Une configuration `Endpoint` est requise pour les serveurs web qui utilisent l’API du serveur HTTP Windows, y compris WebListener.</span><span class="sxs-lookup"><span data-stu-id="ac71c-198">An `Endpoint` configuration is required for web servers that use the Windows HTTP Server API, including WebListener.</span></span> <span data-ttu-id="ac71c-199">Les serveurs web qui utilisent cette API doivent d’abord réserver leur URL avec *http.sys* (cela s’effectue normalement avec l’outil [netsh](https://msdn.microsoft.com/library/windows/desktop/cc307236(v=vs.85).aspx)).</span><span class="sxs-lookup"><span data-stu-id="ac71c-199">Web servers that use the Windows HTTP Server API must first reserve their URL with *http.sys* (this is normally accomplished with the [netsh](https://msdn.microsoft.com/library/windows/desktop/cc307236(v=vs.85).aspx) tool).</span></span> <span data-ttu-id="ac71c-200">Cette action requiert des privilèges élevés dont vos services sont dépourvus par défaut.</span><span class="sxs-lookup"><span data-stu-id="ac71c-200">This action requires elevated privileges that your services by default do not have.</span></span> <span data-ttu-id="ac71c-201">Les options « http » ou « https » de la propriété `Protocol` de la configuration `Endpoint` dans le fichier *ServiceManifest.xml* sont utilisées plus particulièrement pour indiquer au runtime Service Fabric d’inscrire une URL avec *http.sys* pour votre compte en utilisant le préfixe d’URL à [*caractère générique fort*](https://msdn.microsoft.com/library/windows/desktop/aa364698(v=vs.85).aspx).</span><span class="sxs-lookup"><span data-stu-id="ac71c-201">The "http" or "https" options for the `Protocol` property of the `Endpoint` configuration in *ServiceManifest.xml* are used specifically to instruct the Service Fabric runtime to register a URL with *http.sys* on your behalf using the [*strong wildcard*](https://msdn.microsoft.com/library/windows/desktop/aa364698(v=vs.85).aspx) URL prefix.</span></span>

<span data-ttu-id="ac71c-202">Par exemple, pour réserver `http://+:80` pour un service, il convient d’utiliser la configuration suivante dans le fichier ServiceManifest.xml :</span><span class="sxs-lookup"><span data-stu-id="ac71c-202">For example, to reserve `http://+:80` for a service, the following configuration should be used in ServiceManifest.xml:</span></span>

```xml
<ServiceManifest ... >
    ...
    <Resources>
        <Endpoints>
            <Endpoint Name="ServiceEndpoint" Protocol="http" Port="80" />
        </Endpoints>
    </Resources>

</ServiceManifest>
```

<span data-ttu-id="ac71c-203">Par ailleurs, le nom du point de terminaison doit être transmis au constructeur `WebListenerCommunicationListener` :</span><span class="sxs-lookup"><span data-stu-id="ac71c-203">And the endpoint name must be passed to the `WebListenerCommunicationListener` constructor:</span></span>

```csharp
 new WebListenerCommunicationListener(serviceContext, "ServiceEndpoint", (url, listener) =>
 {
     return new WebHostBuilder()
         .UseWebListener()
         .UseServiceFabricIntegration(listener, ServiceFabricIntegrationOptions.None)
         .UseUrls(url)
         .Build();
 })
```

#### <a name="use-weblistener-with-a-static-port"></a><span data-ttu-id="ac71c-204">Utiliser WebListener avec un port statique</span><span class="sxs-lookup"><span data-stu-id="ac71c-204">Use WebListener with a static port</span></span>
<span data-ttu-id="ac71c-205">Pour utiliser un port statique avec WebListener, indiquez le numéro de port dans la configuration `Endpoint` :</span><span class="sxs-lookup"><span data-stu-id="ac71c-205">To use a static port with WebListener, provide the port number in the `Endpoint` configuration:</span></span>

```xml
  <Resources>
    <Endpoints>
      <Endpoint Protocol="http" Name="ServiceEndpoint" Port="80" />
    </Endpoints>
  </Resources>
```

#### <a name="use-weblistener-with-a-dynamic-port"></a><span data-ttu-id="ac71c-206">Utiliser WebListener avec un port dynamique</span><span class="sxs-lookup"><span data-stu-id="ac71c-206">Use WebListener with a dynamic port</span></span>
<span data-ttu-id="ac71c-207">Pour utiliser un port affecté dynamiquement avec WebListener, omettez la propriété `Port` dans la configuration `Endpoint` :</span><span class="sxs-lookup"><span data-stu-id="ac71c-207">To use a dynamically assigned port with WebListener, omit the `Port` property in the `Endpoint` configuration:</span></span>

```xml
  <Resources>
    <Endpoints>
      <Endpoint Protocol="http" Name="ServiceEndpoint" />
    </Endpoints>
  </Resources>
```

<span data-ttu-id="ac71c-208">Notez qu’un port dynamique alloué par une configuration `Endpoint` fournit un seul port *par processus hôte*.</span><span class="sxs-lookup"><span data-stu-id="ac71c-208">Note that a dynamic port allocated by an `Endpoint` configuration only provides one port *per host process*.</span></span> <span data-ttu-id="ac71c-209">Le modèle d’hébergement Service Fabric actuel permet à plusieurs instances de service et/ou réplicas d’être hébergés dans le même processus, ce qui signifie que chacun d’entre eux partagera le même port s’il est alloué via la configuration `Endpoint`.</span><span class="sxs-lookup"><span data-stu-id="ac71c-209">The current Service Fabric hosting model allows multiple service instances and/or replicas to be hosted in the same process, meaning that each one will share the same port when allocated through the `Endpoint` configuration.</span></span> <span data-ttu-id="ac71c-210">Plusieurs instances de WebListener peuvent partager un même port à l’aide de la fonctionnalité de partage de port *http.sys* sous-jacente, mais celle-ci n’est pas prise en charge par `WebListenerCommunicationListener` en raison des complications qu’elle induit pour les demandes des clients.</span><span class="sxs-lookup"><span data-stu-id="ac71c-210">Multiple WebListener instances can share a port using the underlying *http.sys* port sharing feature, but that is not supported by `WebListenerCommunicationListener` due to the complications it introduces for client requests.</span></span> <span data-ttu-id="ac71c-211">Pour une utilisation de port dynamique, il est recommandé d’utiliser Kestrel comme serveur web.</span><span class="sxs-lookup"><span data-stu-id="ac71c-211">For dynamic port usage, Kestrel is the recommended web server.</span></span>

## <a name="kestrel-in-reliable-services"></a><span data-ttu-id="ac71c-212">Kestrel dans Reliable Services</span><span class="sxs-lookup"><span data-stu-id="ac71c-212">Kestrel in Reliable Services</span></span>
<span data-ttu-id="ac71c-213">Kestrel peut être utilisé dans un service Reliable Service en important le paquet NuGet **Microsoft.ServiceFabric.AspNetCore.Kestrel**.</span><span class="sxs-lookup"><span data-stu-id="ac71c-213">Kestrel can be used in a Reliable Service by importing the **Microsoft.ServiceFabric.AspNetCore.Kestrel** NuGet package.</span></span> <span data-ttu-id="ac71c-214">Ce paquet contient `KestrelCommunicationListener`, une implémentation de `ICommunicationListener`, qui vous permet de créer une méthode WebHost d’ASP.NET Core dans un service Reliable Service utilisant Kestrel en tant que serveur web.</span><span class="sxs-lookup"><span data-stu-id="ac71c-214">This package contains `KestrelCommunicationListener`, an implementation of `ICommunicationListener`, that allows you to create an ASP.NET Core WebHost inside a Reliable Service using Kestrel as the web server.</span></span>

<span data-ttu-id="ac71c-215">Kestrel est un serveur web multiplateforme pour ASP.NET Core basé sur libuv, une bibliothèque d’E/S asynchrone multiplateforme.</span><span class="sxs-lookup"><span data-stu-id="ac71c-215">Kestrel is a cross-platform web server for ASP.NET Core based on libuv, a cross-platform asynchronous I/O library.</span></span> <span data-ttu-id="ac71c-216">Contrairement à WebListener, Kestrel n’utilise pas de gestionnaire de points de terminaison centralisé comme *http.sys*.</span><span class="sxs-lookup"><span data-stu-id="ac71c-216">Unlike WebListener, Kestrel does not use a centralized endpoint manager such as *http.sys*.</span></span> <span data-ttu-id="ac71c-217">Et contrairement à WebListener, Kestrel ne prend pas en charge le partage de port entre plusieurs processus.</span><span class="sxs-lookup"><span data-stu-id="ac71c-217">And unlike WebListener, Kestrel does not support port sharing between multiple processes.</span></span> <span data-ttu-id="ac71c-218">Chaque instance de Kestrel doit utiliser un port unique.</span><span class="sxs-lookup"><span data-stu-id="ac71c-218">Each instance of Kestrel must use a unique port.</span></span>

![kestrel][4]

### <a name="kestrel-in-a-stateless-service"></a><span data-ttu-id="ac71c-220">Kestrel dans un service sans état</span><span class="sxs-lookup"><span data-stu-id="ac71c-220">Kestrel in a stateless service</span></span>
<span data-ttu-id="ac71c-221">Pour utiliser `Kestrel` dans un service sans état, remplacez la méthode `CreateServiceInstanceListeners` et retournez une instance `KestrelCommunicationListener` :</span><span class="sxs-lookup"><span data-stu-id="ac71c-221">To use `Kestrel` in a stateless service, override the `CreateServiceInstanceListeners` method and return a `KestrelCommunicationListener` instance:</span></span>

```csharp
protected override IEnumerable<ServiceInstanceListener> CreateServiceInstanceListeners()
{
    return new ServiceInstanceListener[]
    {
        new ServiceInstanceListener(serviceContext =>
            new KestrelCommunicationListener(serviceContext, "ServiceEndpoint", (url, listener) =>
                new WebHostBuilder()
                    .UseKestrel()
                    .ConfigureServices(
                        services => services
                            .AddSingleton<StatelessServiceContext>(serviceContext))
                    .UseContentRoot(Directory.GetCurrentDirectory())
                    .UseServiceFabricIntegration(listener, ServiceFabricIntegrationOptions.UseUniqueServiceUrl)
                    .UseStartup<Startup>()
                    .UseUrls(url)
                    .Build();
            ))
    };
}
```

### <a name="kestrel-in-a-stateful-service"></a><span data-ttu-id="ac71c-222">Kestrel dans un service avec état</span><span class="sxs-lookup"><span data-stu-id="ac71c-222">Kestrel in a stateful service</span></span>
<span data-ttu-id="ac71c-223">Pour utiliser `Kestrel` dans un service avec état, remplacez la méthode `CreateServiceReplicaListeners` et retournez une instance `KestrelCommunicationListener` :</span><span class="sxs-lookup"><span data-stu-id="ac71c-223">To use `Kestrel` in a stateful service, override the `CreateServiceReplicaListeners` method and return a `KestrelCommunicationListener` instance:</span></span>

```csharp
protected override IEnumerable<ServiceReplicaListener> CreateServiceReplicaListeners()
{
    return new ServiceReplicaListener[]
    {
        new ServiceReplicaListener(serviceContext =>
            new KestrelCommunicationListener(serviceContext, (url, listener) =>
                new WebHostBuilder()
                    .UseKestrel()
                    .ConfigureServices(
                         services => services
                             .AddSingleton<StatefulServiceContext>(serviceContext)
                             .AddSingleton<IReliableStateManager>(this.StateManager))
                    .UseContentRoot(Directory.GetCurrentDirectory())
                    .UseServiceFabricIntegration(listener, ServiceFabricIntegrationOptions.UseUniqueServiceUrl)
                    .UseStartup<Startup>()
                    .UseUrls(url)
                    .Build();
            ))
    };
}
```

<span data-ttu-id="ac71c-224">Dans cet exemple, une instance singleton de `IReliableStateManager` est fournie au conteneur d’injection de dépendance WebHost.</span><span class="sxs-lookup"><span data-stu-id="ac71c-224">In this example, a singleton instance of `IReliableStateManager` is provided to the WebHost dependency injection container.</span></span> <span data-ttu-id="ac71c-225">Cela n’est pas rigoureusement nécessaire, mais elle vous permet d’utiliser `IReliableStateManager` et Reliable Collections dans vos méthodes d’action de contrôleur MVC.</span><span class="sxs-lookup"><span data-stu-id="ac71c-225">This is not strictly necessary, but it allows you to use `IReliableStateManager` and Reliable Collections in your MVC controller action methods.</span></span>

<span data-ttu-id="ac71c-226">Notez qu’aucun nom de configuration `Endpoint` **n’est** fourni à `KestrelCommunicationListener` dans un service avec état.</span><span class="sxs-lookup"><span data-stu-id="ac71c-226">Note that an `Endpoint` configuration name is **not** provided to `KestrelCommunicationListener` in a stateful service.</span></span> <span data-ttu-id="ac71c-227">La section suivante contient une explication plus détaillée à ce sujet.</span><span class="sxs-lookup"><span data-stu-id="ac71c-227">This is explained in more detail in the following section.</span></span>

### <a name="endpoint-configuration"></a><span data-ttu-id="ac71c-228">Configuration du point de terminaison</span><span class="sxs-lookup"><span data-stu-id="ac71c-228">Endpoint configuration</span></span>
<span data-ttu-id="ac71c-229">Aucune configuration `Endpoint` n’est requise pour utiliser Kestrel.</span><span class="sxs-lookup"><span data-stu-id="ac71c-229">An `Endpoint` configuration is not required to use Kestrel.</span></span> 

<span data-ttu-id="ac71c-230">Kestrel est un serveur web autonome simple. Contrairement à WebListener (ou HttpListener), il ne nécessite pas de configuration `Endpoint` dans le fichier *ServiceManifest.xml*, car il ne requiert pas d’inscription d’URL avant le démarrage.</span><span class="sxs-lookup"><span data-stu-id="ac71c-230">Kestrel is a simple stand-alone web server; unlike WebListener (or HttpListener), it does not need an `Endpoint` configuration in *ServiceManifest.xml* because it does not require URL registration prior to starting.</span></span> 

#### <a name="use-kestrel-with-a-static-port"></a><span data-ttu-id="ac71c-231">Utiliser Kestrel avec un port statique</span><span class="sxs-lookup"><span data-stu-id="ac71c-231">Use Kestrel with a static port</span></span>
<span data-ttu-id="ac71c-232">Un port statique peut être défini dans la configuration `Endpoint` du fichier ServiceManifest.xml pour une utilisation avec Kestrel.</span><span class="sxs-lookup"><span data-stu-id="ac71c-232">A static port can be configured in the `Endpoint` configuration of ServiceManifest.xml for use with Kestrel.</span></span> <span data-ttu-id="ac71c-233">Même si cela n’est pas rigoureusement nécessaire, cela confère deux avantages potentiels :</span><span class="sxs-lookup"><span data-stu-id="ac71c-233">Although this is not strictly necessary, it provides two potential benefits:</span></span>
 1. <span data-ttu-id="ac71c-234">Si le port n’est pas compris dans la plage de ports d’application, il est ouvert via le pare-feu du système d’exploitation par Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="ac71c-234">If the port does not fall in the application port range, it is opened through the OS firewall by Service Fabric.</span></span>
 2. <span data-ttu-id="ac71c-235">L’URL qui vous est fournie via `KestrelCommunicationListener` utilise ce port.</span><span class="sxs-lookup"><span data-stu-id="ac71c-235">The URL provided to you through `KestrelCommunicationListener` will use this port.</span></span>

```xml
  <Resources>
    <Endpoints>
      <Endpoint Protocol="http" Name="ServiceEndpoint" Port="80" />
    </Endpoints>
  </Resources>
```

<span data-ttu-id="ac71c-236">Si un `Endpoint` est configuré, son nom doit être transmis au constructeur `KestrelCommunicationListener` :</span><span class="sxs-lookup"><span data-stu-id="ac71c-236">If an `Endpoint` is configured, its name must be passed into the `KestrelCommunicationListener` constructor:</span></span> 

```csharp
new KestrelCommunicationListener(serviceContext, "ServiceEndpoint", (url, listener) => ...
```

<span data-ttu-id="ac71c-237">Si aucune configuration `Endpoint` n’est utilisée, omettez le nom dans le constructeur `KestrelCommunicationListener`.</span><span class="sxs-lookup"><span data-stu-id="ac71c-237">If an `Endpoint` configuration is not used, omit the name in the `KestrelCommunicationListener` constructor.</span></span> <span data-ttu-id="ac71c-238">Dans ce cas, un port dynamique est utilisé.</span><span class="sxs-lookup"><span data-stu-id="ac71c-238">In this case, a dynamic port will be used.</span></span> <span data-ttu-id="ac71c-239">Pour en savoir plus, consultez la section suivante.</span><span class="sxs-lookup"><span data-stu-id="ac71c-239">See the next section for more information.</span></span>

#### <a name="use-kestrel-with-a-dynamic-port"></a><span data-ttu-id="ac71c-240">Utiliser Kestrel avec un port dynamique</span><span class="sxs-lookup"><span data-stu-id="ac71c-240">Use Kestrel with a dynamic port</span></span>
<span data-ttu-id="ac71c-241">Kestrel ne peut pas utiliser l’affectation de port automatique de la configuration `Endpoint` indiquée dans le fichier ServiceManifest.xml, car l’affectation de port automatique d’une configuration `Endpoint` affecte un port unique par *processus hôte*, et un processus hôte unique peut contenir plusieurs instances de Kestrel.</span><span class="sxs-lookup"><span data-stu-id="ac71c-241">Kestrel cannot use the automatic port assignment from the `Endpoint` configuration in ServiceManifest.xml, because automatic port assignment from an `Endpoint` configuration assigns a unique port per *host process*, and a single host process can contain multiple Kestrel instances.</span></span> <span data-ttu-id="ac71c-242">Comme Kestrel ne prend pas en charge le partage de port, cela ne fonctionne pas, car chaque instance de Kestrel doit être ouverte sur un port unique.</span><span class="sxs-lookup"><span data-stu-id="ac71c-242">Since Kestrel does not support port sharing, this does not work as each Kestrel instance must be opened on a unique port.</span></span>

<span data-ttu-id="ac71c-243">Pour utiliser l’affectation de port dynamique avec Kestrel, omettez simplement entièrement la configuration `Endpoint` indiquée dans le fichier ServiceManifest.xml, et ne transmettez pas le nom d’un point de terminaison au constructeur `KestrelCommunicationListener` :</span><span class="sxs-lookup"><span data-stu-id="ac71c-243">To use dynamic port assignment with Kestrel, simply omit the `Endpoint` configuration in ServiceManifest.xml entirely, and do not pass an endpoint name to the `KestrelCommunicationListener` constructor:</span></span>

```csharp
new KestrelCommunicationListener(serviceContext, (url, listener) => ...
```

<span data-ttu-id="ac71c-244">Dans cette configuration, `KestrelCommunicationListener` sélectionne automatiquement un port inutilisé dans la plage de ports d’application.</span><span class="sxs-lookup"><span data-stu-id="ac71c-244">In this configuration, `KestrelCommunicationListener` will automatically select an unused port from the application port range.</span></span>

## <a name="scenarios-and-configurations"></a><span data-ttu-id="ac71c-245">Scénarios et configurations</span><span class="sxs-lookup"><span data-stu-id="ac71c-245">Scenarios and configurations</span></span>
<span data-ttu-id="ac71c-246">Cette section décrit les scénarios suivants, et fournit la combinaison recommandée de serveur web, configuration de port, options d’intégration de Service Fabric et divers paramètres pour obtenir un service fonctionnant correctement :</span><span class="sxs-lookup"><span data-stu-id="ac71c-246">This section describes the following scenarios and provides the recommended combination of web server, port configuration, Service Fabric integration options, and miscellaneous settings to achieve a properly functioning service:</span></span>
 - <span data-ttu-id="ac71c-247">Service sans état d’ASP.NET Core exposé en externe</span><span class="sxs-lookup"><span data-stu-id="ac71c-247">Externally exposed ASP.NET Core stateless service</span></span>
 - <span data-ttu-id="ac71c-248">Service sans état d’ASP.NET Core interne uniquement</span><span class="sxs-lookup"><span data-stu-id="ac71c-248">Internal-only ASP.NET Core stateless service</span></span>
 - <span data-ttu-id="ac71c-249">Service avec état d’ASP.NET Core interne uniquement</span><span class="sxs-lookup"><span data-stu-id="ac71c-249">Internal-only ASP.NET Core stateful service</span></span>

<span data-ttu-id="ac71c-250">Un service **exposé en externe** expose un point de terminaison accessible depuis l’extérieur du cluster, généralement par le biais d’un équilibreur de charge.</span><span class="sxs-lookup"><span data-stu-id="ac71c-250">An **externally exposed** service is one that exposes an endpoint reachable from outside the cluster, usually through a load balancer.</span></span>

<span data-ttu-id="ac71c-251">Un service **interne uniquement** possède un point de terminaison qui est uniquement accessible à partir de l’intérieur du cluster.</span><span class="sxs-lookup"><span data-stu-id="ac71c-251">An **internal-only** service is one whose endpoint is only reachable from within the cluster.</span></span>

> [!NOTE]
> <span data-ttu-id="ac71c-252">En règle générale, les points de terminaison de service avec état ne doivent pas être exposés à Internet.</span><span class="sxs-lookup"><span data-stu-id="ac71c-252">Stateful service endpoints generally should not be exposed to the Internet.</span></span> <span data-ttu-id="ac71c-253">Les clusters qui se trouvent derrière des équilibreurs de charge qui ne prennent pas en charge la résolution de service Service Fabric, par exemple Azure Load Balancer, ne peuvent pas exposer des services avec état, car l’équilibreur de charge n’est pas en mesure de localiser ni d’acheminer le trafic vers le réplica de service avec état approprié.</span><span class="sxs-lookup"><span data-stu-id="ac71c-253">Clusters that are behind load balancers that are unaware of Service Fabric service resolution, such as the Azure Load Balancer, will be unable to expose stateful services because the load balancer will not be able to locate and route traffic to the appropriate stateful service replica.</span></span> 

### <a name="externally-exposed-aspnet-core-stateless-services"></a><span data-ttu-id="ac71c-254">Services sans état d’ASP.NET Core exposés en externe</span><span class="sxs-lookup"><span data-stu-id="ac71c-254">Externally exposed ASP.NET Core stateless services</span></span>
<span data-ttu-id="ac71c-255">WebListener est le serveur web recommandé pour les services frontaux qui exposent des points de terminaison HTTP accessibles sur Internet, externes sur Windows.</span><span class="sxs-lookup"><span data-stu-id="ac71c-255">WebListener is the recommended web server for front-end services that expose external, Internet-facing HTTP endpoints on Windows.</span></span> <span data-ttu-id="ac71c-256">Il offre une meilleure protection contre les attaques et prend en charge les fonctionnalités non gérées par Kestrel, par exemple l’authentification Windows et le partage de port.</span><span class="sxs-lookup"><span data-stu-id="ac71c-256">It provides better protection against attacks and supports features that Kestrel does not, such as Windows Authentication and port sharing.</span></span> 

<span data-ttu-id="ac71c-257">Pour le moment, Kestrel n’est pas pris en charge en tant que serveur Edge (accessible sur Internet).</span><span class="sxs-lookup"><span data-stu-id="ac71c-257">Kestrel is not supported as an edge (Internet-facing) server at this time.</span></span> <span data-ttu-id="ac71c-258">Un serveur proxy inverse tel que IIS ou Nginx doit être utilisé pour gérer le trafic à partir de l’Internet public.</span><span class="sxs-lookup"><span data-stu-id="ac71c-258">A reverse proxy server such as IIS or Nginx must be used to handle traffic from the public Internet.</span></span>
 
<span data-ttu-id="ac71c-259">Lorsqu’il est exposé à Internet, un service sans état doit utiliser un point de terminaison connu et stable accessible via un équilibreur de charge.</span><span class="sxs-lookup"><span data-stu-id="ac71c-259">When exposed to the Internet, a stateless service should use a well-known and stable endpoint that is reachable through a load balancer.</span></span> <span data-ttu-id="ac71c-260">Il s’agit de l’URL que vous fournissez aux utilisateurs de votre application.</span><span class="sxs-lookup"><span data-stu-id="ac71c-260">This is the URL you will provide to users of your application.</span></span> <span data-ttu-id="ac71c-261">La configuration suivante est recommandée :</span><span class="sxs-lookup"><span data-stu-id="ac71c-261">The following configuration is recommended:</span></span>

|  |  | <span data-ttu-id="ac71c-262">**Remarques**</span><span class="sxs-lookup"><span data-stu-id="ac71c-262">**Notes**</span></span> |
| --- | --- | --- |
| <span data-ttu-id="ac71c-263">Serveur web</span><span class="sxs-lookup"><span data-stu-id="ac71c-263">Web server</span></span> | <span data-ttu-id="ac71c-264">WebListener</span><span class="sxs-lookup"><span data-stu-id="ac71c-264">WebListener</span></span> | <span data-ttu-id="ac71c-265">Si le service est exposé uniquement à un réseau approuvé, par exemple un intranet, Kestrel peut être utilisé.</span><span class="sxs-lookup"><span data-stu-id="ac71c-265">If the service is only exposed to a trusted network, such an intranet, Kestrel may be used.</span></span> <span data-ttu-id="ac71c-266">Dans le cas contraire, WebListener est l’option recommandée.</span><span class="sxs-lookup"><span data-stu-id="ac71c-266">Otherwise, WebListener is the preferred option.</span></span> |
| <span data-ttu-id="ac71c-267">Configuration du port</span><span class="sxs-lookup"><span data-stu-id="ac71c-267">Port configuration</span></span> | <span data-ttu-id="ac71c-268">statique</span><span class="sxs-lookup"><span data-stu-id="ac71c-268">static</span></span> | <span data-ttu-id="ac71c-269">Un port statique connu doit être défini dans la configuration `Endpoints` du fichier ServiceManifest.xml, par exemple 80 pour HTTP et 443 pour HTTPS.</span><span class="sxs-lookup"><span data-stu-id="ac71c-269">A well-known static port should be configured in the `Endpoints` configuration of ServiceManifest.xml, such as 80 for HTTP or 443 for HTTPS.</span></span> |
| <span data-ttu-id="ac71c-270">ServiceFabricIntegrationOptions</span><span class="sxs-lookup"><span data-stu-id="ac71c-270">ServiceFabricIntegrationOptions</span></span> | <span data-ttu-id="ac71c-271">Aucun</span><span class="sxs-lookup"><span data-stu-id="ac71c-271">None</span></span> | <span data-ttu-id="ac71c-272">Il convient d’utiliser l’option `ServiceFabricIntegrationOptions.None` lors de la configuration de l’intergiciel (middleware) d’intégration à Service Fabric afin que le service n’essaie pas de valider les demandes entrantes pour un identificateur unique.</span><span class="sxs-lookup"><span data-stu-id="ac71c-272">The `ServiceFabricIntegrationOptions.None` option should be used when configuring Service Fabric integration middleware so that the service does not attempt to validate incoming requests for a unique identifier.</span></span> <span data-ttu-id="ac71c-273">Les utilisateurs externes de votre application ne connaissent pas les informations d’identification uniques utilisées par l’intergiciel (middleware).</span><span class="sxs-lookup"><span data-stu-id="ac71c-273">External users of your application will not know the unique identifying information used by the middleware.</span></span> |
| <span data-ttu-id="ac71c-274">Nombre d'instances</span><span class="sxs-lookup"><span data-stu-id="ac71c-274">Instance Count</span></span> | <span data-ttu-id="ac71c-275">-1</span><span class="sxs-lookup"><span data-stu-id="ac71c-275">-1</span></span> | <span data-ttu-id="ac71c-276">Dans les cas d’utilisation standard, le paramètre du nombre d’instances doit être défini sur « -1 » afin qu’une instance soit disponible sur tous les nœuds recevant le trafic à partir d’un équilibreur de charge.</span><span class="sxs-lookup"><span data-stu-id="ac71c-276">In typical use cases, the instance count setting should be set to "-1" so that an instance is available on all nodes that receive traffic from a load balancer.</span></span> |

<span data-ttu-id="ac71c-277">Si plusieurs services exposés en externe partagent le même ensemble de nœuds, vous devez utiliser un chemin d’accès d’URL unique, mais stable.</span><span class="sxs-lookup"><span data-stu-id="ac71c-277">If multiple externally exposed services share the same set of nodes, a unique but stable URL path should be used.</span></span> <span data-ttu-id="ac71c-278">Cela peut être accompli en modifiant l’URL fournie lors de la configuration d’IWebHost.</span><span class="sxs-lookup"><span data-stu-id="ac71c-278">This can be accomplished by modifying the URL provided when configuring IWebHost.</span></span> <span data-ttu-id="ac71c-279">Notez que cela s’applique uniquement à WebListener.</span><span class="sxs-lookup"><span data-stu-id="ac71c-279">Note this applies to WebListener only.</span></span>

 ```csharp
 new WebListenerCommunicationListener(serviceContext, "ServiceEndpoint", (url, listener) =>
 {
     url += "/MyUniqueServicePath";
 
     return new WebHostBuilder()
         .UseWebListener()
         ...
         .UseUrls(url)
         .Build();
 })
 ```

### <a name="internal-only-stateless-aspnet-core-service"></a><span data-ttu-id="ac71c-280">Service d’ASP.NET Core sans état interne uniquement</span><span class="sxs-lookup"><span data-stu-id="ac71c-280">Internal-only stateless ASP.NET Core service</span></span>
<span data-ttu-id="ac71c-281">Les services sans état qui sont appelés uniquement à partir du cluster doivent utiliser des URL uniques et des ports affectés dynamiquement afin d’assurer une coopération entre plusieurs services.</span><span class="sxs-lookup"><span data-stu-id="ac71c-281">Stateless services that are only called from within the cluster should use unique URLs and dynamically assigned ports to ensure cooperation between multiple services.</span></span> <span data-ttu-id="ac71c-282">La configuration suivante est recommandée :</span><span class="sxs-lookup"><span data-stu-id="ac71c-282">The following configuration is recommended:</span></span>

|  |  | <span data-ttu-id="ac71c-283">**Remarques**</span><span class="sxs-lookup"><span data-stu-id="ac71c-283">**Notes**</span></span> |
| --- | --- | --- |
| <span data-ttu-id="ac71c-284">Serveur web</span><span class="sxs-lookup"><span data-stu-id="ac71c-284">Web server</span></span> | <span data-ttu-id="ac71c-285">Kestrel</span><span class="sxs-lookup"><span data-stu-id="ac71c-285">Kestrel</span></span> | <span data-ttu-id="ac71c-286">Bien que WebListener puisse être utilisé pour les services sans état internes, Kestrel est le serveur recommandé pour permettre à plusieurs instances de service de partager un hôte.</span><span class="sxs-lookup"><span data-stu-id="ac71c-286">Although WebListener may be used for internal stateless services, Kestrel is the recommended server to allow multiple service instances to share a host.</span></span>  |
| <span data-ttu-id="ac71c-287">Configuration du port</span><span class="sxs-lookup"><span data-stu-id="ac71c-287">Port configuration</span></span> | <span data-ttu-id="ac71c-288">affecté de manière dynamique</span><span class="sxs-lookup"><span data-stu-id="ac71c-288">dynamically assigned</span></span> | <span data-ttu-id="ac71c-289">Plusieurs réplicas d’un service avec état peuvent partager un processus hôte ou un système d’exploitation hôte, et nécessitent donc des ports uniques.</span><span class="sxs-lookup"><span data-stu-id="ac71c-289">Multiple replicas of a stateful service may share a host process or host operating system and thus will need unique ports.</span></span> |
| <span data-ttu-id="ac71c-290">ServiceFabricIntegrationOptions</span><span class="sxs-lookup"><span data-stu-id="ac71c-290">ServiceFabricIntegrationOptions</span></span> | <span data-ttu-id="ac71c-291">UseUniqueServiceUrl</span><span class="sxs-lookup"><span data-stu-id="ac71c-291">UseUniqueServiceUrl</span></span> | <span data-ttu-id="ac71c-292">Avec l’affectation de port dynamique, ce paramètre empêche le problème d’erreur d’identité décrit précédemment.</span><span class="sxs-lookup"><span data-stu-id="ac71c-292">With dynamic port assignment, this setting prevents the mistaken identity issue described earlier.</span></span> |
| <span data-ttu-id="ac71c-293">InstanceCount</span><span class="sxs-lookup"><span data-stu-id="ac71c-293">InstanceCount</span></span> | <span data-ttu-id="ac71c-294">any</span><span class="sxs-lookup"><span data-stu-id="ac71c-294">any</span></span> | <span data-ttu-id="ac71c-295">Le paramètre du nombre d’instances peut être défini sur toute valeur nécessaire au bon fonctionnement du service.</span><span class="sxs-lookup"><span data-stu-id="ac71c-295">The instance count setting can be set to any value necessary to operate the service.</span></span> |

### <a name="internal-only-stateful-aspnet-core-service"></a><span data-ttu-id="ac71c-296">Service d’ASP.NET Core avec état interne uniquement</span><span class="sxs-lookup"><span data-stu-id="ac71c-296">Internal-only stateful ASP.NET Core service</span></span>
<span data-ttu-id="ac71c-297">Les services avec état qui sont appelés uniquement à partir du cluster doivent utiliser des ports affectés dynamiquement afin d’assurer une coopération entre plusieurs services.</span><span class="sxs-lookup"><span data-stu-id="ac71c-297">Stateful services that are only called from within the cluster should use dynamically assigned ports to ensure cooperation between multiple services.</span></span> <span data-ttu-id="ac71c-298">La configuration suivante est recommandée :</span><span class="sxs-lookup"><span data-stu-id="ac71c-298">The following configuration is recommended:</span></span>

|  |  | <span data-ttu-id="ac71c-299">**Remarques**</span><span class="sxs-lookup"><span data-stu-id="ac71c-299">**Notes**</span></span> |
| --- | --- | --- |
| <span data-ttu-id="ac71c-300">Serveur web</span><span class="sxs-lookup"><span data-stu-id="ac71c-300">Web server</span></span> | <span data-ttu-id="ac71c-301">Kestrel</span><span class="sxs-lookup"><span data-stu-id="ac71c-301">Kestrel</span></span> | <span data-ttu-id="ac71c-302">Le `WebListenerCommunicationListener` n’est pas conçu pour être utilisé par les services avec état dans lesquels les réplicas partagent un processus hôte.</span><span class="sxs-lookup"><span data-stu-id="ac71c-302">The `WebListenerCommunicationListener` is not designed for use by stateful services in which replicas share a host process.</span></span> |
| <span data-ttu-id="ac71c-303">Configuration du port</span><span class="sxs-lookup"><span data-stu-id="ac71c-303">Port configuration</span></span> | <span data-ttu-id="ac71c-304">affecté de manière dynamique</span><span class="sxs-lookup"><span data-stu-id="ac71c-304">dynamically assigned</span></span> | <span data-ttu-id="ac71c-305">Plusieurs réplicas d’un service avec état peuvent partager un processus hôte ou un système d’exploitation hôte, et nécessitent donc des ports uniques.</span><span class="sxs-lookup"><span data-stu-id="ac71c-305">Multiple replicas of a stateful service may share a host process or host operating system and thus will need unique ports.</span></span> |
| <span data-ttu-id="ac71c-306">ServiceFabricIntegrationOptions</span><span class="sxs-lookup"><span data-stu-id="ac71c-306">ServiceFabricIntegrationOptions</span></span> | <span data-ttu-id="ac71c-307">UseUniqueServiceUrl</span><span class="sxs-lookup"><span data-stu-id="ac71c-307">UseUniqueServiceUrl</span></span> | <span data-ttu-id="ac71c-308">Avec l’affectation de port dynamique, ce paramètre empêche le problème d’erreur d’identité décrit précédemment.</span><span class="sxs-lookup"><span data-stu-id="ac71c-308">With dynamic port assignment, this setting prevents the mistaken identity issue described earlier.</span></span> |

## <a name="next-steps"></a><span data-ttu-id="ac71c-309">Étapes suivantes</span><span class="sxs-lookup"><span data-stu-id="ac71c-309">Next steps</span></span>
[<span data-ttu-id="ac71c-310">Débogage de votre application Service Fabric à l’aide de Visual Studio</span><span class="sxs-lookup"><span data-stu-id="ac71c-310">Debug your Service Fabric application by using Visual Studio</span></span>](service-fabric-debugging-your-application.md)

<!--Image references-->
[0]:./media/service-fabric-reliable-services-communication-aspnetcore/webhost-standalone.png
[1]:./media/service-fabric-reliable-services-communication-aspnetcore/webhost-servicefabric.png
[2]:./media/service-fabric-reliable-services-communication-aspnetcore/integration.png
[3]:./media/service-fabric-reliable-services-communication-aspnetcore/httpsys.png
[4]:./media/service-fabric-reliable-services-communication-aspnetcore/kestrel.png
