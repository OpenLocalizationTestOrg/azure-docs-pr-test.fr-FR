---
title: "Vue d’ensemble du cycle de vie de Reliable Services dans Azure Service Fabric | Microsoft Docs"
description: "En savoir plus sur les différents événements de cycle de vie de Reliable Services dans Service Fabric"
services: Service-Fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: vturecek;
ms.assetid: 
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 08/18/2017
ms.author: masnider
ms.openlocfilehash: 16021ca72a2f10070b6409417ff0d88009591331
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/18/2017
---
# <a name="reliable-services-lifecycle-overview"></a><span data-ttu-id="c7f2f-103">Vue d’ensemble du cycle de vie de Reliable Services</span><span class="sxs-lookup"><span data-stu-id="c7f2f-103">Reliable services lifecycle overview</span></span>
> [!div class="op_single_selector"]
> * [<span data-ttu-id="c7f2f-104">C# sur Windows</span><span class="sxs-lookup"><span data-stu-id="c7f2f-104">C# on Windows</span></span>](service-fabric-reliable-services-lifecycle.md)
> * [<span data-ttu-id="c7f2f-105">Java sur Linux</span><span class="sxs-lookup"><span data-stu-id="c7f2f-105">Java on Linux</span></span>](service-fabric-reliable-services-lifecycle-java.md)
>
>

<span data-ttu-id="c7f2f-106">Lorsque l’on songe aux cycles de vie de Reliable Services, les principes de base du cycle de vie sont les plus importants.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-106">When thinking about the lifecycles of Reliable Services, the basics of the lifecycle are the most important.</span></span> <span data-ttu-id="c7f2f-107">En général :</span><span class="sxs-lookup"><span data-stu-id="c7f2f-107">In general:</span></span>

- <span data-ttu-id="c7f2f-108">Lors du démarrage</span><span class="sxs-lookup"><span data-stu-id="c7f2f-108">During Startup</span></span>
  - <span data-ttu-id="c7f2f-109">Les services sont construits</span><span class="sxs-lookup"><span data-stu-id="c7f2f-109">Services are constructed</span></span>
  - <span data-ttu-id="c7f2f-110">Ils ont l’opportunité de se construire et de renvoyer zéro ou plusieurs écouteurs</span><span class="sxs-lookup"><span data-stu-id="c7f2f-110">They have an opportunity to construct and return zero or more listeners</span></span>
  - <span data-ttu-id="c7f2f-111">Les écouteurs retournés sont ouverts, ce qui permet la communication avec le service</span><span class="sxs-lookup"><span data-stu-id="c7f2f-111">Any returned listeners are opened, allowing communication with the service</span></span>
  - <span data-ttu-id="c7f2f-112">La méthode RunAsync du service est appelée, ce qui permet au service d’exécuter des tâches de longue durée ou d’arrière-plan</span><span class="sxs-lookup"><span data-stu-id="c7f2f-112">The Service's RunAsync method is called, allowing the service to do long running or background work</span></span>
- <span data-ttu-id="c7f2f-113">Lors de l’arrêt</span><span class="sxs-lookup"><span data-stu-id="c7f2f-113">During shutdown</span></span>
  - <span data-ttu-id="c7f2f-114">Le jeton d’annulation passé à RunAsync est annulé et les écouteurs sont fermés</span><span class="sxs-lookup"><span data-stu-id="c7f2f-114">The cancellation token passed to RunAsync is canceled, and the listeners are closed</span></span>
  - <span data-ttu-id="c7f2f-115">Une fois cette opération terminée, l’objet de service lui-même est détruit</span><span class="sxs-lookup"><span data-stu-id="c7f2f-115">Once that is complete, the service object itself is destructed</span></span>

<span data-ttu-id="c7f2f-116">Il existe plus d’informations sur l’ordre exact de ces événements.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-116">There are details around the exact ordering of these events.</span></span> <span data-ttu-id="c7f2f-117">En particulier, l’ordre des événements peut varier légèrement selon que le Reliable Service est un service sans état ou avec état.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-117">In particular, the order of events may change slightly depending on whether the Reliable Service is Stateless or Stateful.</span></span> <span data-ttu-id="c7f2f-118">En outre, pour les services avec état, nous devons gérer le scénario d’échange principal.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-118">In addition, for stateful services, we have to deal with the Primary swap scenario.</span></span> <span data-ttu-id="c7f2f-119">Au cours de cette séquence, le rôle principal est transféré vers un autre réplica (ou revient) sans que le service ne s’arrête.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-119">During this sequence, the role of Primary is transferred to another replica (or comes back) without the service shutting down.</span></span> <span data-ttu-id="c7f2f-120">Enfin, nous devons penser aux conditions d’erreur ou d’échec.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-120">Finally, we have to think about error or failure conditions.</span></span>

## <a name="stateless-service-startup"></a><span data-ttu-id="c7f2f-121">Démarrage de service sans état</span><span class="sxs-lookup"><span data-stu-id="c7f2f-121">Stateless service startup</span></span>
<span data-ttu-id="c7f2f-122">Le cycle de vie d’un service sans état est assez simple.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-122">The lifecycle of a stateless service is fairly straightforward.</span></span> <span data-ttu-id="c7f2f-123">Voici l’ordre des événements :</span><span class="sxs-lookup"><span data-stu-id="c7f2f-123">Here's the order of events:</span></span>

1. <span data-ttu-id="c7f2f-124">Le service est construit</span><span class="sxs-lookup"><span data-stu-id="c7f2f-124">The Service is constructed</span></span>
2. <span data-ttu-id="c7f2f-125">Ensuite, deux choses se produisent en parallèle :</span><span class="sxs-lookup"><span data-stu-id="c7f2f-125">Then, in parallel two things happen:</span></span>
    - <span data-ttu-id="c7f2f-126">`StatelessService.CreateServiceInstanceListeners()` est appelé et les écouteurs retournés sont ouverts.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-126">`StatelessService.CreateServiceInstanceListeners()` is invoked and any returned listeners are Opened.</span></span> <span data-ttu-id="c7f2f-127">`ICommunicationListener.OpenAsync()` est appelé sur chaque écouteur.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-127">`ICommunicationListener.OpenAsync()` is called on each listener</span></span>
    - <span data-ttu-id="c7f2f-128">La méthode `StatelessService.RunAsync()` du service est appelée.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-128">The service's `StatelessService.RunAsync()` method is called</span></span>
3. <span data-ttu-id="c7f2f-129">Si elle est présente, la méthode `StatelessService.OnOpenAsync()` du service est appelée.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-129">If present, the service's `StatelessService.OnOpenAsync()` method is called.</span></span> <span data-ttu-id="c7f2f-130">Il s’agit d’un remplacement rare, mais possible.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-130">This is an uncommon override, but it is available.</span></span>

<span data-ttu-id="c7f2f-131">Il est important de noter qu’il n’existe pas d’ordre particulier entre les appels pour créer et ouvrir les écouteurs et RunAsync.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-131">It is important to note that there is no ordering between the calls to create and open the listeners and RunAsync.</span></span> <span data-ttu-id="c7f2f-132">Les écouteurs peuvent s’ouvrir avant que la méthode RunAsync ne soit démarrée.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-132">The listeners may open before RunAsync is started.</span></span> <span data-ttu-id="c7f2f-133">De même, la méthode RunAsync peut être appelée avant que les écouteurs de communication ne soient ouverts ou même construits.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-133">Similarly, RunAsync may end up invoked before the communication listeners are open or have even been constructed.</span></span> <span data-ttu-id="c7f2f-134">Si une synchronisation est nécessaire, elle est considérée comme un exercice à exécuter par le responsable d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-134">If any synchronization is required, it is left as an exercise to the implementer.</span></span> <span data-ttu-id="c7f2f-135">Solutions courantes :</span><span class="sxs-lookup"><span data-stu-id="c7f2f-135">Common solutions:</span></span>

  - <span data-ttu-id="c7f2f-136">Parfois, les écouteurs ne peuvent pas fonctionner avant que d’autres informations ne soient créées ou un travail effectué.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-136">Sometimes listeners can't function until some other information is created or work done.</span></span> <span data-ttu-id="c7f2f-137">Pour les services sans état qui sont actifs, cela peut se faire dans d’autres emplacements, tels que les suivants :</span><span class="sxs-lookup"><span data-stu-id="c7f2f-137">For stateless services that work can usually be done in other locations, such as:</span></span> 
    - <span data-ttu-id="c7f2f-138">Dans le constructeur du service</span><span class="sxs-lookup"><span data-stu-id="c7f2f-138">in the service's constructor</span></span>
    - <span data-ttu-id="c7f2f-139">Pendant l’appel de `CreateServiceInstanceListeners()`</span><span class="sxs-lookup"><span data-stu-id="c7f2f-139">during the `CreateServiceInstanceListeners()` call</span></span>
    - <span data-ttu-id="c7f2f-140">Dans le cadre de la construction de l’écouteur</span><span class="sxs-lookup"><span data-stu-id="c7f2f-140">as a part of the construction of the listener itself</span></span>
  - <span data-ttu-id="c7f2f-141">Parfois, le code dans RunAsync ne souhaite pas démarrer tant que les écouteurs ne sont pas ouverts.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-141">Sometimes the code in RunAsync does not want to start until the listeners are open.</span></span> <span data-ttu-id="c7f2f-142">Dans ce cas, une coordination supplémentaire est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-142">In this case additional coordination is necessary.</span></span> <span data-ttu-id="c7f2f-143">L’une des solutions couramment employées consiste à utiliser un indicateur pour signaler à quel moment se terminent les écouteurs.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-143">One common solution is some flag within the listeners indicating when they have completed.</span></span> <span data-ttu-id="c7f2f-144">Cet indicateur est alors vérifié dans RunAsync avant de poursuivre son travail.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-144">This flag is then checked in RunAsync before continuing to actual work.</span></span>

## <a name="stateless-service-shutdown"></a><span data-ttu-id="c7f2f-145">Arrêt de service sans état</span><span class="sxs-lookup"><span data-stu-id="c7f2f-145">Stateless service shutdown</span></span>
<span data-ttu-id="c7f2f-146">Lorsque vous arrêtez un service sans état, le même modèle est suivi dans l’ordre inverse :</span><span class="sxs-lookup"><span data-stu-id="c7f2f-146">When shutting down a stateless service, the same pattern is followed, just in reverse:</span></span>

1. <span data-ttu-id="c7f2f-147">En parallèle</span><span class="sxs-lookup"><span data-stu-id="c7f2f-147">In parallel</span></span>
    - <span data-ttu-id="c7f2f-148">Tous les écouteurs sont fermés.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-148">Any open listeners are Closed.</span></span> <span data-ttu-id="c7f2f-149">`ICommunicationListener.CloseAsync()` est appelé sur chaque écouteur.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-149">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="c7f2f-150">Le jeton d’annulation passé à `RunAsync()` est annulé.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-150">The cancellation token passed to `RunAsync()` is canceled.</span></span> <span data-ttu-id="c7f2f-151">Vérification que la propriété `IsCancellationRequested` du jeton d’annulation retourne la valeur true et que, si elle est appelée, la méthode `ThrowIfCancellationRequested` du jeton lève une `OperationCanceledException`.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-151">Checking the cancellation token's `IsCancellationRequested` property returns true, and if called the token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="c7f2f-152">Une fois `CloseAsync()` terminé sur chaque écouteur et `RunAsync()` également terminé, la méthode `StatelessService.OnCloseAsync()` du service est appelée.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-152">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, the service's `StatelessService.OnCloseAsync()` method is called, if present.</span></span> <span data-ttu-id="c7f2f-153">Il est rare de remplacer `StatelessService.OnCloseAsync()`.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-153">It is uncommon to override `StatelessService.OnCloseAsync()`.</span></span>
3. <span data-ttu-id="c7f2f-154">Lorsque `StatelessService.OnCloseAsync()` se termine, l’objet de service est détruit</span><span class="sxs-lookup"><span data-stu-id="c7f2f-154">After `StatelessService.OnCloseAsync()` completes, the service object is destructed</span></span>

## <a name="stateful-service-startup"></a><span data-ttu-id="c7f2f-155">Démarrage de service avec état</span><span class="sxs-lookup"><span data-stu-id="c7f2f-155">Stateful service Startup</span></span>
<span data-ttu-id="c7f2f-156">Les services avec état ont un modèle semblable aux services sans état, avec quelques modifications.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-156">Stateful services have a similar pattern to stateless services, with a few changes.</span></span> <span data-ttu-id="c7f2f-157">Lors du démarrage d’un service avec état, l’ordre des événements est le suivant :</span><span class="sxs-lookup"><span data-stu-id="c7f2f-157">When starting up a stateful service, the order of events is as follows:</span></span>

1. <span data-ttu-id="c7f2f-158">Le service est construit</span><span class="sxs-lookup"><span data-stu-id="c7f2f-158">The Service is constructed</span></span>
2. <span data-ttu-id="c7f2f-159">`StatefulServiceBase.OnOpenAsync()` est appelée.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-159">`StatefulServiceBase.OnOpenAsync()` is called.</span></span> <span data-ttu-id="c7f2f-160">Il est rare de le remplacer dans le service.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-160">This is uncommonly overridden in the service.</span></span>
3. <span data-ttu-id="c7f2f-161">Les événements suivants se produisent en parallèle :</span><span class="sxs-lookup"><span data-stu-id="c7f2f-161">The following things happen in parallel</span></span>
    - <span data-ttu-id="c7f2f-162">`StatefulServiceBase.CreateServiceReplicaListeners()` est appelé.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-162">`StatefulServiceBase.CreateServiceReplicaListeners()` is invoked</span></span> 
      - <span data-ttu-id="c7f2f-163">Si le service est un réplica principal, tous les écouteurs retournés sont ouverts.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-163">If the service is a Primary all returned listeners are Opened.</span></span> <span data-ttu-id="c7f2f-164">`ICommunicationListener.OpenAsync()` est appelé sur chaque écouteur.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-164">`ICommunicationListener.OpenAsync()` is called on each listener.</span></span>
      - <span data-ttu-id="c7f2f-165">Si le service est un réplica secondaire, seuls les écouteurs marqués comme `ListenOnSecondary = true` sont ouverts.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-165">If the service is a Secondary, only those listeners marked as `ListenOnSecondary = true` are opened.</span></span> <span data-ttu-id="c7f2f-166">Il est plus rare d’avoir des écouteurs ouverts dans les réplicas secondaires.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-166">Having listeners that are open on Secondaries is less common.</span></span>
    - <span data-ttu-id="c7f2f-167">Si le service est un réplica principal, la méthode `StatefulServiceBase.RunAsync()` du service est appelée.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-167">The if the Service is currently a Primary, the service's `StatefulServiceBase.RunAsync()` method is called</span></span>
4. <span data-ttu-id="c7f2f-168">Une fois que tous les appels `OpenAsync()` de l’écouteur de réplica sont terminés et que `RunAsync()` est appelé, `StatefulServiceBase.OnChangeRoleAsync()` est appelé.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-168">Once all the replica listener's `OpenAsync()` calls complete and `RunAsync()` is called, `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="c7f2f-169">Il est rare de le remplacer dans le service.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-169">This is uncommonly overridden in the service.</span></span>

<span data-ttu-id="c7f2f-170">Comme pour les services sans état, il n’y a aucune coordination entre l’ordre dans lequel les écouteurs sont créés et ouverts, et le moment auquel RunAsync est appelé.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-170">Similarly to stateless services, there's no coordination between the order in which the listeners are created and opened and when RunAsync is called.</span></span> <span data-ttu-id="c7f2f-171">Si vous avez besoin d’une coordination, les solutions à utiliser sont similaires.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-171">If you need coordination, the solutions are much the same.</span></span> <span data-ttu-id="c7f2f-172">Il existe un autre cas : supposons que les appels arrivant aux écouteurs de communication nécessitent des informations conservées dans des [collections fiables](service-fabric-reliable-services-reliable-collections.md).</span><span class="sxs-lookup"><span data-stu-id="c7f2f-172">THere is one additional case: say that the calls arriving at the communication listeners require information kept inside some [Reliable Collections](service-fabric-reliable-services-reliable-collections.md).</span></span> <span data-ttu-id="c7f2f-173">Étant donné que les écouteurs de communication peuvent s’ouvrir avant que les collections fiables ne soient accessibles en lecture ou en écriture, et avant que RunAsync ne démarre, une coordination supplémentaire est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-173">Because the communication listeners could open before the reliable collections are readable or writeable, and before RunAsync could start, some additional coordination is necessary.</span></span> <span data-ttu-id="c7f2f-174">La solution la plus simple et la plus courante est que les écouteurs de communication retournent un code d’erreur que le client utilise pour relancer la requête.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-174">The simplest and most common solution is for the communication listeners to return some error code that the client uses to know to retry the request.</span></span>

## <a name="stateful-service-shutdown"></a><span data-ttu-id="c7f2f-175">Arrêt de service avec état</span><span class="sxs-lookup"><span data-stu-id="c7f2f-175">Stateful service Shutdown</span></span>
<span data-ttu-id="c7f2f-176">Comme pour les services sans état, les événements de cycle de vie lors de l’arrêt sont les mêmes que lors du démarrage, mais dans l’ordre inverse.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-176">Similarly to Stateless services, the lifecycle events during shutdown are the same as during startup, but reversed.</span></span> <span data-ttu-id="c7f2f-177">Lorsqu’un service avec état est arrêté, les événements suivants se produisent :</span><span class="sxs-lookup"><span data-stu-id="c7f2f-177">When a stateful service is being shut down, the following events occur:</span></span>

1. <span data-ttu-id="c7f2f-178">En parallèle</span><span class="sxs-lookup"><span data-stu-id="c7f2f-178">In parallel</span></span>
    - <span data-ttu-id="c7f2f-179">Tous les écouteurs sont fermés.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-179">Any open listeners are Closed.</span></span> <span data-ttu-id="c7f2f-180">`ICommunicationListener.CloseAsync()` est appelé sur chaque écouteur.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-180">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="c7f2f-181">Le jeton d’annulation passé à `RunAsync()` est annulé.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-181">The cancellation token passed to `RunAsync()` is canceled.</span></span> <span data-ttu-id="c7f2f-182">Vérification que la propriété `IsCancellationRequested` du jeton d’annulation retourne la valeur true et que, si elle est appelée, la méthode `ThrowIfCancellationRequested` du jeton lève une `OperationCanceledException`.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-182">Checking the cancellation token's `IsCancellationRequested` property returns true, and if called the token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="c7f2f-183">Une fois `CloseAsync()` terminée sur chaque écouteur et `RunAsync()` également terminée, la méthode `StatefulServiceBase.OnChangeRoleAsync()` du service est appelée.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-183">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, the service's `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="c7f2f-184">(Ceci est rarement remplacé dans le service.)</span><span class="sxs-lookup"><span data-stu-id="c7f2f-184">(This is uncommonly overridden in the service.)</span></span>
    - <span data-ttu-id="c7f2f-185">Ce n’est que si le réplica de service est un réplica principal que vous devez attendre que RunAsync se termine.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-185">Waiting for RunAsync to complete is only necessary if this service replica was a Primary.</span></span>
3. <span data-ttu-id="c7f2f-186">Une fois la méthode `StatefulServiceBase.OnChangeRoleAsync()` terminée, la méthode `StatefulServiceBase.OnCloseAsync()` est appelée.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-186">Once the `StatefulServiceBase.OnChangeRoleAsync()` method completes, the `StatefulServiceBase.OnCloseAsync()` method is called.</span></span> <span data-ttu-id="c7f2f-187">Il s’agit d’un remplacement rare, mais possible.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-187">This is an uncommon override, but it is available.</span></span>
3. <span data-ttu-id="c7f2f-188">Une fois `StatefulServiceBase.OnCloseAsync()` terminée, l’objet de service est détruit.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-188">After `StatefulServiceBase.OnCloseAsync()` completes, the service object is destructed.</span></span>

## <a name="stateful-service-primary-swaps"></a><span data-ttu-id="c7f2f-189">Échanges de réplica principal de service avec état</span><span class="sxs-lookup"><span data-stu-id="c7f2f-189">Stateful service primary swaps</span></span>
<span data-ttu-id="c7f2f-190">Pendant l’exécution d’un service avec état, seuls les réplicas principaux de ce service avec état ont leurs écouteurs de communication ouverts et leur méthode RunAsync appelée.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-190">While a stateful service is running, only the Primary replicas of that stateful services have their communication listeners opened and their RunAsync method called.</span></span> <span data-ttu-id="c7f2f-191">Les réplicas secondaires sont construits mais ne reçoivent aucun autre appel.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-191">Secondary are constructed but see no further calls.</span></span> <span data-ttu-id="c7f2f-192">Toutefois, pendant l’exécution d’un service avec état, le réplica principal peut changer.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-192">While a stateful service is running however, which replica is currently the Primary can change.</span></span> <span data-ttu-id="c7f2f-193">Que cela signifie-t-il en termes des événements du cycle de vie qu’un réplica peut voir ?</span><span class="sxs-lookup"><span data-stu-id="c7f2f-193">What does this mean in terms of the lifecycle events that a replica can see?</span></span> <span data-ttu-id="c7f2f-194">Le comportement que voit le réplica avec état varie selon qu’il s’agit du réplica qui est rétrogradé ou promu au cours de l’échange.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-194">The behavior the stateful replica sees depends on whether it is the replica being demoted or promoted during the swap.</span></span>

### <a name="for-the-primary-being-demoted"></a><span data-ttu-id="c7f2f-195">Pour le réplica principal rétrogradé</span><span class="sxs-lookup"><span data-stu-id="c7f2f-195">For the primary being demoted</span></span>
<span data-ttu-id="c7f2f-196">Service Fabric nécessite que ce réplica arrête de traiter des messages et quitte tout travail en arrière-plan qu’il exécute.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-196">Service Fabric needs this replica to stop processing messages and quit any background work it is doing.</span></span> <span data-ttu-id="c7f2f-197">Par conséquent, cette étape est similaire à l’arrêt du service.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-197">As a result, this step looks similar to when the service is being shut down.</span></span> <span data-ttu-id="c7f2f-198">La différence est que le service n’est pas détruit ou fermé, car il est conservé en tant que réplica secondaire.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-198">One difference is that the Service isn't destructed or closed since it remains as a Secondary.</span></span> <span data-ttu-id="c7f2f-199">Les API suivantes sont appelées :</span><span class="sxs-lookup"><span data-stu-id="c7f2f-199">The following APIs are called:</span></span>

1. <span data-ttu-id="c7f2f-200">En parallèle</span><span class="sxs-lookup"><span data-stu-id="c7f2f-200">In parallel</span></span>
    - <span data-ttu-id="c7f2f-201">Tous les écouteurs sont fermés.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-201">Any open listeners are Closed.</span></span> <span data-ttu-id="c7f2f-202">`ICommunicationListener.CloseAsync()` est appelé sur chaque écouteur.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-202">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="c7f2f-203">Le jeton d’annulation passé à `RunAsync()` est annulé.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-203">The cancellation token passed to `RunAsync()` is canceled.</span></span> <span data-ttu-id="c7f2f-204">Vérification que la propriété `IsCancellationRequested` du jeton d’annulation retourne la valeur true et que, si elle est appelée, la méthode `ThrowIfCancellationRequested` du jeton lève une `OperationCanceledException`.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-204">Checking the cancellation token's `IsCancellationRequested` property returns true, and if called the token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="c7f2f-205">Une fois `CloseAsync()` terminée sur chaque écouteur et `RunAsync()` également terminée, la méthode `StatefulServiceBase.OnChangeRoleAsync()` du service est appelée.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-205">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, the service's `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="c7f2f-206">Il est rare de le remplacer dans le service.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-206">This is uncommonly overridden in the service.</span></span>

### <a name="for-the-secondary-being-promoted"></a><span data-ttu-id="c7f2f-207">Pour le réplica secondaire promu</span><span class="sxs-lookup"><span data-stu-id="c7f2f-207">For the secondary being promoted</span></span>
<span data-ttu-id="c7f2f-208">De même, Service Fabric nécessite que ce réplica commence à écouter les messages sur le réseau et qu’il démarre les tâches en arrière-plan qui le concernent.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-208">Similarly, Service Fabric needs this replica to start listening for messages on the wire and start any background tasks it cares about.</span></span> <span data-ttu-id="c7f2f-209">Par conséquent, ce processus est similaire à la création du service, à ceci près que le réplica lui-même existe déjà.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-209">As a result, this process looks similar to when the service is created, except that the replica itself already exists.</span></span> <span data-ttu-id="c7f2f-210">Les API suivantes sont appelées :</span><span class="sxs-lookup"><span data-stu-id="c7f2f-210">The following APIs are called:</span></span>

1. <span data-ttu-id="c7f2f-211">En parallèle</span><span class="sxs-lookup"><span data-stu-id="c7f2f-211">In parallel</span></span>
    - <span data-ttu-id="c7f2f-212">`StatefulServiceBase.CreateServiceReplicaListeners()` est appelé et les écouteurs retournés sont ouverts.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-212">`StatefulServiceBase.CreateServiceReplicaListeners()` is invoked and any returned listeners are Opened.</span></span> <span data-ttu-id="c7f2f-213">`ICommunicationListener.OpenAsync()` est appelé sur chaque écouteur.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-213">`ICommunicationListener.OpenAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="c7f2f-214">La méthode `StatefulServiceBase.RunAsync()` du service est appelée.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-214">The service's `StatefulServiceBase.RunAsync()` method is called</span></span>
2. <span data-ttu-id="c7f2f-215">Une fois que tous les appels `OpenAsync()` de l’écouteur de réplica sont terminés et que `RunAsync()` a été appelé, `StatefulServiceBase.OnChangeRoleAsync()` est appelé.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-215">Once all the replica listener's `OpenAsync()` calls complete and `RunAsync()` has been called,  `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="c7f2f-216">Il est rare de le remplacer dans le service.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-216">This is uncommonly overridden in the service.</span></span>

### <a name="common-issues-during-stateful-service-shutdown-and-primary-demotion"></a><span data-ttu-id="c7f2f-217">Problèmes courants se produisant pendant l’arrêt d’un service avec état et la rétrogradation du réplica principal</span><span class="sxs-lookup"><span data-stu-id="c7f2f-217">Common issues during stateful service shutdown and primary demotion</span></span>
<span data-ttu-id="c7f2f-218">Service Fabric peut modifier le réplica principal d’un service avec état pour diverses raisons.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-218">Service Fabric changes the Primary of a stateful service for a variety of reasons.</span></span> <span data-ttu-id="c7f2f-219">Parmi les raisons les plus courantes figurent le [rééquilibrage des clusters](service-fabric-cluster-resource-manager-balancing.md) et la [mise à niveau des applications](service-fabric-application-upgrade.md).</span><span class="sxs-lookup"><span data-stu-id="c7f2f-219">The most common are [cluster rebalancing](service-fabric-cluster-resource-manager-balancing.md) and [application upgrade](service-fabric-application-upgrade.md).</span></span> <span data-ttu-id="c7f2f-220">Pendant ces opérations (ainsi que lors de l’arrêt normal du service, comme lorsque le service a été supprimé), il est important que le service respecte le `CancellationToken`.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-220">During these operations (as well as during normal service shutdown, like you'd see if the service was deleted), it is important that the service respect the `CancellationToken`.</span></span> <span data-ttu-id="c7f2f-221">Les services qui ne gèrent pas l’annulation « proprement » seront confrontés à plusieurs problèmes.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-221">Services that do not handle cancellation cleanly will experience several issues.</span></span> <span data-ttu-id="c7f2f-222">Par exemple, les opérations seront lentes, car Service Fabric attendra que les services s’arrêtent normalement.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-222">In particular, these operations will be slow since Service Fabric waits for the services to stop gracefully.</span></span> <span data-ttu-id="c7f2f-223">Cela peut entraîner l’échec des mises à jour qui expirent et sont annulées.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-223">This can ultimately lead to failed upgrades that time out and roll back.</span></span> <span data-ttu-id="c7f2f-224">Si vous ne respectez pas le jeton d’annulation, vous pouvez également provoquer des clusters déséquilibrés, car les nœuds deviennent actifs, mais les services ne peuvent pas être rééquilibrés, car leur déplacement prendrait trop de temps.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-224">Failure to honor the cancellation token can also cause imbalanced clusters because nodes get hot but the services can't be rebalanced since it takes too long to move them elsewhere.</span></span> 

<span data-ttu-id="c7f2f-225">Étant donné que les services sont avec état, il est également probable qu’ils utilisent des [collections fiables](service-fabric-reliable-services-reliable-collections.md).</span><span class="sxs-lookup"><span data-stu-id="c7f2f-225">Since the services are stateful, it is also likely that they are using the [Reliable Collections](service-fabric-reliable-services-reliable-collections.md).</span></span> <span data-ttu-id="c7f2f-226">Dans Service Fabric, lorsqu’un réplica principal est rétrogradé, l’une des premières choses qui se produisent est que l’accès en écriture à l’état sous-jacent est révoqué.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-226">In Service Fabric, when a Primary is demoted, one of the first things that happens is that write access to the underlying state is revoked.</span></span> <span data-ttu-id="c7f2f-227">Cela conduit à un deuxième type de problème qui peut avoir un impact sur le cycle de vie du service.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-227">This leads to a second set of issues that can impact the service lifecycle.</span></span> <span data-ttu-id="c7f2f-228">Les collections retournent des exceptions selon le timing et selon que le réplica est déplacé ou arrêté.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-228">The collections return Exceptions based on the timing and whether the replica is being moved or shut down.</span></span> <span data-ttu-id="c7f2f-229">Ces exceptions doivent être gérées correctement.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-229">These exceptions should be handled correctly.</span></span> <span data-ttu-id="c7f2f-230">Les exceptions levées par Service Fabric sont soit permanentes [(`FabricException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabricexception?view=azure-dotnet), soit passagères [(`FabricTransientException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabrictransientexception?view=azure-dotnet).</span><span class="sxs-lookup"><span data-stu-id="c7f2f-230">Exceptions thrown by Service Fabric fall into permanent [(`FabricException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabricexception?view=azure-dotnet) and transient [(`FabricTransientException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabrictransientexception?view=azure-dotnet) categories.</span></span> <span data-ttu-id="c7f2f-231">Les exceptions permanentes doivent être journalisées et levées, alors que les exceptions passagères peuvent être retentées selon une logique de nouvelle tentative.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-231">Permanent exceptions should be logged and thrown, while the transient exceptions may be retried based on some retry logic.</span></span>

<span data-ttu-id="c7f2f-232">Le fait de gérer des exceptions issues de l’utilisation de `ReliableCollections` conjointement aux événements du cycle de vie du service constitue une partie importante du test et de la validation d’un service fiable.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-232">Handling the exceptions that come from use of the `ReliableCollections` in conjunction with service lifecycle events is an important part of testing and validating a Reliable Service.</span></span> <span data-ttu-id="c7f2f-233">Il est recommandé de toujours exécuter votre service sous une charge lorsque vous effectuez une mise à niveau et des [tests de chaos](service-fabric-controlled-chaos.md) avant de le déployer dans un environnement de production.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-233">The recommendation is always to run your service under load while performing upgrades and [chaos testing](service-fabric-controlled-chaos.md) before ever deploying to production.</span></span> <span data-ttu-id="c7f2f-234">Ces étapes de base vous permettent de vérifier que votre service est correctement implémenté et qu’il gère correctement les événements de cycle de vie.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-234">These basic steps help ensure that your service is correctly implemented and handles lifecycle events correctly.</span></span>


## <a name="notes-on-service-lifecycle"></a><span data-ttu-id="c7f2f-235">Remarques sur le cycle de vie du service</span><span class="sxs-lookup"><span data-stu-id="c7f2f-235">Notes on service lifecycle</span></span>
  - <span data-ttu-id="c7f2f-236">La méthode `RunAsync()` et l’appel `CreateServiceReplicaListeners/CreateServiceInstanceListeners` sont facultatifs.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-236">Both the `RunAsync()` method and the `CreateServiceReplicaListeners/CreateServiceInstanceListeners` calls are optional.</span></span> <span data-ttu-id="c7f2f-237">Un service peut avoir l’un des deux, les deux ou aucun.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-237">A service may have one of them, both, or neither.</span></span> <span data-ttu-id="c7f2f-238">Par exemple, si le service effectue tout son travail en réponse aux appels d’utilisateur, il est inutile d’implémenter `RunAsync()`.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-238">For example, if the service does all its work in response to user calls, there is no need for it to implement `RunAsync()`.</span></span> <span data-ttu-id="c7f2f-239">Seuls les écouteurs de communication et le code associé sont nécessaires.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-239">Only the communication listeners and their associated code are necessary.</span></span> <span data-ttu-id="c7f2f-240">De même, la création et le renvoi d’écouteurs de communication sont facultatifs, car le service peut n’avoir que du travail en arrière-plan à exécuter et n’a donc besoin d’implémenter que `RunAsync()`</span><span class="sxs-lookup"><span data-stu-id="c7f2f-240">Similarly, creating and returning communication listeners is optional, as the service may have only background work to do, and so only needs to implement `RunAsync()`</span></span>
  - <span data-ttu-id="c7f2f-241">Il est valide pour un service de terminer `RunAsync()` correctement et d’en revenir.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-241">It is valid for a service to complete `RunAsync()` successfully and return from it.</span></span> <span data-ttu-id="c7f2f-242">Le fait qu’il se termine ne correspond pas à une condition d’échec.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-242">Completing is not a failure condition.</span></span> <span data-ttu-id="c7f2f-243">Le fait de terminer `RunAsync()` indique que le travail d’arrière-plan du service est terminé.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-243">Completing `RunAsync()` indicates that the background work of the service has completed.</span></span> <span data-ttu-id="c7f2f-244">Pour les services avec état fiables, `RunAsync()` est appelé à nouveau si le réplica principal est devenu un réplica secondaire, puis est repassé à l’état de réplica principal.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-244">For stateful reliable services, `RunAsync()` is called again if the replica were demoted from Primary to Secondary and then promoted back to Primary.</span></span>
  - <span data-ttu-id="c7f2f-245">Si un service quitte `RunAsync()` en levant une exception inattendue, il s’agit d’un échec.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-245">If a service exits from `RunAsync()` by throwing some unexpected exception, this constitutes a failure.</span></span> <span data-ttu-id="c7f2f-246">L’objet du service est arrêté et une erreur d’intégrité est signalée.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-246">The service object is shut down and a health error reported.</span></span>
  - <span data-ttu-id="c7f2f-247">S’il n’existe pas de limite de temps sur le renvoi de ces méthodes, vous perdez immédiatement la capacité d’écrire dans les Collections fiables, et vous ne pouvez donc pas effectuer de travail réel.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-247">While there is no time limit on returning from these methods, you immediately lose the ability to write to Reliable Collections and therefore cannot complete any real work.</span></span> <span data-ttu-id="c7f2f-248">Il est recommandé de procéder au renvoi aussi rapidement que possible dès la réception de la demande d’annulation.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-248">It is recommended that you return as quickly as possible upon receiving the cancellation request.</span></span> <span data-ttu-id="c7f2f-249">Si votre service ne répond pas à ces appels d’API dans un délai raisonnable, Service Fabric peut mettre fin à votre service.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-249">If your service does not respond to these API calls in a reasonable amount of time Service Fabric may forcibly terminate your service.</span></span> <span data-ttu-id="c7f2f-250">En général, cela se produit uniquement lors de mises à niveau d’application ou lorsqu’un service est en cours de suppression.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-250">Usually this only happens during application upgrades or when a service is being deleted.</span></span> <span data-ttu-id="c7f2f-251">Par défaut, ce délai d’attente est de 15 minutes.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-251">This timeout is 15 minutes by default.</span></span>
  - <span data-ttu-id="c7f2f-252">Les échecs dans le chemin d’accès `OnCloseAsync()` entraînent l’appel de `OnAbort()` qui constitue une opportunité de dernière chance pour le service de nettoyer et de libérer les ressources demandées.</span><span class="sxs-lookup"><span data-stu-id="c7f2f-252">Failures in the `OnCloseAsync()` path result in `OnAbort()` being called which is a last-chance best-effort opportunity for the service to clean up and release any resources that they have claimed.</span></span>

## <a name="next-steps"></a><span data-ttu-id="c7f2f-253">Étapes suivantes</span><span class="sxs-lookup"><span data-stu-id="c7f2f-253">Next steps</span></span>
- [<span data-ttu-id="c7f2f-254">Présentation de Reliable Services</span><span class="sxs-lookup"><span data-stu-id="c7f2f-254">Introduction to Reliable Services</span></span>](service-fabric-reliable-services-introduction.md)
- [<span data-ttu-id="c7f2f-255">Démarrage rapide de Reliable Services</span><span class="sxs-lookup"><span data-stu-id="c7f2f-255">Reliable Services quick start</span></span>](service-fabric-reliable-services-quick-start.md)
- [<span data-ttu-id="c7f2f-256">Utilisation avancée de Reliable Services</span><span class="sxs-lookup"><span data-stu-id="c7f2f-256">Reliable Services advanced usage</span></span>](service-fabric-reliable-services-advanced-usage.md)
