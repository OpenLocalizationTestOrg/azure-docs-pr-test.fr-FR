---
title: "Vue d’ensemble de Service Fabric Reliable Actors | Microsoft Docs"
description: "Présentation du modèle de programmation Service Fabric Reliable Actors."
services: service-fabric
documentationcenter: .net
author: vturecek
manager: timlt
editor: 
ms.assetid: 7fdad07f-f2d6-4c74-804d-e0d56131f060
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/29/2017
ms.author: vturecek
ms.openlocfilehash: e89be04a0d6fe90a89e293e67d42f0204eb7000a
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 07/11/2017
---
# <a name="introduction-to-service-fabric-reliable-actors"></a><span data-ttu-id="01dff-103">Présentation des Acteurs fiables Service Fabric</span><span class="sxs-lookup"><span data-stu-id="01dff-103">Introduction to Service Fabric Reliable Actors</span></span>
<span data-ttu-id="01dff-104">Reliable Actors est une infrastructure d’application Service Fabric reposant sur le modèle [Virtual Actor](http://research.microsoft.com/en-us/projects/orleans/).</span><span class="sxs-lookup"><span data-stu-id="01dff-104">Reliable Actors is a Service Fabric application framework based on the [Virtual Actor](http://research.microsoft.com/en-us/projects/orleans/) pattern.</span></span> <span data-ttu-id="01dff-105">L’API Reliable Actors fournit un modèle de programmation monothread qui tire parti des garanties de fiabilité et d’évolutivité fournies par Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="01dff-105">The Reliable Actors API provides a single-threaded programming model built on the scalability and reliability guarantees provided by Service Fabric.</span></span>

## <a name="what-are-actors"></a><span data-ttu-id="01dff-106">Qu’est-ce qu’un « acteur » ?</span><span class="sxs-lookup"><span data-stu-id="01dff-106">What are Actors?</span></span>
<span data-ttu-id="01dff-107">Un acteur est une unité de calcul et d’état indépendante et isolée, associée à une exécution monothread.</span><span class="sxs-lookup"><span data-stu-id="01dff-107">An actor is an isolated, independent unit of compute and state with single-threaded execution.</span></span> <span data-ttu-id="01dff-108">Le [modèle d’acteur](https://en.wikipedia.org/wiki/Actor_model) est un modèle de calcul utilisé pour les systèmes simultanés ou distribués dans lesquels un grand nombre de ces acteurs peut s’exécuter simultanément et indépendamment les uns des autres.</span><span class="sxs-lookup"><span data-stu-id="01dff-108">The [actor pattern](https://en.wikipedia.org/wiki/Actor_model) is a computational model for concurrent or distributed systems in which a large number of these actors can execute simultaneously and independently of each other.</span></span> <span data-ttu-id="01dff-109">Les acteurs peuvent communiquer entre eux et créer d’autres acteurs.</span><span class="sxs-lookup"><span data-stu-id="01dff-109">Actors can communicate with each other and they can create more actors.</span></span>

### <a name="when-to-use-reliable-actors"></a><span data-ttu-id="01dff-110">Quand utiliser Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="01dff-110">When to use Reliable Actors</span></span>
<span data-ttu-id="01dff-111">Service Fabric Reliable Actors est une implémentation du modèle de conception d’acteurs.</span><span class="sxs-lookup"><span data-stu-id="01dff-111">Service Fabric Reliable Actors is an implementation of the actor design pattern.</span></span> <span data-ttu-id="01dff-112">Comme pour n’importe quel modèle de conception de logiciels, le choix de l’utilisation d’un modèle spécifique dépend de son degré d’adéquation avec le problème de conception du logiciel.</span><span class="sxs-lookup"><span data-stu-id="01dff-112">As with any software design pattern, the decision whether to use a specific pattern is made based on whether or not a software design problem fits the pattern.</span></span>

<span data-ttu-id="01dff-113">Bien que le modèle de conception d’acteurs puisse être adapté à divers problèmes et scénarios de systèmes distribués, il est important de bien tenir compte des contraintes du modèle et du cadre servant à sa mise en œuvre.</span><span class="sxs-lookup"><span data-stu-id="01dff-113">Although the actor design pattern can be a good fit to a number of distributed systems problems and scenarios, careful consideration of the constraints of the pattern and the framework implementing it must be made.</span></span> <span data-ttu-id="01dff-114">En règle générale, vous pouvez envisager d’utiliser le modèle d’acteur pour modéliser votre problème ou votre scénario si :</span><span class="sxs-lookup"><span data-stu-id="01dff-114">As general guidance, consider the actor pattern to model your problem or scenario if:</span></span>

* <span data-ttu-id="01dff-115">Votre espace de problème implique un nombre élevé (plusieurs milliers) de petites unités d’état et de logique indépendantes et isolées.</span><span class="sxs-lookup"><span data-stu-id="01dff-115">Your problem space involves a large number (thousands or more) of small, independent, and isolated units of state and logic.</span></span>
* <span data-ttu-id="01dff-116">Vous souhaitez travailler avec des objets monothread ne nécessitant aucune interaction significative avec des composants externes, par exemple l’interrogation de l’état sur un ensemble d’acteurs.</span><span class="sxs-lookup"><span data-stu-id="01dff-116">You want to work with single-threaded objects that do not require significant interaction from external components, including querying state across a set of actors.</span></span>
* <span data-ttu-id="01dff-117">Vos instances d’acteurs ne bloquent pas les appelants avec des retards inattendus en exécutant des opérations d’E/S.</span><span class="sxs-lookup"><span data-stu-id="01dff-117">Your actor instances won't block callers with unpredictable delays by issuing I/O operations.</span></span>

## <a name="actors-in-service-fabric"></a><span data-ttu-id="01dff-118">Le rôle des acteurs dans Service Fabric</span><span class="sxs-lookup"><span data-stu-id="01dff-118">Actors in Service Fabric</span></span>
<span data-ttu-id="01dff-119">Dans Service Fabric, les acteurs sont implémentés dans l’infrastructure Reliable Actors, une infrastructure d’application basée sur un modèle d’acteurs et s’appuyant sur [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md).</span><span class="sxs-lookup"><span data-stu-id="01dff-119">In Service Fabric, actors are implemented in the Reliable Actors framework: An actor-pattern-based application framework built on top of [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md).</span></span> <span data-ttu-id="01dff-120">Chaque service Reliable Actor que vous écrivez correspond en fait à une instance Reliable Service partitionnée avec état.</span><span class="sxs-lookup"><span data-stu-id="01dff-120">Each Reliable Actor service you write is actually a partitioned, stateful Reliable Service.</span></span>

<span data-ttu-id="01dff-121">Chaque acteur se définit comme une instance d’un type d’acteur, de la même façon qu’un objet .NET est une instance d’un type .NET.</span><span class="sxs-lookup"><span data-stu-id="01dff-121">Every actor is defined as an instance of an actor type, identical to the way a .NET object is an instance of a .NET type.</span></span> <span data-ttu-id="01dff-122">Par exemple, un type d'acteur peut implémenter les fonctionnalités d'une calculatrice, et plusieurs acteurs de ce type peuvent être distribués sur différents nœuds d'un cluster.</span><span class="sxs-lookup"><span data-stu-id="01dff-122">For example, there may be an actor type that implements the functionality of a calculator and there could be many actors of that type that are distributed on various nodes across a cluster.</span></span> <span data-ttu-id="01dff-123">Chaque acteur de ce type est identifié de façon unique par un ID d'acteur.</span><span class="sxs-lookup"><span data-stu-id="01dff-123">Each such actor is uniquely identified by an actor ID.</span></span>

### <a name="actor-lifetime"></a><span data-ttu-id="01dff-124">Durée de vie de l’acteur</span><span class="sxs-lookup"><span data-stu-id="01dff-124">Actor Lifetime</span></span>
<span data-ttu-id="01dff-125">Les acteurs Service Fabric sont virtuels, ce qui signifie que leur durée de vie n'est pas liée à leur représentation en mémoire.</span><span class="sxs-lookup"><span data-stu-id="01dff-125">Service Fabric actors are virtual, meaning that their lifetime is not tied to their in-memory representation.</span></span> <span data-ttu-id="01dff-126">En conséquence, ils n’ont pas besoin d’être explicitement créés ou détruits.</span><span class="sxs-lookup"><span data-stu-id="01dff-126">As a result, they do not need to be explicitly created or destroyed.</span></span> <span data-ttu-id="01dff-127">Le runtime Reliable Actors active automatiquement un acteur la première fois qu’il reçoit une demande pour cet identifiant d’acteur.</span><span class="sxs-lookup"><span data-stu-id="01dff-127">The Reliable Actors runtime automatically activates an actor the first time it receives a request for that actor ID.</span></span> <span data-ttu-id="01dff-128">Si un acteur n’est pas utilisé pendant un certain temps, le runtime Reliable Actors nettoie l’objet en mémoire.</span><span class="sxs-lookup"><span data-stu-id="01dff-128">If an actor is not used for a period of time, the Reliable Actors runtime garbage-collects the in-memory object.</span></span> <span data-ttu-id="01dff-129">Il tient également compte de l’existence de l’acteur si celui-ci doit être réactivé ultérieurement.</span><span class="sxs-lookup"><span data-stu-id="01dff-129">It will also maintain knowledge of the actor's existence should it need to be reactivated later.</span></span> <span data-ttu-id="01dff-130">Pour plus de détails, consultez la page [Cycle de vie des acteurs et Garbage Collection](service-fabric-reliable-actors-lifecycle.md).</span><span class="sxs-lookup"><span data-stu-id="01dff-130">For more details, see [Actor lifecycle and garbage collection](service-fabric-reliable-actors-lifecycle.md).</span></span>

<span data-ttu-id="01dff-131">Cette abstraction de la durée de vie de l’acteur virtuel comporte certains inconvénients liés au modèle d’acteur virtuel ; en réalité, l’implémentation de Reliable Actors diffère parfois de ce modèle.</span><span class="sxs-lookup"><span data-stu-id="01dff-131">This virtual actor lifetime abstraction carries some caveats as a result of the virtual actor model, and in fact the Reliable Actors implementation deviates at times from this model.</span></span>

* <span data-ttu-id="01dff-132">Un acteur est automatiquement activé (ce qui entraîne la construction d’un objet d’acteur) la première fois qu’un message est envoyé à son ID d’acteur.</span><span class="sxs-lookup"><span data-stu-id="01dff-132">An actor is automatically activated (causing an actor object to be constructed) the first time a message is sent to its actor ID.</span></span> <span data-ttu-id="01dff-133">Après un certain temps, l’objet d’acteur est nettoyé.</span><span class="sxs-lookup"><span data-stu-id="01dff-133">After some period of time, the actor object is garbage collected.</span></span> <span data-ttu-id="01dff-134">Si vous réutilisez ensuite ce même ID d’acteur, un nouvel objet d’acteur sera construit.</span><span class="sxs-lookup"><span data-stu-id="01dff-134">In the future, using the actor ID again, causes a new actor object to be constructed.</span></span> <span data-ttu-id="01dff-135">L’état d’un acteur survit à la durée de vie de l’objet lorsqu’il est stocké dans le gestionnaire d’état.</span><span class="sxs-lookup"><span data-stu-id="01dff-135">An actor's state outlives the object's lifetime when stored in the state manager.</span></span>
* <span data-ttu-id="01dff-136">Le déclenchement d’une méthode d’acteur pour un ID d’acteur donné aura pour effet d’activer cet acteur.</span><span class="sxs-lookup"><span data-stu-id="01dff-136">Calling any actor method for an actor ID activates that actor.</span></span> <span data-ttu-id="01dff-137">Pour cette raison, le constructeur des types d’acteur est implicitement appelé par le runtime.</span><span class="sxs-lookup"><span data-stu-id="01dff-137">For this reason, actor types have their constructor called implicitly by the runtime.</span></span> <span data-ttu-id="01dff-138">Par conséquent, le code client ne peut pas transmettre les paramètres au constructeur du type d’acteur, bien que des paramètres puissent être transférés au constructeur de l’acteur par le service lui-même.</span><span class="sxs-lookup"><span data-stu-id="01dff-138">Therefore, client code cannot pass parameters to the actor type's constructor, although parameters may be passed to the actor's constructor by the service itself.</span></span> <span data-ttu-id="01dff-139">Autrement dit, les acteurs peuvent être construits à un état partiellement initialisé au moment où d’autres méthodes sont appelées si l’acteur nécessite l’envoi de paramètres d’initialisation par le client.</span><span class="sxs-lookup"><span data-stu-id="01dff-139">The result is that actors may be constructed in a partially-initialized state by the time other methods are called on it, if the actor requires initialization parameters from the client.</span></span> <span data-ttu-id="01dff-140">Il n’existe aucun point d’entrée unique pour l’activation d’un acteur à partir du client.</span><span class="sxs-lookup"><span data-stu-id="01dff-140">There is no single entry point for the activation of an actor from the client.</span></span>
* <span data-ttu-id="01dff-141">Bien que Reliable Actors crée implicitement des objets d’acteur, vous n’avez pas la possibilité de supprimer explicitement un acteur et son état.</span><span class="sxs-lookup"><span data-stu-id="01dff-141">Although Reliable Actors implicitly create actor objects; you do have the ability to explicitly delete an actor and its state.</span></span>

### <a name="distribution-and-failover"></a><span data-ttu-id="01dff-142">Distribution et basculement</span><span class="sxs-lookup"><span data-stu-id="01dff-142">Distribution and failover</span></span>
<span data-ttu-id="01dff-143">Dans un souci de fiabilité et d’évolutivité, Service Fabric distribue les acteurs dans l’ensemble du cluster et les migre automatiquement à partir des nœuds ayant échoué vers des nœuds sains selon les besoins.</span><span class="sxs-lookup"><span data-stu-id="01dff-143">To provide scalability and reliability, Service Fabric distributes actors throughout the cluster and automatically migrates them from failed nodes to healthy ones as required.</span></span> <span data-ttu-id="01dff-144">Il s’agit ici d’une abstraction sur une instance [Reliable Service partitionnée avec état](service-fabric-concepts-partitioning.md).</span><span class="sxs-lookup"><span data-stu-id="01dff-144">This is an abstraction over a [partitioned, stateful Reliable Service](service-fabric-concepts-partitioning.md).</span></span> <span data-ttu-id="01dff-145">L’exécution des acteurs dans une instance Reliable Service avec état appelée *Actor Service*garantit la distribution, l’évolutivité, la fiabilité et le basculement automatique du service.</span><span class="sxs-lookup"><span data-stu-id="01dff-145">Distribution, scalability, reliability, and automatic failover are all provided by virtue of the fact that actors are running inside a stateful Reliable Service called the *Actor Service*.</span></span>

<span data-ttu-id="01dff-146">Les acteurs sont distribués sur les partitions d’Actor Service, et ces partitions sont réparties entre les nœuds d’un cluster Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="01dff-146">Actors are distributed across the partitions of the Actor Service, and those partitions are distributed across the nodes in a Service Fabric cluster.</span></span> <span data-ttu-id="01dff-147">Chaque partition de service contient un ensemble d’acteurs.</span><span class="sxs-lookup"><span data-stu-id="01dff-147">Each service partition contains a set of actors.</span></span> <span data-ttu-id="01dff-148">Service Fabric gère la distribution et le basculement des partitions du service.</span><span class="sxs-lookup"><span data-stu-id="01dff-148">Service Fabric manages distribution and failover of the service partitions.</span></span>

<span data-ttu-id="01dff-149">Par exemple, un service d’acteur avec neuf partitions déployées sur trois nœuds à l’aide de l’emplacement de partition d’acteurs par défaut serait distribué comme suit :</span><span class="sxs-lookup"><span data-stu-id="01dff-149">For example, an actor service with nine partitions deployed to three nodes using the default actor partition placement would be distributed thusly:</span></span>

![Distribution Reliable Actors][2]

<span data-ttu-id="01dff-151">L’infrastructure Actor gère automatiquement les paramètres du schéma de partitions et de la plage de clés.</span><span class="sxs-lookup"><span data-stu-id="01dff-151">The Actor Framework manages partition scheme and key range settings for you.</span></span> <span data-ttu-id="01dff-152">Bien que cela simplifie certains choix, certains aspects méritent d’être pris en compte :</span><span class="sxs-lookup"><span data-stu-id="01dff-152">This simplifies some choices but also carries some consideration:</span></span>

* <span data-ttu-id="01dff-153">Reliable Services vous permet de choisir un schéma de partitionnement, une plage de clés (lorsque vous utilisez un schéma de partitionnement par plage) et un nombre de partitions.</span><span class="sxs-lookup"><span data-stu-id="01dff-153">Reliable Services allows you to choose a partitioning scheme, key range (when using a range partitioning scheme), and partition count.</span></span> <span data-ttu-id="01dff-154">Reliable Actors est limité au schéma de partitionnement par plage (schéma uniforme Int64) et vous oblige à utiliser la plage de clés Int64 complète.</span><span class="sxs-lookup"><span data-stu-id="01dff-154">Reliable Actors is restricted to the range partitioning scheme (the uniform Int64 scheme) and requires you use the full Int64 key range.</span></span>
* <span data-ttu-id="01dff-155">Par défaut, les acteurs sont placés aléatoirement dans les partitions, ce qui entraîne une distribution uniforme.</span><span class="sxs-lookup"><span data-stu-id="01dff-155">By default, actors are randomly placed into partitions resulting in uniform distribution.</span></span>
* <span data-ttu-id="01dff-156">Du fait de ce placement aléatoire, il faudra vraisemblablement s’attendre à ce que les opérations d’acteur requièrent systématiquement une communication réseau, y compris la sérialisation et la désérialisation des données d’appel de méthode, ce qui implique un effet de latence et une surcharge.</span><span class="sxs-lookup"><span data-stu-id="01dff-156">Because actors are randomly placed, it should be expected that actor operations will always require network communication, including serialization and deserialization of method call data, incurring latency and overhead.</span></span>
* <span data-ttu-id="01dff-157">Dans les scénarios avancés, il est possible de contrôler le placement des partitions en utilisant des ID d’acteur Int64 ID qui correspondent à des partitions spécifiques.</span><span class="sxs-lookup"><span data-stu-id="01dff-157">In advanced scenarios, it is possible to control actor partition placement by using Int64 actor IDs that map to specific partitions.</span></span> <span data-ttu-id="01dff-158">Toutefois, cette opération peut entraîner une répartition déséquilibrée des acteurs sur les différentes partitions.</span><span class="sxs-lookup"><span data-stu-id="01dff-158">However, doing so can result in an unbalanced distribution of actors across partitions.</span></span>

<span data-ttu-id="01dff-159">Pour plus d’informations sur le mode de partitionnement des services d’acteur, reportez-vous à la rubrique relative aux [concepts de partitionnement pour les acteurs](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span><span class="sxs-lookup"><span data-stu-id="01dff-159">For more information on how actor services are partitioned, refer to [partitioning concepts for actors](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span></span>

### <a name="actor-communication"></a><span data-ttu-id="01dff-160">Communication d’acteur</span><span class="sxs-lookup"><span data-stu-id="01dff-160">Actor communication</span></span>
<span data-ttu-id="01dff-161">Les interactions d’acteur sont définies dans une interface partagée entre l’acteur qui implémente l’interface et le client qui obtient un proxy vers un acteur via la même interface.</span><span class="sxs-lookup"><span data-stu-id="01dff-161">Actor interactions are defined in an interface that is shared by the actor that implements the interface, and the client that gets a proxy to an actor via the same interface.</span></span> <span data-ttu-id="01dff-162">Étant donné que cette interface est utilisée pour appeler des méthodes d’acteur de façon asynchrone, toutes les méthodes sur l’interface doivent retourner des tâches.</span><span class="sxs-lookup"><span data-stu-id="01dff-162">Because this interface is used to invoke actor methods asynchronously, every method on the interface must be Task-returning.</span></span>

<span data-ttu-id="01dff-163">Comme les appels de méthode et leurs réponses aboutissent à des demandes réseau sur le cluster, les arguments et les types de résultat des tâches renvoyées doivent être sérialisables par la plateforme.</span><span class="sxs-lookup"><span data-stu-id="01dff-163">Method invocations and their responses ultimately result in network requests across the cluster, so the arguments and the result types of the tasks that they return must be serializable by the platform.</span></span> <span data-ttu-id="01dff-164">En particulier, ils doivent être [sérialisables en contrat de données](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="01dff-164">In particular, they must be [data contract serializable](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span></span>

#### <a name="the-actor-proxy"></a><span data-ttu-id="01dff-165">Le proxy d’acteur</span><span class="sxs-lookup"><span data-stu-id="01dff-165">The actor proxy</span></span>
<span data-ttu-id="01dff-166">L’API du client Reliable Actors assure la communication entre une instance d’acteur et un client d’acteur.</span><span class="sxs-lookup"><span data-stu-id="01dff-166">The Reliable Actors client API provides communication between an actor instance and an actor client.</span></span> <span data-ttu-id="01dff-167">Pour communiquer avec un acteur, un client crée un objet proxy d'acteur qui implémente l'interface d'acteur.</span><span class="sxs-lookup"><span data-stu-id="01dff-167">To communicate with an actor, a client creates an actor proxy object that implements the actor interface.</span></span> <span data-ttu-id="01dff-168">Le client interagit avec l'acteur en appelant des méthodes sur l'objet proxy.</span><span class="sxs-lookup"><span data-stu-id="01dff-168">The client interacts with the actor by invoking methods on the proxy object.</span></span> <span data-ttu-id="01dff-169">Le proxy d’acteur peut être utilisé pour les communications client-acteur et acteur-acteur.</span><span class="sxs-lookup"><span data-stu-id="01dff-169">The actor proxy can be used for client-to-actor and actor-to-actor communication.</span></span>

```csharp
// Create a randomly distributed actor ID
ActorId actorId = ActorId.CreateRandom();

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
IMyActor myActor = ActorProxy.Create<IMyActor>(actorId, new Uri("fabric:/MyApp/MyActorService"));

// This will invoke a method on the actor. If an actor with the given ID does not exist, it will be activated by this method call.
await myActor.DoWorkAsync();
```

```java
// Create actor ID with some name
ActorId actorId = new ActorId("Actor1");

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
MyActor myActor = ActorProxyBase.create(actorId, new URI("fabric:/MyApp/MyActorService"), MyActor.class);

// This will invoke a method on the actor. If an actor with the given ID does not exist, it will be activated by this method call.
myActor.DoWorkAsync().get();
```


<span data-ttu-id="01dff-170">Notez que les deux informations utilisées pour créer l’objet proxy d’acteur sont l’ID d’acteur et le nom d’application.</span><span class="sxs-lookup"><span data-stu-id="01dff-170">Note that the two pieces of information used to create the actor proxy object are the actor ID and the application name.</span></span> <span data-ttu-id="01dff-171">L’ID d’acteur identifie de façon unique l’acteur, tandis que le nom d’application identifie l’ [application Service Fabric](service-fabric-reliable-actors-platform.md#application-model) dans laquelle l’acteur est déployé.</span><span class="sxs-lookup"><span data-stu-id="01dff-171">The actor ID uniquely identifies the actor, while the application name identifies the [Service Fabric application](service-fabric-reliable-actors-platform.md#application-model) where the actor is deployed.</span></span>

<span data-ttu-id="01dff-172">La classe `ActorProxy`(C#) / `ActorProxyBase`(Java) côté client effectue la résolution nécessaire pour localiser l’acteur par ID et ouvrir un canal de communication avec lui.</span><span class="sxs-lookup"><span data-stu-id="01dff-172">The `ActorProxy`(C#) / `ActorProxyBase`(Java) class on the client side performs the necessary resolution to locate the actor by ID and open a communication channel with it.</span></span> <span data-ttu-id="01dff-173">Cette classe retente également de localiser l’acteur en cas d’échecs de communication et de basculements.</span><span class="sxs-lookup"><span data-stu-id="01dff-173">It also retries to locate the actor in the cases of communication failures and failovers.</span></span> <span data-ttu-id="01dff-174">Par conséquent, la remise des messages présente les caractéristiques suivantes :</span><span class="sxs-lookup"><span data-stu-id="01dff-174">As a result, message delivery has the following characteristics:</span></span>

* <span data-ttu-id="01dff-175">La remise de messages est conseillée.</span><span class="sxs-lookup"><span data-stu-id="01dff-175">Message delivery is best effort.</span></span>
* <span data-ttu-id="01dff-176">Les acteurs peuvent recevoir des messages en double provenant du même client.</span><span class="sxs-lookup"><span data-stu-id="01dff-176">Actors may receive duplicate messages from the same client.</span></span>

### <a name="concurrency"></a><span data-ttu-id="01dff-177">Accès concurrentiel</span><span class="sxs-lookup"><span data-stu-id="01dff-177">Concurrency</span></span>
<span data-ttu-id="01dff-178">Le runtime Reliable Actors fournit un modèle d’accès en alternance simple pour accéder aux méthodes d’acteur.</span><span class="sxs-lookup"><span data-stu-id="01dff-178">The Reliable Actors runtime provides a simple turn-based access model for accessing actor methods.</span></span> <span data-ttu-id="01dff-179">Cela signifie qu’un seul thread peut être actif à tout moment à l’intérieur du code d’un objet d’acteur.</span><span class="sxs-lookup"><span data-stu-id="01dff-179">This means that no more than one thread can be active inside an actor object's code at any time.</span></span> <span data-ttu-id="01dff-180">L’accès en alternance simplifie considérablement l’exécution de systèmes simultanés dans la mesure où aucun mécanisme de synchronisation n’est nécessaire pour accéder aux données.</span><span class="sxs-lookup"><span data-stu-id="01dff-180">Turn-based access greatly simplifies concurrent systems as there is no need for synchronization mechanisms for data access.</span></span> <span data-ttu-id="01dff-181">Cela signifie également que les systèmes doivent être conçus en tenant tout particulièrement compte de la nature de l’accès monothread de chaque instance d’acteur.</span><span class="sxs-lookup"><span data-stu-id="01dff-181">It also means systems must be designed with special considerations for the single-threaded access nature of each actor instance.</span></span>

* <span data-ttu-id="01dff-182">Une instance unique d’acteur ne peut pas traiter plusieurs demandes à la fois.</span><span class="sxs-lookup"><span data-stu-id="01dff-182">A single actor instance cannot process more than one request at a time.</span></span> <span data-ttu-id="01dff-183">Une instance d’acteur peut provoquer un goulot d’étranglement au niveau du débit si elle est prévue pour gérer des demandes simultanées.</span><span class="sxs-lookup"><span data-stu-id="01dff-183">An actor instance can cause a throughput bottleneck if it is expected to handle concurrent requests.</span></span>
* <span data-ttu-id="01dff-184">Les acteurs peuvent se bloquer mutuellement s’il existe une demande circulaire entre deux acteurs alors qu’une demande externe est apportée à l’un des acteurs simultanément.</span><span class="sxs-lookup"><span data-stu-id="01dff-184">Actors can deadlock on each other if there is a circular request between two actors while an external request is made to one of the actors simultaneously.</span></span> <span data-ttu-id="01dff-185">Le runtime de l’acteur expirera automatiquement lors des appels de l’acteur et lèvera une exception à l’appelant afin d’interrompre toute situation de blocage potentielle.</span><span class="sxs-lookup"><span data-stu-id="01dff-185">The actor runtime will automatically time out on actor calls and throw an exception to the caller to interrupt possible deadlock situations.</span></span>

![Communication Reliable Actors][3]

#### <a name="turn-based-access"></a><span data-ttu-id="01dff-187">Accès en alternance</span><span class="sxs-lookup"><span data-stu-id="01dff-187">Turn-based access</span></span>
<span data-ttu-id="01dff-188">Un tour consiste en l’exécution complète d’une méthode d’acteur en réponse à une demande d’autres acteurs ou clients, ou l’exécution complète d’un rappel de [minuterie/rappel](service-fabric-reliable-actors-timers-reminders.md) .</span><span class="sxs-lookup"><span data-stu-id="01dff-188">A turn consists of the complete execution of an actor method in response to a request from other actors or clients, or the complete execution of a [timer/reminder](service-fabric-reliable-actors-timers-reminders.md) callback.</span></span> <span data-ttu-id="01dff-189">Bien que ces méthodes et ces rappels soient asynchrones, le runtime Actors ne les entremêle pas.</span><span class="sxs-lookup"><span data-stu-id="01dff-189">Even though these methods and callbacks are asynchronous, the Actors runtime does not interleave them.</span></span> <span data-ttu-id="01dff-190">Un tour doit être totalement terminé avant qu’un nouveau tour soit autorisé.</span><span class="sxs-lookup"><span data-stu-id="01dff-190">A turn must be fully finished before a new turn is allowed.</span></span> <span data-ttu-id="01dff-191">En d’autres termes, une méthode d’acteur ou un rappel de minuterie/rappel en cours d’exécution doit être totalement terminé avant qu’un nouvel appel à une méthode ou qu’un rappel soit autorisé.</span><span class="sxs-lookup"><span data-stu-id="01dff-191">In other words, an actor method or timer/reminder callback that is currently executing must be fully finished before a new call to a method or callback is allowed.</span></span> <span data-ttu-id="01dff-192">Une méthode ou un rappel est considéré terminé si l’exécution a été retournée depuis la méthode ou le rappel et que la tâche retournée par la méthode ou le rappel est terminée.</span><span class="sxs-lookup"><span data-stu-id="01dff-192">A method or callback is considered to have finished if the execution has returned from the method or callback and the task returned by the method or callback has finished.</span></span> <span data-ttu-id="01dff-193">Il est important de souligner que cet accès concurrentiel en alternance est respecté même dans les différents rappels, minuteries et méthodes.</span><span class="sxs-lookup"><span data-stu-id="01dff-193">It is worth emphasizing that turn-based concurrency is respected even across different methods, timers, and callbacks.</span></span>

<span data-ttu-id="01dff-194">Le runtime Actors applique un accès concurrentiel en alternance en acquérant un verrou par acteur au début d'un tour et en le relâchant à la fin du tour.</span><span class="sxs-lookup"><span data-stu-id="01dff-194">The Actors runtime enforces turn-based concurrency by acquiring a per-actor lock at the beginning of a turn and releasing the lock at the end of the turn.</span></span> <span data-ttu-id="01dff-195">Par conséquent, l'accès concurrentiel en alternance est appliqué sur une base par acteur et non entre acteurs.</span><span class="sxs-lookup"><span data-stu-id="01dff-195">Thus, turn-based concurrency is enforced on a per-actor basis and not across actors.</span></span> <span data-ttu-id="01dff-196">Les méthodes d'acteur et les rappels de minuterie/rappel peuvent s'exécuter simultanément pour le compte de différents acteurs.</span><span class="sxs-lookup"><span data-stu-id="01dff-196">Actor methods and timer/reminder callbacks can execute simultaneously on behalf of different actors.</span></span>

<span data-ttu-id="01dff-197">L'exemple suivant illustre les concepts ci-dessus :</span><span class="sxs-lookup"><span data-stu-id="01dff-197">The following example illustrates the above concepts.</span></span> <span data-ttu-id="01dff-198">Prenons l’exemple d’un type d’acteur qui implémente deux méthodes asynchrones (par exemple, *Method1* et *Method2*), une minuterie et un rappel.</span><span class="sxs-lookup"><span data-stu-id="01dff-198">Consider an actor type that implements two asynchronous methods (say, *Method1* and *Method2*), a timer, and a reminder.</span></span> <span data-ttu-id="01dff-199">Le diagramme suivant montre un exemple de chronologie de l’exécution de ces méthodes et rappels pour le compte de deux acteurs (*ActorId1* et *ActorId2*) qui appartiennent à ce type d’acteur.</span><span class="sxs-lookup"><span data-stu-id="01dff-199">The diagram below shows an example of a timeline for the execution of these methods and callbacks on behalf of two actors (*ActorId1* and *ActorId2*) that belong to this actor type.</span></span>

![Accès et accès concurrentiel en alternance avec le runtime Reliable Actors][1]

<span data-ttu-id="01dff-201">Ce diagramme suit les conventions suivantes :</span><span class="sxs-lookup"><span data-stu-id="01dff-201">This diagram follows these conventions:</span></span>

* <span data-ttu-id="01dff-202">Chaque ligne verticale indique le flux logique d'exécution d'une méthode ou d'un rappel pour le compte d'un acteur spécifique.</span><span class="sxs-lookup"><span data-stu-id="01dff-202">Each vertical line shows the logical flow of execution of a method or a callback on behalf of a particular actor.</span></span>
* <span data-ttu-id="01dff-203">Les événements marqués sur chaque ligne verticale se produisent dans l’ordre chronologique, les nouveaux événements se trouvant en dessous des plus anciens.</span><span class="sxs-lookup"><span data-stu-id="01dff-203">The events marked on each vertical line occur in chronological order, with newer events occurring below older ones.</span></span>
* <span data-ttu-id="01dff-204">Différentes couleurs sont utilisées pour les chronologies des différents acteurs.</span><span class="sxs-lookup"><span data-stu-id="01dff-204">Different colors are used for timelines corresponding to different actors.</span></span>
* <span data-ttu-id="01dff-205">La mise en surbrillance est utilisée pour indiquer la durée pendant laquelle le verrou par acteur est maintenu pour le compte d'une méthode ou d'un rappel.</span><span class="sxs-lookup"><span data-stu-id="01dff-205">Highlighting is used to indicate the duration for which the per-actor lock is held on behalf of a method or callback.</span></span>

<span data-ttu-id="01dff-206">Quelques points importants à prendre en compte :</span><span class="sxs-lookup"><span data-stu-id="01dff-206">Some important points to consider:</span></span>

* <span data-ttu-id="01dff-207">Pendant que *Method1* s’exécute pour le compte *d’ActorId2* en réponse à la demande du client *xyz789*, une autre demande du client (*abc123*) arrive et nécessite également que *Method1* soit exécutée par *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="01dff-207">While *Method1* is executing on behalf of *ActorId2* in response to client request *xyz789*, another client request (*abc123*) arrives that also requires *Method1* to be executed by *ActorId2*.</span></span> <span data-ttu-id="01dff-208">Toutefois, la seconde exécution de *Method1* ne commence pas tant que l’exécution précédente n’est pas terminée.</span><span class="sxs-lookup"><span data-stu-id="01dff-208">However, the second execution of *Method1* does not begin until the prior execution has finished.</span></span> <span data-ttu-id="01dff-209">De même, un rappel enregistré par *ActorId2* se déclenche lors de l'exécution de *Method1* en réponse à la demande du client *xyz789*.</span><span class="sxs-lookup"><span data-stu-id="01dff-209">Similarly, a reminder registered by *ActorId2* fires while *Method1* is being executed in response to client request *xyz789*.</span></span> <span data-ttu-id="01dff-210">Le rappel de rappel est exécuté uniquement une fois que les deux exécutions de *Method1* sont terminées.</span><span class="sxs-lookup"><span data-stu-id="01dff-210">The reminder callback is executed only after both executions of *Method1* are complete.</span></span> <span data-ttu-id="01dff-211">Cela s'explique par l'application de l'accès concurrentiel en alternance à *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="01dff-211">All of this is due to turn-based concurrency being enforced for *ActorId2*.</span></span>
* <span data-ttu-id="01dff-212">De même, l’accès concurrentiel en alternance est également appliqué à *ActorId1*, comme l’illustrent l’exécution en série de *Method1* / *Method2* et le rappel de minuterie pour le compte *d’ActorId1*.</span><span class="sxs-lookup"><span data-stu-id="01dff-212">Similarly, turn-based concurrency is also enforced for *ActorId1*, as demonstrated by the execution of *Method1*, *Method2*, and the timer callback on behalf of *ActorId1* happening in a serial fashion.</span></span>
* <span data-ttu-id="01dff-213">L'exécution de *Method1* pour le compte *d'ActorId1* se chevauche avec son exécution pour le compte *d'ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="01dff-213">Execution of *Method1* on behalf of *ActorId1* overlaps with its execution on behalf of *ActorId2*.</span></span> <span data-ttu-id="01dff-214">En effet, l’accès concurrentiel en alternance est appliqué uniquement au sein d’un acteur et non entre les acteurs.</span><span class="sxs-lookup"><span data-stu-id="01dff-214">This is because turn-based concurrency is enforced only within an actor and not across actors.</span></span>
* <span data-ttu-id="01dff-215">Dans certaines exécutions de méthode/de rappel, le `Task`(C#)/`CompletableFuture` (Java) retourné par la méthode/le rappel se termine après le retour de la méthode.</span><span class="sxs-lookup"><span data-stu-id="01dff-215">In some of the method/callback executions, the `Task`(C#) / `CompletableFuture`(Java) returned by the method/callback finishes after the method returns.</span></span> <span data-ttu-id="01dff-216">Dans d’autres exécutions, l’opération asynchrone est déjà terminée au moment du retour de la méthode/du rappel.</span><span class="sxs-lookup"><span data-stu-id="01dff-216">In some others, the asynchronous operation has already finished by the time the method/callback returns.</span></span> <span data-ttu-id="01dff-217">Dans les deux cas, le verrou par acteur n’est relâché qu’après le retour de la méthode/du rappel et la fin de l’opération asynchrone.</span><span class="sxs-lookup"><span data-stu-id="01dff-217">In both cases, the per-actor lock is released only after both the method/callback returns and the asynchronous operation finishes.</span></span>

#### <a name="reentrancy"></a><span data-ttu-id="01dff-218">Réentrance</span><span class="sxs-lookup"><span data-stu-id="01dff-218">Reentrancy</span></span>
<span data-ttu-id="01dff-219">Le runtime Actors autorise la réentrance par défaut.</span><span class="sxs-lookup"><span data-stu-id="01dff-219">The Actors runtime allows reentrancy by default.</span></span> <span data-ttu-id="01dff-220">Cela signifie que, si une méthode de *l’acteur A* appelle une méthode sur *l’acteur B*, qui appelle à son tour une autre méthode sur *l’acteur A*, cette méthode peut s’exécuter.</span><span class="sxs-lookup"><span data-stu-id="01dff-220">This means that if an actor method of *Actor A* calls a method on *Actor B*, which in turn calls another method on *Actor A*, that method is allowed to run.</span></span> <span data-ttu-id="01dff-221">En effet, elle fait partie du même contexte de chaîne d’appel logique.</span><span class="sxs-lookup"><span data-stu-id="01dff-221">This is because it is part of the same logical call-chain context.</span></span> <span data-ttu-id="01dff-222">Tous les appels du minuteur et du rappel démarrent avec le nouveau contexte d'appel logique.</span><span class="sxs-lookup"><span data-stu-id="01dff-222">All timer and reminder calls start with the new logical call context.</span></span> <span data-ttu-id="01dff-223">Pour plus d’informations, consultez [Réentrance Reliable Actors](service-fabric-reliable-actors-reentrancy.md) .</span><span class="sxs-lookup"><span data-stu-id="01dff-223">See the [Reliable Actors reentrancy](service-fabric-reliable-actors-reentrancy.md) for more details.</span></span>

#### <a name="scope-of-concurrency-guarantees"></a><span data-ttu-id="01dff-224">Étendue des garanties d'accès concurrentiel</span><span class="sxs-lookup"><span data-stu-id="01dff-224">Scope of concurrency guarantees</span></span>
<span data-ttu-id="01dff-225">Le runtime Actors fournit ces garanties d'accès concurrentiel dans les situations où il contrôle l'appel de ces méthodes.</span><span class="sxs-lookup"><span data-stu-id="01dff-225">The Actors runtime provides these concurrency guarantees in situations where it controls the invocation of these methods.</span></span> <span data-ttu-id="01dff-226">Par exemple, il fournit ces garanties pour les appels de méthode effectués en réponse à une demande du client, ainsi que pour les rappels de minuterie et de rappel.</span><span class="sxs-lookup"><span data-stu-id="01dff-226">For example, it provides these guarantees for the method invocations that are done in response to a client request, as well as for timer and reminder callbacks.</span></span> <span data-ttu-id="01dff-227">Toutefois, si le code de l'acteur appelle directement ces méthodes en dehors des mécanismes fournis par le runtime Actors, celui-ci ne peut pas fournir de garanties d'accès concurrentiel.</span><span class="sxs-lookup"><span data-stu-id="01dff-227">However, if the actor code directly invokes these methods outside of the mechanisms provided by the Actors runtime, then the runtime cannot provide any concurrency guarantees.</span></span> <span data-ttu-id="01dff-228">Par exemple, si la méthode est appelée dans le contexte d’une tâche qui n’est pas associée à la tâche retournée par les méthodes d’acteur, le runtime ne peut pas fournir de garantie d’accès concurrentiel.</span><span class="sxs-lookup"><span data-stu-id="01dff-228">For example, if the method is invoked in the context of some task that is not associated with the task returned by the actor methods, then the runtime cannot provide concurrency guarantees.</span></span> <span data-ttu-id="01dff-229">Il en va de même si la méthode est appelée à partir d’un thread créé par l’acteur de son côté.</span><span class="sxs-lookup"><span data-stu-id="01dff-229">If the method is invoked from a thread that the actor creates on its own, then the runtime also cannot provide concurrency guarantees.</span></span> <span data-ttu-id="01dff-230">Ainsi, pour effectuer des opérations d’arrière-plan, les acteurs doivent utiliser les [minuteurs d’acteur et les rappels d’acteur](service-fabric-reliable-actors-timers-reminders.md) , qui respectent l’accès concurrentiel en alternance.</span><span class="sxs-lookup"><span data-stu-id="01dff-230">Therefore, to perform background operations, actors should use [actor timers and actor reminders](service-fabric-reliable-actors-timers-reminders.md) that respect turn-based concurrency.</span></span>

## <a name="next-steps"></a><span data-ttu-id="01dff-231">Étapes suivantes</span><span class="sxs-lookup"><span data-stu-id="01dff-231">Next steps</span></span>
* <span data-ttu-id="01dff-232">Commencez par créer votre premier service Reliable Actors :</span><span class="sxs-lookup"><span data-stu-id="01dff-232">Get started by building your first Reliable Actors service:</span></span>
   * [<span data-ttu-id="01dff-233">Prise en main de Reliable Actors sur .NET</span><span class="sxs-lookup"><span data-stu-id="01dff-233">Getting started with Reliable Actors on .NET</span></span>](service-fabric-reliable-actors-get-started.md)
   * [<span data-ttu-id="01dff-234">Prise en main de Reliable Actors sur Java</span><span class="sxs-lookup"><span data-stu-id="01dff-234">Getting started with Reliable Actors on Java</span></span>](service-fabric-reliable-actors-get-started-java.md)

<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-introduction/concurrency.png
[2]: ./media/service-fabric-reliable-actors-introduction/distribution.png
[3]: ./media/service-fabric-reliable-actors-introduction/actor-communication.png
