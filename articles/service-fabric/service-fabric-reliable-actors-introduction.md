---
title: "aaaService vue d’ensemble des acteurs fiable Fabric | Documents Microsoft"
description: "Modèle de la programmation de l’infrastructure de Service Reliable Actors toohello de présentation."
services: service-fabric
documentationcenter: .net
author: vturecek
manager: timlt
editor: 
ms.assetid: 7fdad07f-f2d6-4c74-804d-e0d56131f060
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/29/2017
ms.author: vturecek
ms.openlocfilehash: ab010cbf936c6cf723b3d453ef95a9bf51f76c95
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/06/2017
---
# <a name="introduction-tooservice-fabric-reliable-actors"></a><span data-ttu-id="a4858-103">Introduction tooService infrastructure Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="a4858-103">Introduction tooService Fabric Reliable Actors</span></span>
<span data-ttu-id="a4858-104">Reliable Actors est une infrastructure d’application de Service Fabric selon hello [Virtual Actor](http://research.microsoft.com/en-us/projects/orleans/) modèle.</span><span class="sxs-lookup"><span data-stu-id="a4858-104">Reliable Actors is a Service Fabric application framework based on hello [Virtual Actor](http://research.microsoft.com/en-us/projects/orleans/) pattern.</span></span> <span data-ttu-id="a4858-105">Hello fiable acteurs API fournit un modèle de programmation monothread reposant sur hello l’évolutivité et la fiabilité les garanties fournies par l’infrastructure de Service.</span><span class="sxs-lookup"><span data-stu-id="a4858-105">hello Reliable Actors API provides a single-threaded programming model built on hello scalability and reliability guarantees provided by Service Fabric.</span></span>

## <a name="what-are-actors"></a><span data-ttu-id="a4858-106">Qu’est-ce qu’un « acteur » ?</span><span class="sxs-lookup"><span data-stu-id="a4858-106">What are Actors?</span></span>
<span data-ttu-id="a4858-107">Un acteur est une unité de calcul et d’état indépendante et isolée, associée à une exécution monothread.</span><span class="sxs-lookup"><span data-stu-id="a4858-107">An actor is an isolated, independent unit of compute and state with single-threaded execution.</span></span> <span data-ttu-id="a4858-108">Hello [modèle d’acteur](https://en.wikipedia.org/wiki/Actor_model) est un modèle de calcul pour les systèmes simultanés ou distribuées dans laquelle un grand nombre de ces acteurs peut exécuter simultanément et indépendamment les uns des autres.</span><span class="sxs-lookup"><span data-stu-id="a4858-108">hello [actor pattern](https://en.wikipedia.org/wiki/Actor_model) is a computational model for concurrent or distributed systems in which a large number of these actors can execute simultaneously and independently of each other.</span></span> <span data-ttu-id="a4858-109">Les acteurs peuvent communiquer entre eux et créer d’autres acteurs.</span><span class="sxs-lookup"><span data-stu-id="a4858-109">Actors can communicate with each other and they can create more actors.</span></span>

### <a name="when-toouse-reliable-actors"></a><span data-ttu-id="a4858-110">Lorsque toouse Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="a4858-110">When toouse Reliable Actors</span></span>
<span data-ttu-id="a4858-111">Service Fabric Reliable Actors est une implémentation du modèle de conception d’acteur hello.</span><span class="sxs-lookup"><span data-stu-id="a4858-111">Service Fabric Reliable Actors is an implementation of hello actor design pattern.</span></span> <span data-ttu-id="a4858-112">Comme avec n’importe quel modèle de conception de logiciels, décision hello se toouse un modèle spécifique est effectué en se basant sur ou non un logiciel de conception problème adapté à un modèle de hello.</span><span class="sxs-lookup"><span data-stu-id="a4858-112">As with any software design pattern, hello decision whether toouse a specific pattern is made based on whether or not a software design problem fits hello pattern.</span></span>

<span data-ttu-id="a4858-113">Bien que le modèle de conception hello acteur peut être un bon tooa adapté de problèmes de systèmes distribués et scénarios, tenez compte des contraintes de hello de modèle de hello et d’implémentation de framework hello que doivent figurer.</span><span class="sxs-lookup"><span data-stu-id="a4858-113">Although hello actor design pattern can be a good fit tooa number of distributed systems problems and scenarios, careful consideration of hello constraints of hello pattern and hello framework implementing it must be made.</span></span> <span data-ttu-id="a4858-114">En règle générale, envisagez hello acteur modèle toomodel votre scénario ou un problème si :</span><span class="sxs-lookup"><span data-stu-id="a4858-114">As general guidance, consider hello actor pattern toomodel your problem or scenario if:</span></span>

* <span data-ttu-id="a4858-115">Votre espace de problème implique un nombre élevé (plusieurs milliers) de petites unités d’état et de logique indépendantes et isolées.</span><span class="sxs-lookup"><span data-stu-id="a4858-115">Your problem space involves a large number (thousands or more) of small, independent, and isolated units of state and logic.</span></span>
* <span data-ttu-id="a4858-116">Vous souhaitez toowork avec des objets à thread unique qui ne nécessitent pas d’interaction significative à partir des composants externes, y compris l’interrogation d’état sur un ensemble d’intervenants.</span><span class="sxs-lookup"><span data-stu-id="a4858-116">You want toowork with single-threaded objects that do not require significant interaction from external components, including querying state across a set of actors.</span></span>
* <span data-ttu-id="a4858-117">Vos instances d’acteurs ne bloquent pas les appelants avec des retards inattendus en exécutant des opérations d’E/S.</span><span class="sxs-lookup"><span data-stu-id="a4858-117">Your actor instances won't block callers with unpredictable delays by issuing I/O operations.</span></span>

## <a name="actors-in-service-fabric"></a><span data-ttu-id="a4858-118">Le rôle des acteurs dans Service Fabric</span><span class="sxs-lookup"><span data-stu-id="a4858-118">Actors in Service Fabric</span></span>
<span data-ttu-id="a4858-119">Dans l’infrastructure de Service, les acteurs sont implémentées dans le framework Reliable Actors de hello : une infrastructure d’application de modèle-basé sur acteur construite sur [Service des Services de Fabric fiables](service-fabric-reliable-services-introduction.md).</span><span class="sxs-lookup"><span data-stu-id="a4858-119">In Service Fabric, actors are implemented in hello Reliable Actors framework: An actor-pattern-based application framework built on top of [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md).</span></span> <span data-ttu-id="a4858-120">Chaque service Reliable Actor que vous écrivez correspond en fait à une instance Reliable Service partitionnée avec état.</span><span class="sxs-lookup"><span data-stu-id="a4858-120">Each Reliable Actor service you write is actually a partitioned, stateful Reliable Service.</span></span>

<span data-ttu-id="a4858-121">Chaque acteur est définie comme une instance d’un type d’acteur, toohello identiques façon un objet .NET est une instance d’un type .NET.</span><span class="sxs-lookup"><span data-stu-id="a4858-121">Every actor is defined as an instance of an actor type, identical toohello way a .NET object is an instance of a .NET type.</span></span> <span data-ttu-id="a4858-122">Par exemple, il peut y avoir un type d’acteur qui implémente les fonctionnalités de hello d’une calculatrice, et il peut y avoir de nombreux acteurs de ce type qui sont réparties sur différents nœuds sur un cluster.</span><span class="sxs-lookup"><span data-stu-id="a4858-122">For example, there may be an actor type that implements hello functionality of a calculator and there could be many actors of that type that are distributed on various nodes across a cluster.</span></span> <span data-ttu-id="a4858-123">Chaque acteur de ce type est identifié de façon unique par un ID d'acteur.</span><span class="sxs-lookup"><span data-stu-id="a4858-123">Each such actor is uniquely identified by an actor ID.</span></span>

### <a name="actor-lifetime"></a><span data-ttu-id="a4858-124">Durée de vie de l’acteur</span><span class="sxs-lookup"><span data-stu-id="a4858-124">Actor Lifetime</span></span>
<span data-ttu-id="a4858-125">Les acteurs de l’infrastructure de service sont virtuelles, ce qui signifie que leur durée de vie est pas de représentation en mémoire de tootheir liée.</span><span class="sxs-lookup"><span data-stu-id="a4858-125">Service Fabric actors are virtual, meaning that their lifetime is not tied tootheir in-memory representation.</span></span> <span data-ttu-id="a4858-126">Par conséquent, ils n’avez pas besoin de toobe explicitement créé ou détruit.</span><span class="sxs-lookup"><span data-stu-id="a4858-126">As a result, they do not need toobe explicitly created or destroyed.</span></span> <span data-ttu-id="a4858-127">Hello Reliable Actors runtime active automatiquement une hello acteur première fois qu’il reçoit une demande pour cet ID d’acteur.</span><span class="sxs-lookup"><span data-stu-id="a4858-127">hello Reliable Actors runtime automatically activates an actor hello first time it receives a request for that actor ID.</span></span> <span data-ttu-id="a4858-128">Si un intervenant n’est pas utilisé pour une période donnée, hello Reliable Actors runtime garbage-collecte les objets de hello en mémoire.</span><span class="sxs-lookup"><span data-stu-id="a4858-128">If an actor is not used for a period of time, hello Reliable Actors runtime garbage-collects hello in-memory object.</span></span> <span data-ttu-id="a4858-129">Il gère également les connaissances d’existence de hello acteur devez toobe réactivé ultérieurement.</span><span class="sxs-lookup"><span data-stu-id="a4858-129">It will also maintain knowledge of hello actor's existence should it need toobe reactivated later.</span></span> <span data-ttu-id="a4858-130">Pour plus de détails, consultez la page [Cycle de vie des acteurs et Garbage Collection](service-fabric-reliable-actors-lifecycle.md).</span><span class="sxs-lookup"><span data-stu-id="a4858-130">For more details, see [Actor lifecycle and garbage collection](service-fabric-reliable-actors-lifecycle.md).</span></span>

<span data-ttu-id="a4858-131">Cette abstraction de la durée de vie acteur virtuel exécute certaines restrictions à la suite de modèle d’acteur virtuel hello et en fait hello mise en œuvre Reliable Actors dévie parfois à partir de ce modèle.</span><span class="sxs-lookup"><span data-stu-id="a4858-131">This virtual actor lifetime abstraction carries some caveats as a result of hello virtual actor model, and in fact hello Reliable Actors implementation deviates at times from this model.</span></span>

* <span data-ttu-id="a4858-132">Un acteur est activé automatiquement (ce qui provoque un acteur toobe objet construit) hello la première fois, un message est envoyé à tooits acteur ID.</span><span class="sxs-lookup"><span data-stu-id="a4858-132">An actor is automatically activated (causing an actor object toobe constructed) hello first time a message is sent tooits actor ID.</span></span> <span data-ttu-id="a4858-133">Après un certain temps, hello acteur l’objet est le garbage collecté.</span><span class="sxs-lookup"><span data-stu-id="a4858-133">After some period of time, hello actor object is garbage collected.</span></span> <span data-ttu-id="a4858-134">Bonjour futur, à l’aide de l’ID d’acteur hello, entraîne un acteur nouvelle toobe objet construit.</span><span class="sxs-lookup"><span data-stu-id="a4858-134">In hello future, using hello actor ID again, causes a new actor object toobe constructed.</span></span> <span data-ttu-id="a4858-135">État d’un acteur est supérieure à celle durée de vie de l’objet hello lorsque stockées dans le Gestionnaire d’état hello.</span><span class="sxs-lookup"><span data-stu-id="a4858-135">An actor's state outlives hello object's lifetime when stored in hello state manager.</span></span>
* <span data-ttu-id="a4858-136">Le déclenchement d’une méthode d’acteur pour un ID d’acteur donné aura pour effet d’activer cet acteur.</span><span class="sxs-lookup"><span data-stu-id="a4858-136">Calling any actor method for an actor ID activates that actor.</span></span> <span data-ttu-id="a4858-137">Pour cette raison, les types d’acteur ont leur constructeur appelé implicitement par le runtime de hello.</span><span class="sxs-lookup"><span data-stu-id="a4858-137">For this reason, actor types have their constructor called implicitly by hello runtime.</span></span> <span data-ttu-id="a4858-138">Par conséquent, le code client ne peut pas passer au constructeur du type de paramètres toohello acteur, bien que les paramètres peuvent être passés constructeur de toohello acteur par service hello lui-même.</span><span class="sxs-lookup"><span data-stu-id="a4858-138">Therefore, client code cannot pass parameters toohello actor type's constructor, although parameters may be passed toohello actor's constructor by hello service itself.</span></span> <span data-ttu-id="a4858-139">résultat de Hello est que les acteurs peuvent être construites dans un état partiellement initialisée par heure hello, d’autres méthodes sont appelées si acteur de hello requiert des paramètres de l’initialisation à partir du client de hello.</span><span class="sxs-lookup"><span data-stu-id="a4858-139">hello result is that actors may be constructed in a partially-initialized state by hello time other methods are called on it, if hello actor requires initialization parameters from hello client.</span></span> <span data-ttu-id="a4858-140">Il n’existe aucun point d’entrée unique pour l’activation d’un acteur à partir du client de hello hello.</span><span class="sxs-lookup"><span data-stu-id="a4858-140">There is no single entry point for hello activation of an actor from hello client.</span></span>
* <span data-ttu-id="a4858-141">Bien que Reliable Actors créent implicitement des objets de l’acteur. vous n’avez pas hello capacité tooexplicitly supprimer un acteur et son état.</span><span class="sxs-lookup"><span data-stu-id="a4858-141">Although Reliable Actors implicitly create actor objects; you do have hello ability tooexplicitly delete an actor and its state.</span></span>

### <a name="distribution-and-failover"></a><span data-ttu-id="a4858-142">Distribution et basculement</span><span class="sxs-lookup"><span data-stu-id="a4858-142">Distribution and failover</span></span>
<span data-ttu-id="a4858-143">tooprovide évolutivité et la fiabilité, Service Fabric distribue les acteurs dans l’ensemble de cluster de hello et automatiquement les transfère à partir des nœuds ayant échoué toohealthy celles en fonction des besoins.</span><span class="sxs-lookup"><span data-stu-id="a4858-143">tooprovide scalability and reliability, Service Fabric distributes actors throughout hello cluster and automatically migrates them from failed nodes toohealthy ones as required.</span></span> <span data-ttu-id="a4858-144">Il s’agit ici d’une abstraction sur une instance [Reliable Service partitionnée avec état](service-fabric-concepts-partitioning.md).</span><span class="sxs-lookup"><span data-stu-id="a4858-144">This is an abstraction over a [partitioned, stateful Reliable Service](service-fabric-concepts-partitioning.md).</span></span> <span data-ttu-id="a4858-145">Distribution, d’évolutivité, de fiabilité et de basculement automatique sont toutes fournies fait hello acteurs sont en cours d’exécution à l’intérieur d’un Service fiable sans état appelée hello *acteur Service*.</span><span class="sxs-lookup"><span data-stu-id="a4858-145">Distribution, scalability, reliability, and automatic failover are all provided by virtue of hello fact that actors are running inside a stateful Reliable Service called hello *Actor Service*.</span></span>

<span data-ttu-id="a4858-146">Acteurs sont répartis entre des partitions hello Hello acteur Service, et ces partitions sont réparties entre les nœuds de hello dans un cluster Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="a4858-146">Actors are distributed across hello partitions of hello Actor Service, and those partitions are distributed across hello nodes in a Service Fabric cluster.</span></span> <span data-ttu-id="a4858-147">Chaque partition de service contient un ensemble d’acteurs.</span><span class="sxs-lookup"><span data-stu-id="a4858-147">Each service partition contains a set of actors.</span></span> <span data-ttu-id="a4858-148">L’infrastructure de service gère la distribution et le basculement de partitions de service hello.</span><span class="sxs-lookup"><span data-stu-id="a4858-148">Service Fabric manages distribution and failover of hello service partitions.</span></span>

<span data-ttu-id="a4858-149">Par exemple, un service d’acteur avec neuf partitions déployée toothree nœuds à l’aide de placement de partition acteur hello par défaut est distribuées doit être remplacé :</span><span class="sxs-lookup"><span data-stu-id="a4858-149">For example, an actor service with nine partitions deployed toothree nodes using hello default actor partition placement would be distributed thusly:</span></span>

![Distribution Reliable Actors][2]

<span data-ttu-id="a4858-151">Hello acteur Framework gère les paramètres de plage des schéma et clé de partition pour vous.</span><span class="sxs-lookup"><span data-stu-id="a4858-151">hello Actor Framework manages partition scheme and key range settings for you.</span></span> <span data-ttu-id="a4858-152">Bien que cela simplifie certains choix, certains aspects méritent d’être pris en compte :</span><span class="sxs-lookup"><span data-stu-id="a4858-152">This simplifies some choices but also carries some consideration:</span></span>

* <span data-ttu-id="a4858-153">Services fiables vous permet de toochoose un schéma de partitionnement, plage de clés (lorsque vous utilisez une plage de schéma de partitionnement), et le nombre de partition.</span><span class="sxs-lookup"><span data-stu-id="a4858-153">Reliable Services allows you toochoose a partitioning scheme, key range (when using a range partitioning scheme), and partition count.</span></span> <span data-ttu-id="a4858-154">Reliable Actors est le schéma de partitionnement de plage toohello restreint (schéma de Int64 uniforme hello) et vous demande d’utiliser complète plage de clés Int64 hello.</span><span class="sxs-lookup"><span data-stu-id="a4858-154">Reliable Actors is restricted toohello range partitioning scheme (hello uniform Int64 scheme) and requires you use hello full Int64 key range.</span></span>
* <span data-ttu-id="a4858-155">Par défaut, les acteurs sont placés aléatoirement dans les partitions, ce qui entraîne une distribution uniforme.</span><span class="sxs-lookup"><span data-stu-id="a4858-155">By default, actors are randomly placed into partitions resulting in uniform distribution.</span></span>
* <span data-ttu-id="a4858-156">Du fait de ce placement aléatoire, il faudra vraisemblablement s’attendre à ce que les opérations d’acteur requièrent systématiquement une communication réseau, y compris la sérialisation et la désérialisation des données d’appel de méthode, ce qui implique un effet de latence et une surcharge.</span><span class="sxs-lookup"><span data-stu-id="a4858-156">Because actors are randomly placed, it should be expected that actor operations will always require network communication, including serialization and deserialization of method call data, incurring latency and overhead.</span></span>
* <span data-ttu-id="a4858-157">Dans les scénarios avancés, il est placement de partition d’acteur toocontrol possible à l’aide de l’acteur Int64 ID mapper les partitions toospecific.</span><span class="sxs-lookup"><span data-stu-id="a4858-157">In advanced scenarios, it is possible toocontrol actor partition placement by using Int64 actor IDs that map toospecific partitions.</span></span> <span data-ttu-id="a4858-158">Toutefois, cette opération peut entraîner une répartition déséquilibrée des acteurs sur les différentes partitions.</span><span class="sxs-lookup"><span data-stu-id="a4858-158">However, doing so can result in an unbalanced distribution of actors across partitions.</span></span>

<span data-ttu-id="a4858-159">Pour plus d’informations sur la façon dont les services d’acteur sont partitionnées, consultez trop[concepts de partitionnement pour les acteurs](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span><span class="sxs-lookup"><span data-stu-id="a4858-159">For more information on how actor services are partitioned, refer too[partitioning concepts for actors](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span></span>

### <a name="actor-communication"></a><span data-ttu-id="a4858-160">Communication d’acteur</span><span class="sxs-lookup"><span data-stu-id="a4858-160">Actor communication</span></span>
<span data-ttu-id="a4858-161">Interactions d’acteur sont définies dans une interface qui est partagée par acteur hello qui implémente l’interface de hello et client hello qui obtient un proxy acteur tooan via hello même interface.</span><span class="sxs-lookup"><span data-stu-id="a4858-161">Actor interactions are defined in an interface that is shared by hello actor that implements hello interface, and hello client that gets a proxy tooan actor via hello same interface.</span></span> <span data-ttu-id="a4858-162">Étant donné que cette interface est utilisée tooinvoke acteur méthodes en mode asynchrone, toutes les méthodes sur l’interface de hello doivent être retournant des tâches.</span><span class="sxs-lookup"><span data-stu-id="a4858-162">Because this interface is used tooinvoke actor methods asynchronously, every method on hello interface must be Task-returning.</span></span>

<span data-ttu-id="a4858-163">Appels de méthode et leurs réponses ultime demandes réseau entre le cluster de hello, c’est le cas hello arguments hello résultat et des tâches hello qu’elles renvoient doivent être sérialisables par la plateforme de hello.</span><span class="sxs-lookup"><span data-stu-id="a4858-163">Method invocations and their responses ultimately result in network requests across hello cluster, so hello arguments and hello result types of hello tasks that they return must be serializable by hello platform.</span></span> <span data-ttu-id="a4858-164">En particulier, ils doivent être [sérialisables en contrat de données](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="a4858-164">In particular, they must be [data contract serializable](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span></span>

#### <a name="hello-actor-proxy"></a><span data-ttu-id="a4858-165">proxy d’acteur Hello</span><span class="sxs-lookup"><span data-stu-id="a4858-165">hello actor proxy</span></span>
<span data-ttu-id="a4858-166">API du client Reliable Actors Hello assure la communication entre une instance de l’acteur et un client de l’acteur.</span><span class="sxs-lookup"><span data-stu-id="a4858-166">hello Reliable Actors client API provides communication between an actor instance and an actor client.</span></span> <span data-ttu-id="a4858-167">toocommunicate avec un acteur, un client crée un objet proxy acteur qui implémente l’interface d’acteur hello.</span><span class="sxs-lookup"><span data-stu-id="a4858-167">toocommunicate with an actor, a client creates an actor proxy object that implements hello actor interface.</span></span> <span data-ttu-id="a4858-168">client de Hello interagit avec l’acteur de hello en appelant les méthodes sur l’objet de proxy hello.</span><span class="sxs-lookup"><span data-stu-id="a4858-168">hello client interacts with hello actor by invoking methods on hello proxy object.</span></span> <span data-ttu-id="a4858-169">proxy d’acteur de Hello peut être utilisé pour la communication client à acteur et acteur à acteur.</span><span class="sxs-lookup"><span data-stu-id="a4858-169">hello actor proxy can be used for client-to-actor and actor-to-actor communication.</span></span>

```csharp
// Create a randomly distributed actor ID
ActorId actorId = ActorId.CreateRandom();

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
IMyActor myActor = ActorProxy.Create<IMyActor>(actorId, new Uri("fabric:/MyApp/MyActorService"));

// This will invoke a method on hello actor. If an actor with hello given ID does not exist, it will be activated by this method call.
await myActor.DoWorkAsync();
```

```java
// Create actor ID with some name
ActorId actorId = new ActorId("Actor1");

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
MyActor myActor = ActorProxyBase.create(actorId, new URI("fabric:/MyApp/MyActorService"), MyActor.class);

// This will invoke a method on hello actor. If an actor with hello given ID does not exist, it will be activated by this method call.
myActor.DoWorkAsync().get();
```


<span data-ttu-id="a4858-170">Notez que deux hello deux informations utilisées objet de proxy toocreate hello acteur sont l’ID d’acteur hello et le nom de l’application hello.</span><span class="sxs-lookup"><span data-stu-id="a4858-170">Note that hello two pieces of information used toocreate hello actor proxy object are hello actor ID and hello application name.</span></span> <span data-ttu-id="a4858-171">ID d’acteur Hello identifie acteur de hello, tandis que le nom de l’application hello identifie hello [application Service Fabric](service-fabric-reliable-actors-platform.md#application-model) où l’acteur de hello est déployé.</span><span class="sxs-lookup"><span data-stu-id="a4858-171">hello actor ID uniquely identifies hello actor, while hello application name identifies hello [Service Fabric application](service-fabric-reliable-actors-platform.md#application-model) where hello actor is deployed.</span></span>

<span data-ttu-id="a4858-172">Hello `ActorProxy`(c#) / `ActorProxyBase`classe (Java) côté client de hello effectue l’acteur de hello toolocate hello résolution nécessaire par ID et ouvrir un canal de communication avec lui.</span><span class="sxs-lookup"><span data-stu-id="a4858-172">hello `ActorProxy`(C#) / `ActorProxyBase`(Java) class on hello client side performs hello necessary resolution toolocate hello actor by ID and open a communication channel with it.</span></span> <span data-ttu-id="a4858-173">Il réessaie également acteur de hello toolocate dans le cas de hello des échecs de communication et les basculements.</span><span class="sxs-lookup"><span data-stu-id="a4858-173">It also retries toolocate hello actor in hello cases of communication failures and failovers.</span></span> <span data-ttu-id="a4858-174">Par conséquent, remise de messages a hello suivant caractéristiques :</span><span class="sxs-lookup"><span data-stu-id="a4858-174">As a result, message delivery has hello following characteristics:</span></span>

* <span data-ttu-id="a4858-175">La remise de messages est conseillée.</span><span class="sxs-lookup"><span data-stu-id="a4858-175">Message delivery is best effort.</span></span>
* <span data-ttu-id="a4858-176">Acteurs peuvent recevoir des messages en double de hello même client.</span><span class="sxs-lookup"><span data-stu-id="a4858-176">Actors may receive duplicate messages from hello same client.</span></span>

### <a name="concurrency"></a><span data-ttu-id="a4858-177">Accès concurrentiel</span><span class="sxs-lookup"><span data-stu-id="a4858-177">Concurrency</span></span>
<span data-ttu-id="a4858-178">Hello Reliable Actors runtime fournit un modèle simple accès de tour pour accéder aux méthodes d’acteur.</span><span class="sxs-lookup"><span data-stu-id="a4858-178">hello Reliable Actors runtime provides a simple turn-based access model for accessing actor methods.</span></span> <span data-ttu-id="a4858-179">Cela signifie qu’un seul thread peut être actif à tout moment à l’intérieur du code d’un objet d’acteur.</span><span class="sxs-lookup"><span data-stu-id="a4858-179">This means that no more than one thread can be active inside an actor object's code at any time.</span></span> <span data-ttu-id="a4858-180">L’accès en alternance simplifie considérablement l’exécution de systèmes simultanés dans la mesure où aucun mécanisme de synchronisation n’est nécessaire pour accéder aux données.</span><span class="sxs-lookup"><span data-stu-id="a4858-180">Turn-based access greatly simplifies concurrent systems as there is no need for synchronization mechanisms for data access.</span></span> <span data-ttu-id="a4858-181">Cela signifie également systèmes doivent être conçues avec des remarques particulières sur la nature de l’accès monothread hello de chaque instance de l’acteur.</span><span class="sxs-lookup"><span data-stu-id="a4858-181">It also means systems must be designed with special considerations for hello single-threaded access nature of each actor instance.</span></span>

* <span data-ttu-id="a4858-182">Une instance unique d’acteur ne peut pas traiter plusieurs demandes à la fois.</span><span class="sxs-lookup"><span data-stu-id="a4858-182">A single actor instance cannot process more than one request at a time.</span></span> <span data-ttu-id="a4858-183">Une instance de l’acteur peut provoquer un goulot d’étranglement de débit s’il s’agit de requêtes simultanées toohandle attendu.</span><span class="sxs-lookup"><span data-stu-id="a4858-183">An actor instance can cause a throughput bottleneck if it is expected toohandle concurrent requests.</span></span>
* <span data-ttu-id="a4858-184">Acteurs se bloquer mutuellement s’il existe une demande circulaire entre les deux intervenants pendant une demande externe est tooone des acteurs de hello simultanément.</span><span class="sxs-lookup"><span data-stu-id="a4858-184">Actors can deadlock on each other if there is a circular request between two actors while an external request is made tooone of hello actors simultaneously.</span></span> <span data-ttu-id="a4858-185">Hello acteur runtime sera automatiquement une fois sur acteur appelle et lever une toointerrupt d’appelant exception toohello une situation de blocage possible.</span><span class="sxs-lookup"><span data-stu-id="a4858-185">hello actor runtime will automatically time out on actor calls and throw an exception toohello caller toointerrupt possible deadlock situations.</span></span>

![Communication Reliable Actors][3]

#### <a name="turn-based-access"></a><span data-ttu-id="a4858-187">Accès en alternance</span><span class="sxs-lookup"><span data-stu-id="a4858-187">Turn-based access</span></span>
<span data-ttu-id="a4858-188">Tour de rôle se compose de terminer l’exécution de hello d’une méthode d’acteur dans tooa demande à partir d’autres acteurs ou les clients, ou l’exécution complète de hello d’un [du minuteur/rappel](service-fabric-reliable-actors-timers-reminders.md) rappel.</span><span class="sxs-lookup"><span data-stu-id="a4858-188">A turn consists of hello complete execution of an actor method in response tooa request from other actors or clients, or hello complete execution of a [timer/reminder](service-fabric-reliable-actors-timers-reminders.md) callback.</span></span> <span data-ttu-id="a4858-189">Bien que ces méthodes et les rappels sont asynchrones, hello acteurs runtime ne pas entrelacer les.</span><span class="sxs-lookup"><span data-stu-id="a4858-189">Even though these methods and callbacks are asynchronous, hello Actors runtime does not interleave them.</span></span> <span data-ttu-id="a4858-190">Un tour doit être totalement terminé avant qu’un nouveau tour soit autorisé.</span><span class="sxs-lookup"><span data-stu-id="a4858-190">A turn must be fully finished before a new turn is allowed.</span></span> <span data-ttu-id="a4858-191">En d’autres termes, un rappel de méthode ou un minuteur/rappel d’acteur en cours d’exécution doit être entièrement terminé avant une nouvelle méthode de tooa d’appel ou de rappel est autorisé.</span><span class="sxs-lookup"><span data-stu-id="a4858-191">In other words, an actor method or timer/reminder callback that is currently executing must be fully finished before a new call tooa method or callback is allowed.</span></span> <span data-ttu-id="a4858-192">Une méthode ou un rappel est considéré comme toohave terminé si l’exécution de hello a retourné à partir de la méthode hello ou la fin de la tâche de rappel et hello retourné par la méthode hello ou un rappel.</span><span class="sxs-lookup"><span data-stu-id="a4858-192">A method or callback is considered toohave finished if hello execution has returned from hello method or callback and hello task returned by hello method or callback has finished.</span></span> <span data-ttu-id="a4858-193">Il est important de souligner que cet accès concurrentiel en alternance est respecté même dans les différents rappels, minuteries et méthodes.</span><span class="sxs-lookup"><span data-stu-id="a4858-193">It is worth emphasizing that turn-based concurrency is respected even across different methods, timers, and callbacks.</span></span>

<span data-ttu-id="a4858-194">Hello acteurs runtime applique à concurrence de tour en obtenant un verrou par acteur au début de hello de tour de rôle et activer la libération de verrou hello à fin hello Hello.</span><span class="sxs-lookup"><span data-stu-id="a4858-194">hello Actors runtime enforces turn-based concurrency by acquiring a per-actor lock at hello beginning of a turn and releasing hello lock at hello end of hello turn.</span></span> <span data-ttu-id="a4858-195">Par conséquent, l'accès concurrentiel en alternance est appliqué sur une base par acteur et non entre acteurs.</span><span class="sxs-lookup"><span data-stu-id="a4858-195">Thus, turn-based concurrency is enforced on a per-actor basis and not across actors.</span></span> <span data-ttu-id="a4858-196">Les méthodes d'acteur et les rappels de minuterie/rappel peuvent s'exécuter simultanément pour le compte de différents acteurs.</span><span class="sxs-lookup"><span data-stu-id="a4858-196">Actor methods and timer/reminder callbacks can execute simultaneously on behalf of different actors.</span></span>

<span data-ttu-id="a4858-197">Hello l’exemple suivant illustre hello au-dessus de concepts.</span><span class="sxs-lookup"><span data-stu-id="a4858-197">hello following example illustrates hello above concepts.</span></span> <span data-ttu-id="a4858-198">Prenons l’exemple d’un type d’acteur qui implémente deux méthodes asynchrones (par exemple, *Method1* et *Method2*), une minuterie et un rappel.</span><span class="sxs-lookup"><span data-stu-id="a4858-198">Consider an actor type that implements two asynchronous methods (say, *Method1* and *Method2*), a timer, and a reminder.</span></span> <span data-ttu-id="a4858-199">diagramme Hello ci-dessous montre un exemple d’une chronologie pour l’exécution de hello de ces méthodes et les rappels pour le compte de deux acteurs (*ActorId1* et *ActorId2*) qui appartiennent à toothis le type d’acteur.</span><span class="sxs-lookup"><span data-stu-id="a4858-199">hello diagram below shows an example of a timeline for hello execution of these methods and callbacks on behalf of two actors (*ActorId1* and *ActorId2*) that belong toothis actor type.</span></span>

![Accès et accès concurrentiel en alternance avec le runtime Reliable Actors][1]

<span data-ttu-id="a4858-201">Ce diagramme suit les conventions suivantes :</span><span class="sxs-lookup"><span data-stu-id="a4858-201">This diagram follows these conventions:</span></span>

* <span data-ttu-id="a4858-202">Chaque ligne verticale indique flux logique de hello de l’exécution d’une méthode ou d’un rappel pour le compte d’un acteur particulier.</span><span class="sxs-lookup"><span data-stu-id="a4858-202">Each vertical line shows hello logical flow of execution of a method or a callback on behalf of a particular actor.</span></span>
* <span data-ttu-id="a4858-203">Hello marqué sur chaque ligne verticale se produisent dans l’ordre chronologique, avec les événements plus récents qui se produisent sous les plus anciens.</span><span class="sxs-lookup"><span data-stu-id="a4858-203">hello events marked on each vertical line occur in chronological order, with newer events occurring below older ones.</span></span>
* <span data-ttu-id="a4858-204">Différentes couleurs sont utilisées pour les chronologies correspondante toodifferent acteurs.</span><span class="sxs-lookup"><span data-stu-id="a4858-204">Different colors are used for timelines corresponding toodifferent actors.</span></span>
* <span data-ttu-id="a4858-205">Mise en surbrillance est la durée de hello tooindicate utilisés pour le hello un verrou par acteur est maintenu pour le compte d’une méthode ou un rappel.</span><span class="sxs-lookup"><span data-stu-id="a4858-205">Highlighting is used tooindicate hello duration for which hello per-actor lock is held on behalf of a method or callback.</span></span>

<span data-ttu-id="a4858-206">Tooconsider de certains points importants suivants :</span><span class="sxs-lookup"><span data-stu-id="a4858-206">Some important points tooconsider:</span></span>

* <span data-ttu-id="a4858-207">Alors que *Method1* est l’exécution de la part de *ActorId2* dans la demande de réponse tooclient *xyz789*, une autre demande de client (*abc123*) arrive et qu’il requiert également *Method1* toobe exécutée par *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="a4858-207">While *Method1* is executing on behalf of *ActorId2* in response tooclient request *xyz789*, another client request (*abc123*) arrives that also requires *Method1* toobe executed by *ActorId2*.</span></span> <span data-ttu-id="a4858-208">Toutefois, hello deuxième exécution de *Method1* ne commence pas jusqu'à la fin de l’exécution préalable de hello.</span><span class="sxs-lookup"><span data-stu-id="a4858-208">However, hello second execution of *Method1* does not begin until hello prior execution has finished.</span></span> <span data-ttu-id="a4858-209">De même, un rappel inscrit par *ActorId2* se déclenche lors de la *Method1* est en cours d’exécution dans la demande de réponse tooclient *xyz789*.</span><span class="sxs-lookup"><span data-stu-id="a4858-209">Similarly, a reminder registered by *ActorId2* fires while *Method1* is being executed in response tooclient request *xyz789*.</span></span> <span data-ttu-id="a4858-210">rappel de rappel Hello est exécuté uniquement après les deux exécutions de *Method1* sont terminées.</span><span class="sxs-lookup"><span data-stu-id="a4858-210">hello reminder callback is executed only after both executions of *Method1* are complete.</span></span> <span data-ttu-id="a4858-211">Tout ceci est dû concurrence tooturn appliquée pour *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="a4858-211">All of this is due tooturn-based concurrency being enforced for *ActorId2*.</span></span>
* <span data-ttu-id="a4858-212">De même, concurrence activer est également appliquée pour *ActorId1*, comme illustré par l’exécution de hello de *Method1*, *méthode2*, et hello du rappel timer de la part de *ActorId1* passe en série.</span><span class="sxs-lookup"><span data-stu-id="a4858-212">Similarly, turn-based concurrency is also enforced for *ActorId1*, as demonstrated by hello execution of *Method1*, *Method2*, and hello timer callback on behalf of *ActorId1* happening in a serial fashion.</span></span>
* <span data-ttu-id="a4858-213">L'exécution de *Method1* pour le compte *d'ActorId1* se chevauche avec son exécution pour le compte *d'ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="a4858-213">Execution of *Method1* on behalf of *ActorId1* overlaps with its execution on behalf of *ActorId2*.</span></span> <span data-ttu-id="a4858-214">En effet, l’accès concurrentiel en alternance est appliqué uniquement au sein d’un acteur et non entre les acteurs.</span><span class="sxs-lookup"><span data-stu-id="a4858-214">This is because turn-based concurrency is enforced only within an actor and not across actors.</span></span>
* <span data-ttu-id="a4858-215">Dans certains des exécutions de méthode/rappel hello, hello `Task`(c#) / `CompletableFuture`(Java) retourné par hello méthode/rappel termine après le retour de la méthode hello.</span><span class="sxs-lookup"><span data-stu-id="a4858-215">In some of hello method/callback executions, hello `Task`(C#) / `CompletableFuture`(Java) returned by hello method/callback finishes after hello method returns.</span></span> <span data-ttu-id="a4858-216">Dans d’autres, opération asynchrone de hello terminée en heure hello hello méthode/rappel retourne.</span><span class="sxs-lookup"><span data-stu-id="a4858-216">In some others, hello asynchronous operation has already finished by hello time hello method/callback returns.</span></span> <span data-ttu-id="a4858-217">Dans les deux cas, un verrou par acteur hello est publié uniquement après les deux produits rappel de la méthode hello retourne et la fin de l’opération asynchrone hello.</span><span class="sxs-lookup"><span data-stu-id="a4858-217">In both cases, hello per-actor lock is released only after both hello method/callback returns and hello asynchronous operation finishes.</span></span>

#### <a name="reentrancy"></a><span data-ttu-id="a4858-218">Réentrance</span><span class="sxs-lookup"><span data-stu-id="a4858-218">Reentrancy</span></span>
<span data-ttu-id="a4858-219">Hello acteurs runtime permet de réentrance par défaut.</span><span class="sxs-lookup"><span data-stu-id="a4858-219">hello Actors runtime allows reentrancy by default.</span></span> <span data-ttu-id="a4858-220">Cela signifie que si une méthode d’acteur de *acteur A* appelle une méthode sur *acteur B*, qui appelle à son tour une autre méthode sur *acteur A*, que méthode est autorisée à toorun.</span><span class="sxs-lookup"><span data-stu-id="a4858-220">This means that if an actor method of *Actor A* calls a method on *Actor B*, which in turn calls another method on *Actor A*, that method is allowed toorun.</span></span> <span data-ttu-id="a4858-221">Il s’agit, car il fait partie de hello même contexte de la chaîne d’appel logique.</span><span class="sxs-lookup"><span data-stu-id="a4858-221">This is because it is part of hello same logical call-chain context.</span></span> <span data-ttu-id="a4858-222">Tous les appels du minuteur et rappel démarrer avec le contexte d’appel logique nouvelle hello.</span><span class="sxs-lookup"><span data-stu-id="a4858-222">All timer and reminder calls start with hello new logical call context.</span></span> <span data-ttu-id="a4858-223">Consultez hello [réentrance de Reliable Actors](service-fabric-reliable-actors-reentrancy.md) pour plus d’informations.</span><span class="sxs-lookup"><span data-stu-id="a4858-223">See hello [Reliable Actors reentrancy](service-fabric-reliable-actors-reentrancy.md) for more details.</span></span>

#### <a name="scope-of-concurrency-guarantees"></a><span data-ttu-id="a4858-224">Étendue des garanties d'accès concurrentiel</span><span class="sxs-lookup"><span data-stu-id="a4858-224">Scope of concurrency guarantees</span></span>
<span data-ttu-id="a4858-225">Hello acteurs runtime fournit ces garanties d’accès concurrentiel dans les situations où il contrôle appel hello de ces méthodes.</span><span class="sxs-lookup"><span data-stu-id="a4858-225">hello Actors runtime provides these concurrency guarantees in situations where it controls hello invocation of these methods.</span></span> <span data-ttu-id="a4858-226">Par exemple, il fournit ces garanties pour les appels de méthode hello qui sont effectuées dans la demande du client tooa réponse, ainsi que pour les rappels timer et de rappel.</span><span class="sxs-lookup"><span data-stu-id="a4858-226">For example, it provides these guarantees for hello method invocations that are done in response tooa client request, as well as for timer and reminder callbacks.</span></span> <span data-ttu-id="a4858-227">Toutefois, si le code d’acteur hello appelle directement ces méthodes en dehors des mécanismes hello fournies par le runtime d’acteurs hello, hello runtime ne peut pas fournir aucune garantie d’accès concurrentiel.</span><span class="sxs-lookup"><span data-stu-id="a4858-227">However, if hello actor code directly invokes these methods outside of hello mechanisms provided by hello Actors runtime, then hello runtime cannot provide any concurrency guarantees.</span></span> <span data-ttu-id="a4858-228">Par exemple, si la méthode hello est appelé dans le contexte de hello d’une tâche qui n’est pas associée avec la tâche hello retourné par les méthodes d’acteur hello, hello runtime ne peut pas fournir d’accès concurrentiel garanties.</span><span class="sxs-lookup"><span data-stu-id="a4858-228">For example, if hello method is invoked in hello context of some task that is not associated with hello task returned by hello actor methods, then hello runtime cannot provide concurrency guarantees.</span></span> <span data-ttu-id="a4858-229">Si la méthode hello est appelé à partir d’un thread acteur hello crée sur son propre, puis hello runtime ne peut pas fournir d’accès concurrentiel garanties.</span><span class="sxs-lookup"><span data-stu-id="a4858-229">If hello method is invoked from a thread that hello actor creates on its own, then hello runtime also cannot provide concurrency guarantees.</span></span> <span data-ttu-id="a4858-230">Par conséquent, les opérations d’arrière-plan tooperform, acteurs doivent utiliser [minuteries d’acteur et les rappels d’acteur](service-fabric-reliable-actors-timers-reminders.md) qui respectent la concurrence basée sur Activer.</span><span class="sxs-lookup"><span data-stu-id="a4858-230">Therefore, tooperform background operations, actors should use [actor timers and actor reminders](service-fabric-reliable-actors-timers-reminders.md) that respect turn-based concurrency.</span></span>

## <a name="next-steps"></a><span data-ttu-id="a4858-231">Étapes suivantes</span><span class="sxs-lookup"><span data-stu-id="a4858-231">Next steps</span></span>
* <span data-ttu-id="a4858-232">Commencez par créer votre premier service Reliable Actors :</span><span class="sxs-lookup"><span data-stu-id="a4858-232">Get started by building your first Reliable Actors service:</span></span>
   * [<span data-ttu-id="a4858-233">Prise en main de Reliable Actors sur .NET</span><span class="sxs-lookup"><span data-stu-id="a4858-233">Getting started with Reliable Actors on .NET</span></span>](service-fabric-reliable-actors-get-started.md)
   * [<span data-ttu-id="a4858-234">Prise en main de Reliable Actors sur Java</span><span class="sxs-lookup"><span data-stu-id="a4858-234">Getting started with Reliable Actors on Java</span></span>](service-fabric-reliable-actors-get-started-java.md)

<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-introduction/concurrency.png
[2]: ./media/service-fabric-reliable-actors-introduction/distribution.png
[3]: ./media/service-fabric-reliable-actors-introduction/actor-communication.png
