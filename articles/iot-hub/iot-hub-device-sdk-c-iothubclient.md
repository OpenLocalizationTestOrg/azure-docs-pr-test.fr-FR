---
title: "Azure IoT device SDK pour C - IoTHubClient | Microsoft Docs"
description: "Guide d’utilisation de la bibliothèque IoTHubClient dans Azure IoT device SDK pour C et de création d’applications d’appareil qui communiquent avec un IoT Hub."
services: iot-hub
documentationcenter: 
author: olivierbloch
manager: timlt
editor: 
ms.assetid: 828cf2bf-999d-4b8a-8a28-c7c901629600
ms.service: iot-hub
ms.devlang: cpp
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 09/06/2016
ms.author: obloch
ms.openlocfilehash: 422d89014511f0d08ba57a893570ff7b253b7bc4
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 07/11/2017
---
# <a name="azure-iot-device-sdk-for-c--more-about-iothubclient"></a><span data-ttu-id="769cf-103">Kit de développement logiciel d’appareil Azure IoT pour C : en savoir plus sur IoTHubClient</span><span class="sxs-lookup"><span data-stu-id="769cf-103">Azure IoT device SDK for C – more about IoTHubClient</span></span>
<span data-ttu-id="769cf-104">Le [premier article](iot-hub-device-sdk-c-intro.md) de cette série a présenté le **Kit de développement logiciel (SDK) d’appareil Azure IoT (Azure IoT device SDK) pour C**. Cet article explique qu’il existe deux couches architecturales dans le Kit de développement logiciel (SDK).</span><span class="sxs-lookup"><span data-stu-id="769cf-104">The [first article](iot-hub-device-sdk-c-intro.md) in this series introduced the **Azure IoT device SDK for C**. That article explained that there are two architectural layers in SDK.</span></span> <span data-ttu-id="769cf-105">À la base se trouve la bibliothèque **IoTHubClient** qui gère directement la communication avec IoT Hub.</span><span class="sxs-lookup"><span data-stu-id="769cf-105">At the base is the **IoTHubClient** library which directly manages communication with IoT Hub.</span></span> <span data-ttu-id="769cf-106">Il existe également la bibliothèque **sérialiseur** , qui s’ajoute à cette dernière pour fournir des services de sérialisation.</span><span class="sxs-lookup"><span data-stu-id="769cf-106">There's also the **serializer** library that builds on top of that to provide serialization services.</span></span> <span data-ttu-id="769cf-107">Dans cet article, vous trouverez des informations supplémentaires sur la bibliothèque **IoTHubClient** .</span><span class="sxs-lookup"><span data-stu-id="769cf-107">In this article we'll provide additional detail on the **IoTHubClient** library.</span></span>

<span data-ttu-id="769cf-108">L’article précédent explique comment utiliser la bibliothèque **IoTHubClient** pour envoyer des événements à IoT Hub et recevoir des messages.</span><span class="sxs-lookup"><span data-stu-id="769cf-108">The previous article described how to use the **IoTHubClient** library to send events to IoT Hub and receive messages.</span></span> <span data-ttu-id="769cf-109">Cet article approfondit le sujet en expliquant comment gérer de manière plus précise le *moment* de l’envoi ou de la réception des données, en vous présentant les **API de niveau inférieur**.</span><span class="sxs-lookup"><span data-stu-id="769cf-109">This article extends that discussion by explaining how to more precisely manage *when* you send and receive data, introducing you to the **lower-level APIs**.</span></span> <span data-ttu-id="769cf-110">Nous expliquerons également comment associer des propriétés à des événements (et les récupérer à partir de messages) en utilisant des fonctions de gestion de propriété de la bibliothèque **IoTHubClient** .</span><span class="sxs-lookup"><span data-stu-id="769cf-110">We'll also explain how to attach properties to events (and retrieve them from messages) using the property handling features in the **IoTHubClient** library.</span></span> <span data-ttu-id="769cf-111">Enfin, nous fournirons des explications supplémentaires sur les différentes façons de gérer les messages reçus d’IoT Hub.</span><span class="sxs-lookup"><span data-stu-id="769cf-111">Finally, we'll provide additional explanation of different ways to handle messages received from IoT Hub.</span></span>

<span data-ttu-id="769cf-112">Cet article conclut en abordant des sujets divers, notamment les informations d’identification des appareils et la manière de modifier le comportement **d’IoTHubClient** par le biais des options de configuration.</span><span class="sxs-lookup"><span data-stu-id="769cf-112">The article concludes by covering a couple of miscellaneous topics, including more about device credentials and how to change the behavior of the **IoTHubClient** through configuration options.</span></span>

<span data-ttu-id="769cf-113">Nous allons utiliser les exemples du Kit de développement logiciel (SDK) **IoTHubClient** pour illustrer ces rubriques.</span><span class="sxs-lookup"><span data-stu-id="769cf-113">We'll use the **IoTHubClient** SDK samples to explain these topics.</span></span> <span data-ttu-id="769cf-114">Si vous souhaitez assurer le suivi, consultez les applications **iothub\_client\_sample\_http** et **iothub\_client\_sample\_amqp** incluses dans le Kit de développement logiciel (SDK) d’appareil Azure IoT (Azure IoT device SDK) pour C. Les détails décrits dans les sections suivantes sont illustrés dans ces exemples.</span><span class="sxs-lookup"><span data-stu-id="769cf-114">If you want to follow along, see the **iothub\_client\_sample\_http** and **iothub\_client\_sample\_amqp** applications that are included in the Azure IoT device SDK for C. Everything described in the following sections is demonstrated in these samples.</span></span>

<span data-ttu-id="769cf-115">Vous trouverez [**Azure IoT device SDK pour C**](https://github.com/Azure/azure-iot-sdk-c) dans le référentiel GitHub. Vous pouvez consulter les détails de l’[API dans Référence de l’API C](https://azure.github.io/azure-iot-sdk-c/index.html).</span><span class="sxs-lookup"><span data-stu-id="769cf-115">You can find the [**Azure IoT device SDK for C**](https://github.com/Azure/azure-iot-sdk-c) GitHub repository and view details of the API in the [C API reference](https://azure.github.io/azure-iot-sdk-c/index.html).</span></span>

## <a name="the-lower-level-apis"></a><span data-ttu-id="769cf-116">API de niveau inférieur</span><span class="sxs-lookup"><span data-stu-id="769cf-116">The lower-level APIs</span></span>
<span data-ttu-id="769cf-117">L’article précédent traitait du fonctionnement de base **d’IotHubClient** dans le contexte de l’application **iothub\_client\_sample\_amqp**.</span><span class="sxs-lookup"><span data-stu-id="769cf-117">The previous article described the basic operation of the **IotHubClient** within the context of the **iothub\_client\_sample\_amqp** application.</span></span> <span data-ttu-id="769cf-118">Par exemple, il expliquait comment initialiser la bibliothèque à l’aide de ce code.</span><span class="sxs-lookup"><span data-stu-id="769cf-118">For example, it explained how to initialize the library using this code.</span></span>

```
IOTHUB_CLIENT_HANDLE iotHubClientHandle;
iotHubClientHandle = IoTHubClient_CreateFromConnectionString(connectionString, AMQP_Protocol);
```

<span data-ttu-id="769cf-119">Il décrivait également la façon d’envoyer des événements à l’aide de cet appel de fonction.</span><span class="sxs-lookup"><span data-stu-id="769cf-119">It also described how to send events using this function call.</span></span>

```
IoTHubClient_SendEventAsync(iotHubClientHandle, message.messageHandle, SendConfirmationCallback, &message);
```

<span data-ttu-id="769cf-120">Cet article expliquait également comment recevoir des messages en enregistrant une fonction de rappel.</span><span class="sxs-lookup"><span data-stu-id="769cf-120">The article also described how to receive messages by registering a callback function.</span></span>

```
int receiveContext = 0;
IoTHubClient_SetMessageCallback(iotHubClientHandle, ReceiveMessageCallback, &receiveContext);
```

<span data-ttu-id="769cf-121">L’article a également montré comment libérer les ressources à l’aide du code suivant.</span><span class="sxs-lookup"><span data-stu-id="769cf-121">The article also showed how to free resources using code such as the following.</span></span>

```
IoTHubClient_Destroy(iotHubClientHandle);
```

<span data-ttu-id="769cf-122">Toutefois il existe des fonctions d’accompagnement pour chacune de ces API :</span><span class="sxs-lookup"><span data-stu-id="769cf-122">However there are companion functions to each of these APIs:</span></span>

* <span data-ttu-id="769cf-123">IoTHubClient\_LL\_CreateFromConnectionString</span><span class="sxs-lookup"><span data-stu-id="769cf-123">IoTHubClient\_LL\_CreateFromConnectionString</span></span>
* <span data-ttu-id="769cf-124">IoTHubClient\_LL\_SendEventAsync</span><span class="sxs-lookup"><span data-stu-id="769cf-124">IoTHubClient\_LL\_SendEventAsync</span></span>
* <span data-ttu-id="769cf-125">IoTHubClient\_LL\_SetMessageCallback</span><span class="sxs-lookup"><span data-stu-id="769cf-125">IoTHubClient\_LL\_SetMessageCallback</span></span>
* <span data-ttu-id="769cf-126">IoTHubClient\_LL\_Destroy</span><span class="sxs-lookup"><span data-stu-id="769cf-126">IoTHubClient\_LL\_Destroy</span></span>

<span data-ttu-id="769cf-127">Ces fonctions incluent toutes « LL » dans le nom d’API.</span><span class="sxs-lookup"><span data-stu-id="769cf-127">These functions all include “LL” in the API name.</span></span> <span data-ttu-id="769cf-128">De plus, les paramètres de chacune de ces fonctions sont identiques aux éléments non-LL équivalents.</span><span class="sxs-lookup"><span data-stu-id="769cf-128">Other than that, the parameters of each of these functions are identical to their non-LL counterparts.</span></span> <span data-ttu-id="769cf-129">Toutefois, le comportement de ces fonctions diffère sur un point important.</span><span class="sxs-lookup"><span data-stu-id="769cf-129">However, the behavior of these functions is different in one important way.</span></span>

<span data-ttu-id="769cf-130">Lorsque vous appelez **IoTHubClient\_CreateFromConnectionString**, les bibliothèques sous-jacentes créent un thread qui s’exécute en arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="769cf-130">When you call **IoTHubClient\_CreateFromConnectionString**, the underlying libraries create a new thread that runs in the background.</span></span> <span data-ttu-id="769cf-131">Ce thread envoie les événements vers IoT Hub et reçoit les messages émanant d’IoT Hub.</span><span class="sxs-lookup"><span data-stu-id="769cf-131">This thread sends events to, and receives messages from, IoT Hub.</span></span> <span data-ttu-id="769cf-132">Aucun thread de ce type n’est créé lorsque vous travaillez avec des API « LL ».</span><span class="sxs-lookup"><span data-stu-id="769cf-132">No such thread is created when working with the "LL" APIs.</span></span> <span data-ttu-id="769cf-133">La création du thread d’arrière-plan est pratique pour le développeur.</span><span class="sxs-lookup"><span data-stu-id="769cf-133">The creation of the background thread is a convenience to the developer.</span></span> <span data-ttu-id="769cf-134">Vous n’avez pas à vous soucier d’envoyer des événements et de recevoir des messages d’IoT Hub. Ces opérations s’exécutent automatiquement en arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="769cf-134">You don’t have to worry about explicitly sending events and receiving messages from IoT Hub -- it happens automatically in the background.</span></span> <span data-ttu-id="769cf-135">En revanche, l’API « LL » vous offre un contrôle explicite sur la communication avec IoT Hub, si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="769cf-135">In contrast, the "LL" APIs give you explicit control over communication with IoT Hub, if you need it.</span></span>

<span data-ttu-id="769cf-136">Pour mieux comprendre, examinons un exemple :</span><span class="sxs-lookup"><span data-stu-id="769cf-136">To understand this better, let’s look at an example:</span></span>

<span data-ttu-id="769cf-137">Lorsque vous appelez **IoTHubClient\_SendEventAsync**, vous mettez en fait un événement en mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="769cf-137">When you call **IoTHubClient\_SendEventAsync**, what you're actually doing is putting the event in a buffer.</span></span> <span data-ttu-id="769cf-138">Le thread d’arrière-plan créé lorsque vous appelez **IoTHubClient\_CreateFromConnectionString** surveille en continu ce tampon et envoie toutes les données qu’il contient à IoT Hub.</span><span class="sxs-lookup"><span data-stu-id="769cf-138">The background thread created when you call **IoTHubClient\_CreateFromConnectionString** continually monitors this buffer and sends any data that it contains to IoT Hub.</span></span> <span data-ttu-id="769cf-139">Cela se produit en arrière-plan, pendant que le thread principal exécute une autre tâche.</span><span class="sxs-lookup"><span data-stu-id="769cf-139">This happens in the background at the same time that the main thread is performing other work.</span></span>

<span data-ttu-id="769cf-140">De même, quand vous enregistrez une fonction de rappel pour les messages à l’aide **d’IoTHubClient\_SetMessageCallback**, vous indiquez au Kit de développement logiciel (SDK) que le thread d’arrière-plan doit appeler la fonction de rappel quand un message est reçu, indépendamment du thread principal.</span><span class="sxs-lookup"><span data-stu-id="769cf-140">Similarly, when you register a callback function for messages using **IoTHubClient\_SetMessageCallback**, you're instructing the SDK to have the background thread invoke the callback function when a message is received, independent of the main thread.</span></span>

<span data-ttu-id="769cf-141">Les API « LL » ne créent pas un thread d’arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="769cf-141">The "LL" APIs don’t create a background thread.</span></span> <span data-ttu-id="769cf-142">Au lieu de cela, une nouvelle API doit être appelée explicitement pour envoyer et recevoir des données de la part d’IoT Hub.</span><span class="sxs-lookup"><span data-stu-id="769cf-142">Instead, a new API must be called to explicitly send and receive data from IoT Hub.</span></span> <span data-ttu-id="769cf-143">Cette opération est illustrée dans l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="769cf-143">This is demonstrated in the following example.</span></span>

<span data-ttu-id="769cf-144">L’application **iothub\_client\_sample\_http** incluse dans le Kit de développement logiciel (SDK) présente les API de niveau inférieur.</span><span class="sxs-lookup"><span data-stu-id="769cf-144">The **iothub\_client\_sample\_http** application that’s included in the SDK demonstrates the lower-level APIs.</span></span> <span data-ttu-id="769cf-145">Dans cet exemple, nous envoyons des événements à IoT Hub avec un code similaire à celui qui suit :</span><span class="sxs-lookup"><span data-stu-id="769cf-145">In that sample, we send events to IoT Hub with code such as the following:</span></span>

```
EVENT_INSTANCE message;
sprintf_s(msgText, sizeof(msgText), "Message_%d_From_IoTHubClient_LL_Over_HTTP", i);
message.messageHandle = IoTHubMessage_CreateFromByteArray((const unsigned char*)msgText, strlen(msgText));

IoTHubClient_LL_SendEventAsync(iotHubClientHandle, message.messageHandle, SendConfirmationCallback, &message)
```

<span data-ttu-id="769cf-146">Les trois premières lignes créent le message et la dernière ligne envoie l’événement.</span><span class="sxs-lookup"><span data-stu-id="769cf-146">The first three lines create the message, and the last line sends the event.</span></span> <span data-ttu-id="769cf-147">Cependant, comme indiqué précédemment l’« envoi » de l’événement indique simplement que les données sont placées dans une mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="769cf-147">However, as mentioned previously, "sending" the event means that the data is simply placed in a buffer.</span></span> <span data-ttu-id="769cf-148">Lorsque nous appelons **IoTHubClient\_LL\_SendEventAsync**, rien n’est transmis sur le réseau.</span><span class="sxs-lookup"><span data-stu-id="769cf-148">Nothing is transmitted on the network when we call **IoTHubClient\_LL\_SendEventAsync**.</span></span> <span data-ttu-id="769cf-149">Pour entrer réellement les données sur IoT Hub, vous devez appeler **IoTHubClient\_LL\_DoWork**, comme dans cet exemple :</span><span class="sxs-lookup"><span data-stu-id="769cf-149">In order to actually ingress the data to IoT Hub, you must call **IoTHubClient\_LL\_DoWork**, as in this example:</span></span>

```
while (1)
{
    IoTHubClient_LL_DoWork(iotHubClientHandle);
    ThreadAPI_Sleep(1000);
}
```

<span data-ttu-id="769cf-150">Ce code (tiré de l’application **iothub\_client\_sample\_http**) appelle à plusieurs reprises **IoTHubClient\_LL\_DoWork**.</span><span class="sxs-lookup"><span data-stu-id="769cf-150">This code (from the **iothub\_client\_sample\_http** application) repeatedly calls **IoTHubClient\_LL\_DoWork**.</span></span> <span data-ttu-id="769cf-151">Chaque fois que la fonction **IoTHubClient\_LL\_DoWork** est appelée, elle envoie des événements de la mémoire tampon vers IoT Hub et récupère ensuite un message en file d’attente envoyé à l’appareil.</span><span class="sxs-lookup"><span data-stu-id="769cf-151">Each time **IoTHubClient\_LL\_DoWork** is called, it sends some events from the buffer to IoT Hub and it retrieves a queued message being sent to the device.</span></span> <span data-ttu-id="769cf-152">Dans ce dernier cas, si nous avons inscrit une fonction de rappel pour les messages, le rappel est invoqué (en supposant que des messages sont en file d’attente).</span><span class="sxs-lookup"><span data-stu-id="769cf-152">The latter case means that if we registered a callback function for messages, then the callback is invoked (assuming any messages are queued up).</span></span> <span data-ttu-id="769cf-153">Cette fonction de rappel a été enregistrée avec le code qui suit :</span><span class="sxs-lookup"><span data-stu-id="769cf-153">We would have registered such a callback function with code such as the following:</span></span>

```
IoTHubClient_LL_SetMessageCallback(iotHubClientHandle, ReceiveMessageCallback, &receiveContext)
```

<span data-ttu-id="769cf-154">La raison pour laquelle la fonction **IoTHubClient\_LL\_DoWork** est souvent appelée dans une boucle est qu’à chaque appel, elle envoie *certains* événements mis en mémoire tampon à IoT Hub et récupère le message en file d’attente *suivant* destiné à l’appareil.</span><span class="sxs-lookup"><span data-stu-id="769cf-154">The reason that **IoTHubClient\_LL\_DoWork** is often called in a loop is that each time it’s called, it sends *some* buffered events to IoT Hub and retrieves *the next* message queued up for the device.</span></span> <span data-ttu-id="769cf-155">Chaque appel ne garantit pas que tous les événements en mémoire tampon sont envoyés ou que tous les messages en file d’attente sont récupérés.</span><span class="sxs-lookup"><span data-stu-id="769cf-155">Each call isn’t guaranteed to send all buffered events or to retrieve all queued messages.</span></span> <span data-ttu-id="769cf-156">Si vous souhaitez envoyer tous les événements en mémoire tampon, puis continuer avec un autre traitement, vous pouvez remplacer cette boucle par un code similaire à celui qui suit :</span><span class="sxs-lookup"><span data-stu-id="769cf-156">If you want to send all events in the buffer and then continue on with other processing you can replace this loop with code such as the following:</span></span>

```
IOTHUB_CLIENT_STATUS status;

while ((IoTHubClient_LL_GetSendStatus(iotHubClientHandle, &status) == IOTHUB_CLIENT_OK) && (status == IOTHUB_CLIENT_SEND_STATUS_BUSY))
{
    IoTHubClient_LL_DoWork(iotHubClientHandle);
    ThreadAPI_Sleep(1000);
}
```

<span data-ttu-id="769cf-157">Ce code appelle **IoTHubClient\_LL\_DoWork** jusqu’à ce que tous les événements placés en mémoire tampon aient été envoyés à IoT Hub.</span><span class="sxs-lookup"><span data-stu-id="769cf-157">This code calls **IoTHubClient\_LL\_DoWork** until all events in the buffer have been sent to IoT Hub.</span></span> <span data-ttu-id="769cf-158">Notez que cela ne signifie pas non plus que tous les messages en file d’attente ont été reçus.</span><span class="sxs-lookup"><span data-stu-id="769cf-158">Note this does not also imply that all queued messages have been received.</span></span> <span data-ttu-id="769cf-159">Cela est en partie dû au fait que le contrôle de « tous » les messages n’est pas une action déterminante.</span><span class="sxs-lookup"><span data-stu-id="769cf-159">Part of the reason for this is that checking for "all" messages isn’t as deterministic an action.</span></span> <span data-ttu-id="769cf-160">Que se passe-t-il si vous récupérez « tous » les messages, mais qu’un autre est envoyé à l’appareil immédiatement après ?</span><span class="sxs-lookup"><span data-stu-id="769cf-160">What happens if you retrieve "all" of the messages, but then another one is sent to the device immediately after?</span></span> <span data-ttu-id="769cf-161">Une bonne façon de traiter cette possibilité consiste à programmer un délai d’attente.</span><span class="sxs-lookup"><span data-stu-id="769cf-161">A better way to deal with that is with a programmed timeout.</span></span> <span data-ttu-id="769cf-162">Par exemple, la fonction de rappel de message peut réinitialiser une minuterie à chaque fois qu’elle est appelée.</span><span class="sxs-lookup"><span data-stu-id="769cf-162">For example, the message callback function could reset a timer every time it’s invoked.</span></span> <span data-ttu-id="769cf-163">Vous pouvez ensuite rédiger un programme permettant de poursuivre le traitement si, par exemple, aucun message n’a été reçu au cours des *X* dernières secondes.</span><span class="sxs-lookup"><span data-stu-id="769cf-163">You can then write logic to continue processing if, for example, no messages have been received in the last *X* seconds.</span></span>

<span data-ttu-id="769cf-164">Lorsque vous avez terminé de réceptionner les événements et les messages, assurez-vous d’appeler la fonction correspondante pour nettoyer les ressources.</span><span class="sxs-lookup"><span data-stu-id="769cf-164">When you’re finished ingressing events and receiving messages, be sure to call the corresponding function to clean up resources.</span></span>

```
IoTHubClient_LL_Destroy(iotHubClientHandle);
```

<span data-ttu-id="769cf-165">En fait, il existe un seul ensemble d’API pour envoyer et recevoir des données avec un thread d’arrière-plan et un autre ensemble d’API qui fait la même chose sans thread d’arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="769cf-165">Basically there’s only one set of APIs to send and receive data with a background thread and another set of APIs that does the same thing without the background thread.</span></span> <span data-ttu-id="769cf-166">Un grand nombre de développeurs préfèrent les API non LL, mais les API de niveau inférieur sont utiles lorsque le développeur souhaite obtenir un contrôle explicite sur les transmissions réseau.</span><span class="sxs-lookup"><span data-stu-id="769cf-166">A lot of developers may prefer the non-LL APIs, but the lower-level APIs are useful when the developer wants explicit control over network transmissions.</span></span> <span data-ttu-id="769cf-167">Par exemple, certains appareils recueillent des données au fil du temps et n’enregistrent que les événements à des intervalles spécifiés (par exemple, une fois par heure ou une fois par jour).</span><span class="sxs-lookup"><span data-stu-id="769cf-167">For example, some devices collect data over time and only ingress events at specified intervals (for example, once an hour or once a day).</span></span> <span data-ttu-id="769cf-168">Les API de niveau inférieur vous donnent la possibilité de contrôler explicitement l’envoi et la réception depuis IoT Hub.</span><span class="sxs-lookup"><span data-stu-id="769cf-168">The lower-level APIs give you the ability to explicitly control when you send and receive data from IoT Hub.</span></span> <span data-ttu-id="769cf-169">D’autres préfèrent la simplicité qu’offrent les API de niveau inférieur.</span><span class="sxs-lookup"><span data-stu-id="769cf-169">Others will simply prefer the simplicity that the lower-level APIs provide.</span></span> <span data-ttu-id="769cf-170">Tout se produit sur le thread principal plutôt que sur les travaux qui s’exécutent en arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="769cf-170">Everything happens on the main thread rather than some work happening in the background.</span></span>

<span data-ttu-id="769cf-171">Quel que soit le modèle que vous choisissez, assurez-vous d’être cohérent avec les API que vous utilisez.</span><span class="sxs-lookup"><span data-stu-id="769cf-171">Whichever model you choose, be sure to be consistent in which APIs you use.</span></span> <span data-ttu-id="769cf-172">Si vous commencez par appeler **IoTHubClient\_LL\_CreateFromConnectionString**, veillez à utiliser uniquement les API de niveau inférieur correspondantes pour les travaux ultérieurs :</span><span class="sxs-lookup"><span data-stu-id="769cf-172">If you start by calling **IoTHubClient\_LL\_CreateFromConnectionString**, be sure you only use the corresponding lower-level APIs for any follow-up work:</span></span>

* <span data-ttu-id="769cf-173">IoTHubClient\_LL\_SendEventAsync</span><span class="sxs-lookup"><span data-stu-id="769cf-173">IoTHubClient\_LL\_SendEventAsync</span></span>
* <span data-ttu-id="769cf-174">IoTHubClient\_LL\_SetMessageCallback</span><span class="sxs-lookup"><span data-stu-id="769cf-174">IoTHubClient\_LL\_SetMessageCallback</span></span>
* <span data-ttu-id="769cf-175">IoTHubClient\_LL\_Destroy</span><span class="sxs-lookup"><span data-stu-id="769cf-175">IoTHubClient\_LL\_Destroy</span></span>
* <span data-ttu-id="769cf-176">IoTHubClient\_LL\_DoWork</span><span class="sxs-lookup"><span data-stu-id="769cf-176">IoTHubClient\_LL\_DoWork</span></span>

<span data-ttu-id="769cf-177">L’inverse est également vrai.</span><span class="sxs-lookup"><span data-stu-id="769cf-177">The opposite is true as well.</span></span> <span data-ttu-id="769cf-178">Si vous démarrez avec **IoTHubClient\_CreateFromConnectionString**, utilisez les API non LL pour tout traitement supplémentaire.</span><span class="sxs-lookup"><span data-stu-id="769cf-178">If you start with **IoTHubClient\_CreateFromConnectionString**, then use the non-LL APIs for any additional processing.</span></span>

<span data-ttu-id="769cf-179">Dans le Kit de développement logiciel (SDK) d’appareil Azure IoT (Azure IoT device SDK) pour C, consultez l’application **iothub\_client\_sample\_http** pour obtenir un exemple complet des API de niveau inférieur.</span><span class="sxs-lookup"><span data-stu-id="769cf-179">In the Azure IoT device SDK for C, see the **iothub\_client\_sample\_http** application for a complete example of the lower-level APIs.</span></span> <span data-ttu-id="769cf-180">L’application **iothub\_client\_sample\_amqp** peut être référencée pour un exemple complet des API non LL.</span><span class="sxs-lookup"><span data-stu-id="769cf-180">The **iothub\_client\_sample\_amqp** application can be referenced for a full example of the non-LL APIs.</span></span>

## <a name="property-handling"></a><span data-ttu-id="769cf-181">Gestion des propriétés</span><span class="sxs-lookup"><span data-stu-id="769cf-181">Property handling</span></span>
<span data-ttu-id="769cf-182">Jusqu’à présent, lorsque nous avons décrit l’envoi de données, nous avons fait référence au corps du message.</span><span class="sxs-lookup"><span data-stu-id="769cf-182">So far when we've described sending data, we've been referring to the body of the message.</span></span> <span data-ttu-id="769cf-183">Considérez par exemple le code suivant :</span><span class="sxs-lookup"><span data-stu-id="769cf-183">For example, consider this code:</span></span>

```
EVENT_INSTANCE message;
sprintf_s(msgText, sizeof(msgText), "Hello World");
message.messageHandle = IoTHubMessage_CreateFromByteArray((const unsigned char*)msgText, strlen(msgText));
IoTHubClient_LL_SendEventAsync(iotHubClientHandle, message.messageHandle, SendConfirmationCallback, &message)
```

<span data-ttu-id="769cf-184">Cet exemple envoie un message à IoT Hub avec le texte « Hello World ».</span><span class="sxs-lookup"><span data-stu-id="769cf-184">This example sends a message to IoT Hub with the text "Hello World."</span></span> <span data-ttu-id="769cf-185">Cependant, IoT Hub permet également de joindre des propriétés à chaque message.</span><span class="sxs-lookup"><span data-stu-id="769cf-185">However, IoT Hub also allows properties to be attached to each message.</span></span> <span data-ttu-id="769cf-186">Les propriétés sont des paires nom/valeur pouvant être jointes au message.</span><span class="sxs-lookup"><span data-stu-id="769cf-186">Properties are name/value pairs that can be attached to the message.</span></span> <span data-ttu-id="769cf-187">Par exemple, nous pouvons modifier le code précédent pour attacher une propriété au message :</span><span class="sxs-lookup"><span data-stu-id="769cf-187">For example, we can modify the previous code to attach a property to the message:</span></span>

```
MAP_HANDLE propMap = IoTHubMessage_Properties(message.messageHandle);
sprintf_s(propText, sizeof(propText), "%d", i);
Map_AddOrUpdate(propMap, "SequenceNumber", propText);
```

<span data-ttu-id="769cf-188">Nous allons commencer en appelant **IoTHubMessage\_Properties** et en lui transmettant le pointeur de notre message.</span><span class="sxs-lookup"><span data-stu-id="769cf-188">We start by calling **IoTHubMessage\_Properties** and passing it the handle of our message.</span></span> <span data-ttu-id="769cf-189">Nous obtenons une référence **MAP\_HANDLE** qui nous permet de commencer à ajouter des propriétés.</span><span class="sxs-lookup"><span data-stu-id="769cf-189">What we get back is a **MAP\_HANDLE** reference that enables us to start adding properties.</span></span> <span data-ttu-id="769cf-190">Cette opération s’effectue en appelant **Map\_AddOrUpdate** qui accepte une référence MAP\_HANDLE, le nom de propriété et la valeur de propriété.</span><span class="sxs-lookup"><span data-stu-id="769cf-190">The latter is accomplished by calling **Map\_AddOrUpdate**, which takes a reference to a MAP\_HANDLE, the property name, and the property value.</span></span> <span data-ttu-id="769cf-191">Avec cette API, nous pouvons ajouter autant de propriétés que nous le souhaitons.</span><span class="sxs-lookup"><span data-stu-id="769cf-191">With this API we can add as many properties as we like.</span></span>

<span data-ttu-id="769cf-192">Lorsque l’événement est lu à partir **d’Event Hubs**, le récepteur peut énumérer les propriétés et récupérer les valeurs correspondantes.</span><span class="sxs-lookup"><span data-stu-id="769cf-192">When the event is read from **Event Hubs**, the receiver can enumerate the properties and retrieve their corresponding values.</span></span> <span data-ttu-id="769cf-193">Par exemple, dans .NET, cette opération s’effectue grâce à un accès à la [collection de propriétés sur l’objet EventData](https://msdn.microsoft.com/library/azure/microsoft.servicebus.messaging.eventdata.properties.aspx).</span><span class="sxs-lookup"><span data-stu-id="769cf-193">For example, in .NET this would be accomplished by accessing the [Properties collection on the EventData object](https://msdn.microsoft.com/library/azure/microsoft.servicebus.messaging.eventdata.properties.aspx).</span></span>

<span data-ttu-id="769cf-194">Dans l’exemple précédent, nous allons rattacher des propriétés à un événement que nous envoyons à IoT Hub.</span><span class="sxs-lookup"><span data-stu-id="769cf-194">In the previous example, we’re attaching properties to an event that we send to IoT Hub.</span></span> <span data-ttu-id="769cf-195">Les propriétés peuvent également être jointes à des messages provenant d’IoT Hub.</span><span class="sxs-lookup"><span data-stu-id="769cf-195">Properties can also be attached to messages received from IoT Hub.</span></span> <span data-ttu-id="769cf-196">Si vous souhaitez récupérer les propriétés d’un message, nous pouvons utiliser un code du type qui suit dans notre fonction de rappel de message :</span><span class="sxs-lookup"><span data-stu-id="769cf-196">If we want to retrieve properties from a message, we can use code such as the following in our message callback function:</span></span>

```
static IOTHUBMESSAGE_DISPOSITION_RESULT ReceiveMessageCallback(IOTHUB_MESSAGE_HANDLE message, void* userContextCallback)
{
    . . .

    // Retrieve properties from the message
    MAP_HANDLE mapProperties = IoTHubMessage_Properties(message);
    if (mapProperties != NULL)
    {
        const char*const* keys;
        const char*const* values;
        size_t propertyCount = 0;
        if (Map_GetInternals(mapProperties, &keys, &values, &propertyCount) == MAP_OK)
        {
            if (propertyCount > 0)
            {
                printf("Message Properties:\r\n");
                for (size_t index = 0; index < propertyCount; index++)
                {
                    printf("\tKey: %s Value: %s\r\n", keys[index], values[index]);
                }
                printf("\r\n");
            }
        }
    }

    . . .
}
```

<span data-ttu-id="769cf-197">L’appel à **IoTHubMessage\_Properties** renvoie la référence **MAP\_HANDLE**.</span><span class="sxs-lookup"><span data-stu-id="769cf-197">The call to **IoTHubMessage\_Properties** returns the **MAP\_HANDLE** reference.</span></span> <span data-ttu-id="769cf-198">Cette référence est ensuite transmise à **Map\_GetInternals** pour obtenir une référence à un tableau de paires nom/valeur (ainsi que le nombre des propriétés).</span><span class="sxs-lookup"><span data-stu-id="769cf-198">We then pass that reference to **Map\_GetInternals** to obtain a reference to an array of the name/value pairs (as well as a count of the properties).</span></span> <span data-ttu-id="769cf-199">À ce stade, il est très simple d’énumérer les propriétés pour obtenir les valeurs souhaitées.</span><span class="sxs-lookup"><span data-stu-id="769cf-199">At that point it's a simple matter of enumerating the properties to get to the values we want.</span></span>

<span data-ttu-id="769cf-200">Vous n’êtes pas obligé d’utiliser des propriétés dans votre application.</span><span class="sxs-lookup"><span data-stu-id="769cf-200">You don't have to use properties in your application.</span></span> <span data-ttu-id="769cf-201">Mais si vous devez les définir sur les événements ou les récupérer à partir de messages, la bibliothèque **IoTHubClient** facilite cette opération.</span><span class="sxs-lookup"><span data-stu-id="769cf-201">However, if you need to set them on events or retrieve them from messages, the **IoTHubClient** library makes it easy.</span></span>

## <a name="message-handling"></a><span data-ttu-id="769cf-202">Gestion des messages</span><span class="sxs-lookup"><span data-stu-id="769cf-202">Message handling</span></span>
<span data-ttu-id="769cf-203">Comme expliqué précédemment, lorsque les messages arrivent d’IoT Hub, la bibliothèque **IoTHubClient** répond en appelant une fonction de rappel enregistrée.</span><span class="sxs-lookup"><span data-stu-id="769cf-203">As stated previously, when messages arrive from IoT Hub the **IoTHubClient** library responds by invoking a registered callback function.</span></span> <span data-ttu-id="769cf-204">Un des paramètres de retour de cette fonction mérite cependant quelques explications supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="769cf-204">There is a return parameter of this function that deserves some additional explanation.</span></span> <span data-ttu-id="769cf-205">Voici un extrait de la fonction de rappel de l’exemple d’application **iothub\_client\_sample\_http** :</span><span class="sxs-lookup"><span data-stu-id="769cf-205">Here’s an excerpt of the callback function in the **iothub\_client\_sample\_http** sample application:</span></span>

```
static IOTHUBMESSAGE_DISPOSITION_RESULT ReceiveMessageCallback(IOTHUB_MESSAGE_HANDLE message, void* userContextCallback)
{
    . . .
    return IOTHUBMESSAGE_ACCEPTED;
}
```

<span data-ttu-id="769cf-206">Notez que le type de retour est **IOTHUBMESSAGE\_DISPOSITION\_RESULT** et, dans ce cas particulier, c’est le message **IOTHUBMESSAGE\_ACCEPTED** qui est renvoyé.</span><span class="sxs-lookup"><span data-stu-id="769cf-206">Note that the return type is **IOTHUBMESSAGE\_DISPOSITION\_RESULT** and in this particular case we return **IOTHUBMESSAGE\_ACCEPTED**.</span></span> <span data-ttu-id="769cf-207">Il existe d’autres valeurs que nous pouvons renvoyer à partir de cette fonction afin de modifier la réaction de la bibliothèque **IoTHubClient** au rappel de message.</span><span class="sxs-lookup"><span data-stu-id="769cf-207">There are other values we can return from this function that change how the **IoTHubClient** library reacts to the message callback.</span></span> <span data-ttu-id="769cf-208">Les options proposées sont les suivantes.</span><span class="sxs-lookup"><span data-stu-id="769cf-208">Here are the options.</span></span>

* <span data-ttu-id="769cf-209">**IOTHUBMESSAGE\_ACCEPTED** : le message a été traité avec succès.</span><span class="sxs-lookup"><span data-stu-id="769cf-209">**IOTHUBMESSAGE\_ACCEPTED** – The message has been processed successfully.</span></span> <span data-ttu-id="769cf-210">La bibliothèque **IoTHubClient** ne rappellera pas la fonction de rappel avec le même message.</span><span class="sxs-lookup"><span data-stu-id="769cf-210">The **IoTHubClient** library will not invoke the callback function again with the same message.</span></span>
* <span data-ttu-id="769cf-211">**IOTHUBMESSAGE\_REJECTED** : le message n’a pas été traité, et ne devrait pas l’être à l’avenir.</span><span class="sxs-lookup"><span data-stu-id="769cf-211">**IOTHUBMESSAGE\_REJECTED** – The message was not processed and there is no desire to do so in the future.</span></span> <span data-ttu-id="769cf-212">La bibliothèque **IoTHubClient** n’appellera pas la fonction de rappel avec le même message.</span><span class="sxs-lookup"><span data-stu-id="769cf-212">The **IoTHubClient** library should not invoke the callback function again with the same message.</span></span>
* <span data-ttu-id="769cf-213">**IOTHUBMESSAGE\_ABANDONED** : le message n’a pas été traité correctement, mais la bibliothèque **IoTHubClient** doit de nouveau invoquer la fonction de rappel, en utilisant le même message.</span><span class="sxs-lookup"><span data-stu-id="769cf-213">**IOTHUBMESSAGE\_ABANDONED** – The message was not processed successfully, but the **IoTHubClient** library should invoke the callback function again with the same message.</span></span>

<span data-ttu-id="769cf-214">Pour les deux premiers codes de retour, la bibliothèque **IoTHubClient** envoie à IoT Hub un message indiquant que le message doit être supprimé de la file d’attente de l’appareil et non remis à nouveau.</span><span class="sxs-lookup"><span data-stu-id="769cf-214">For the first two return codes, the **IoTHubClient** library sends a message to IoT Hub indicating that the message should be deleted from the device queue and not delivered again.</span></span> <span data-ttu-id="769cf-215">La conséquence est identique (le message est supprimé de la file d’attente de l’appareil), mais le fait que le message ait été accepté ou rejeté reste dans les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="769cf-215">The net effect is the same (the message is deleted from the device queue), but whether the message was accepted or rejected is still recorded.</span></span>  <span data-ttu-id="769cf-216">L’enregistrement de cette différence est utile aux expéditeurs du message qui peuvent écouter le retour et découvrir si un appareil a accepté ou rejeté un message particulier.</span><span class="sxs-lookup"><span data-stu-id="769cf-216">Recording this distinction is useful to senders of the message who can listen for feedback and find out if a device has accepted or rejected a particular message.</span></span>

<span data-ttu-id="769cf-217">Dans ce dernier cas, un message est également envoyé à IoT Hub, mais il indique que le message doit être à nouveau remis.</span><span class="sxs-lookup"><span data-stu-id="769cf-217">In the last case a message is also sent to IoT Hub, but it indicates that the message should be redelivered.</span></span> <span data-ttu-id="769cf-218">En général, si vous rencontrez une erreur mais que vous souhaitez essayer de traiter de nouveau le message, vous devez abandonner le message.</span><span class="sxs-lookup"><span data-stu-id="769cf-218">Typically you’ll abandon a message if you encounter some error but want to try to process the message again.</span></span> <span data-ttu-id="769cf-219">En revanche, le rejet d’un message se justifie lorsque vous rencontrez une erreur irrécupérable (ou si vous décidez simplement que vous ne voulez pas traiter le message).</span><span class="sxs-lookup"><span data-stu-id="769cf-219">In contrast, rejecting a message is appropriate when you encounter an unrecoverable error (or if you simply decide you don’t want to process the message).</span></span>

<span data-ttu-id="769cf-220">Dans tous les cas, vous devez connaître les différents codes de retour de façon à choisir le comportement que vous souhaitez obtenir de la bibliothèque **IoTHubClient** .</span><span class="sxs-lookup"><span data-stu-id="769cf-220">In any case, be aware of the different return codes so that you can elicit the behavior you want from the **IoTHubClient** library.</span></span>

## <a name="alternate-device-credentials"></a><span data-ttu-id="769cf-221">Autres informations d’identification d’appareil</span><span class="sxs-lookup"><span data-stu-id="769cf-221">Alternate device credentials</span></span>
<span data-ttu-id="769cf-222">Comme nous l’avons expliqué plus haut, la première chose à faire lorsqu’on travaille avec la bibliothèque **IoTHubClient** consiste à obtenir une référence **IOTHUB\_CLIENT\_HANDLE** avec un appel tel que le suivant :</span><span class="sxs-lookup"><span data-stu-id="769cf-222">As explained previously, the first thing to do when working with the **IoTHubClient** library is to obtain a **IOTHUB\_CLIENT\_HANDLE** with a call such as the following:</span></span>

```
IOTHUB_CLIENT_HANDLE iotHubClientHandle;
iotHubClientHandle = IoTHubClient_CreateFromConnectionString(connectionString, AMQP_Protocol);
```

<span data-ttu-id="769cf-223">Les arguments de **IoTHubClient\_CreateFromConnectionString** correspondent à la chaîne de connexion de l’appareil et un paramètre indique le protocole que nous allons utiliser pour communiquer avec IoT Hub.</span><span class="sxs-lookup"><span data-stu-id="769cf-223">The arguments to **IoTHubClient\_CreateFromConnectionString** are the device connection string and a parameter that indicates the protocol we use to communicate with IoT Hub.</span></span> <span data-ttu-id="769cf-224">Le format de la chaîne de connexion de l’appareil se présente comme suit :</span><span class="sxs-lookup"><span data-stu-id="769cf-224">The device connection string has a format that appears as follows:</span></span>

```
HostName=IOTHUBNAME.IOTHUBSUFFIX;DeviceId=DEVICEID;SharedAccessKey=SHAREDACCESSKEY
```

<span data-ttu-id="769cf-225">Il existe ici quatre éléments d’information : le nom IoT Hub, le suffixe IoT Hub, l’ID d’appareil et la clé d’accès partagé.</span><span class="sxs-lookup"><span data-stu-id="769cf-225">There are four pieces of information in this string: IoT Hub name, IoT Hub suffix, device ID, and shared access key.</span></span> <span data-ttu-id="769cf-226">Vous obtenez le nom de domaine complet (FQDN) d’un IoT Hub lorsque vous créez une instance d’IoT Hub dans le portail Azure. Vous obtenez ainsi le nom d’IoT Hub (la première partie du nom de domaine complet) et le suffixe d’IoT Hub (le reste du nom de domaine complet).</span><span class="sxs-lookup"><span data-stu-id="769cf-226">You obtain the fully qualified domain name (FQDN) of an IoT hub when you create your IoT hub instance in the Azure portal — this gives you the IoT hub name (the first part of the FQDN) and the IoT hub suffix (the rest of the FQDN).</span></span> <span data-ttu-id="769cf-227">L’ID d’appareil et la clé d’accès partagé vous sont fournis lorsque vous inscrivez votre appareil avec IoT Hub (comme le décrit [l’article précédent](iot-hub-device-sdk-c-intro.md)).</span><span class="sxs-lookup"><span data-stu-id="769cf-227">You get the device ID and the shared access key when you register your device with IoT Hub (as described in the [previous article](iot-hub-device-sdk-c-intro.md)).</span></span>

<span data-ttu-id="769cf-228">**IoTHubClient\_CreateFromConnectionString** vous propose une façon d’initialiser la bibliothèque.</span><span class="sxs-lookup"><span data-stu-id="769cf-228">**IoTHubClient\_CreateFromConnectionString** gives you one way to initialize the library.</span></span> <span data-ttu-id="769cf-229">Vous pouvez également créer un élément **IOTHUB\_CLIENT\_HANDLE** à l’aide de ces paramètres individuels plutôt que de la chaîne de connexion de l’appareil.</span><span class="sxs-lookup"><span data-stu-id="769cf-229">If you prefer, you can create a new **IOTHUB\_CLIENT\_HANDLE** by using these individual parameters rather than the device connection string.</span></span> <span data-ttu-id="769cf-230">Vous pouvez y parvenir avec le code suivant :</span><span class="sxs-lookup"><span data-stu-id="769cf-230">This is achieved with the following code:</span></span>

```
IOTHUB_CLIENT_CONFIG iotHubClientConfig;
iotHubClientConfig.iotHubName = "";
iotHubClientConfig.deviceId = "";
iotHubClientConfig.deviceKey = "";
iotHubClientConfig.iotHubSuffix = "";
iotHubClientConfig.protocol = HTTP_Protocol;
IOTHUB_CLIENT_HANDLE iotHubClientHandle = IoTHubClient_LL_Create(&iotHubClientConfig);
```

<span data-ttu-id="769cf-231">Il effectue la même opération que **IoTHubClient\_CreateFromConnectionString**.</span><span class="sxs-lookup"><span data-stu-id="769cf-231">This accomplishes the same thing as **IoTHubClient\_CreateFromConnectionString**.</span></span>

<span data-ttu-id="769cf-232">Il semble évident que vous préférerez utiliser **IoTHubClient\_CreateFromConnectionString** plutôt que la méthode d’initialisation plus détaillée.</span><span class="sxs-lookup"><span data-stu-id="769cf-232">It may seem obvious that you would want to use **IoTHubClient\_CreateFromConnectionString** rather than this more verbose method of initialization.</span></span> <span data-ttu-id="769cf-233">Cependant, gardez à l’esprit que lorsque vous enregistrez un appareil dans IoT Hub, vous obtenez un ID d’appareil et une clé d’appareil (pas une chaîne de connexion).</span><span class="sxs-lookup"><span data-stu-id="769cf-233">Keep in mind, however, that when you register a device in IoT Hub what you get is a device ID and device key (not a connection string).</span></span> <span data-ttu-id="769cf-234">L’outil du Kit de développement logiciel (SDK) *Explorateur d’appareils* présenté dans [l’article précédent](iot-hub-device-sdk-c-intro.md) utilise des bibliothèques du **Kit de développement logiciel (SDK) de service Azure IoT** pour créer la chaîne de connexion à l’appareil à partir de l’ID d’appareil, de la clé d’appareil et du nom d’hôte IoT Hub.</span><span class="sxs-lookup"><span data-stu-id="769cf-234">The *device explorer* SDK tool introduced in the [previous article](iot-hub-device-sdk-c-intro.md) uses libraries in the **Azure IoT service SDK** to create the device connection string from the device ID, device key, and IoT Hub host name.</span></span> <span data-ttu-id="769cf-235">Ainsi, il peut être préférable d’appeler **IoTHubClient\_LL\_Create**, car cela vous évite de générer une chaîne de connexion.</span><span class="sxs-lookup"><span data-stu-id="769cf-235">So calling **IoTHubClient\_LL\_Create** may be preferable because it saves you the step of generating a connection string.</span></span> <span data-ttu-id="769cf-236">Utilisez la méthode adéquate.</span><span class="sxs-lookup"><span data-stu-id="769cf-236">Use whichever method is convenient.</span></span>

## <a name="configuration-options"></a><span data-ttu-id="769cf-237">Options de configuration</span><span class="sxs-lookup"><span data-stu-id="769cf-237">Configuration options</span></span>
<span data-ttu-id="769cf-238">Jusqu’ici, tout ce qui est décrit dans la façon dont la bibliothèque **IoTHubClient** fonctionne reflète son comportement par défaut.</span><span class="sxs-lookup"><span data-stu-id="769cf-238">So far everything described about the way the **IoTHubClient** library works reflects its default behavior.</span></span> <span data-ttu-id="769cf-239">Cependant, vous pouvez définir quelques options que vous pouvez définir pour modifier le fonctionnement de la bibliothèque.</span><span class="sxs-lookup"><span data-stu-id="769cf-239">However, there are a few options that you can set to change how the library works.</span></span> <span data-ttu-id="769cf-240">Vous pouvez procéder en exploitant l’API **IoTHubClient\_LL\_SetOption**.</span><span class="sxs-lookup"><span data-stu-id="769cf-240">This is accomplished by leveraging the **IoTHubClient\_LL\_SetOption** API.</span></span> <span data-ttu-id="769cf-241">Examinez cet exemple :</span><span class="sxs-lookup"><span data-stu-id="769cf-241">Consider this example:</span></span>

```
unsigned int timeout = 30000;
IoTHubClient_LL_SetOption(iotHubClientHandle, "timeout", &timeout);
```

<span data-ttu-id="769cf-242">Quelques options sont couramment utilisées :</span><span class="sxs-lookup"><span data-stu-id="769cf-242">There are a couple of options that are commonly used:</span></span>

* <span data-ttu-id="769cf-243">**SetBatching** (bool) : si cette option a la valeur **true**, les données transmises à IoT Hub sont envoyées par lots.</span><span class="sxs-lookup"><span data-stu-id="769cf-243">**SetBatching** (bool) – If **true**, then data sent to IoT Hub is sent in batches.</span></span> <span data-ttu-id="769cf-244">Si elle a la valeur **false**, les messages sont envoyés individuellement.</span><span class="sxs-lookup"><span data-stu-id="769cf-244">If **false**, then messages are sent individually.</span></span> <span data-ttu-id="769cf-245">La valeur par défaut est **false**.</span><span class="sxs-lookup"><span data-stu-id="769cf-245">The default is **false**.</span></span> <span data-ttu-id="769cf-246">Notez que l’option **SetBatching** s’applique uniquement au protocole HTTP et non aux protocoles MQTT et AMQP.</span><span class="sxs-lookup"><span data-stu-id="769cf-246">Note that the **SetBatching** option only applies to the HTTP protocol and not to the MQTT or AMQP protocols.</span></span>
* <span data-ttu-id="769cf-247">**Timeout** (unsigned int) : cette valeur est exprimée en millisecondes.</span><span class="sxs-lookup"><span data-stu-id="769cf-247">**Timeout** (unsigned int) – This value is represented in milliseconds.</span></span> <span data-ttu-id="769cf-248">Si l’envoi d’une demande HTTP ou la réception d’une réponse prend davantage de temps, la connexion expire.</span><span class="sxs-lookup"><span data-stu-id="769cf-248">If sending an HTTP request or receiving a response takes longer than this time, then the connection times out.</span></span>

<span data-ttu-id="769cf-249">L’option de traitement par lot est importante.</span><span class="sxs-lookup"><span data-stu-id="769cf-249">The batching option is important.</span></span> <span data-ttu-id="769cf-250">Par défaut, la bibliothèque intègre des événements individuellement (un événement unique correspond à ce que vous transmettez à **IoTHubClient\_LL\_SendEventAsync**).</span><span class="sxs-lookup"><span data-stu-id="769cf-250">By default, the library ingresses events individually (a single event is whatever you pass to **IoTHubClient\_LL\_SendEventAsync**).</span></span> <span data-ttu-id="769cf-251">Mais si l’option de traitement par lot est définie sur **true**, la bibliothèque collecte autant d’événements que possible (jusqu’à atteindre la taille de message maximale acceptée par IoT Hub).</span><span class="sxs-lookup"><span data-stu-id="769cf-251">If the batching option is **true**, the library collects as many events as it can from the buffer (up to the maximum message size that IoT Hub will accept).</span></span>  <span data-ttu-id="769cf-252">Le lot d’événements est envoyé à IoT hub par le biais d’un seul appel HTTP (les événements individuels sont regroupés dans un tableau JSON).</span><span class="sxs-lookup"><span data-stu-id="769cf-252">The event batch is sent to IoT Hub in a single HTTP call (the individual events are bundled into a JSON array).</span></span> <span data-ttu-id="769cf-253">L’activation de l’option de traitement par lot permet d’obtenir des gains de performance, car vous réduisez le nombre d’allers-retours sur le réseau.</span><span class="sxs-lookup"><span data-stu-id="769cf-253">Enabling batching typically results in big performance gains since you’re reducing network round-trips.</span></span> <span data-ttu-id="769cf-254">Elle réduit également considérablement la bande passante, car vous envoyez un seul ensemble d’en-têtes HTTP avec un lot d’événements plutôt qu’un ensemble d’en-têtes pour chaque événement individuel.</span><span class="sxs-lookup"><span data-stu-id="769cf-254">It also significantly reduces bandwidth since you are sending one set of HTTP headers with an event batch rather than a set of headers for each individual event.</span></span> <span data-ttu-id="769cf-255">À moins d’avoir une raison particulière de faire autrement, vous devrez activer le traitement par lot.</span><span class="sxs-lookup"><span data-stu-id="769cf-255">Unless you have a specific reason to do otherwise, typically you’ll want to enable batching.</span></span>

## <a name="next-steps"></a><span data-ttu-id="769cf-256">Étapes suivantes</span><span class="sxs-lookup"><span data-stu-id="769cf-256">Next steps</span></span>
<span data-ttu-id="769cf-257">Cet article décrit en détail le comportement de la bibliothèque **IoTHubClient** se trouvant dans le **Kit de développement logiciel (SDK) d’appareil Azure IoT (Azure IoT device SDK) pour C**. Ces informations doivent vous permettre de bien comprendre les fonctionnalités de la bibliothèque **IoTHubClient**.</span><span class="sxs-lookup"><span data-stu-id="769cf-257">This article describes in detail the behavior of the **IoTHubClient** library found in the **Azure IoT device SDK for C**. With this information, you should have a good understanding of the capabilities of the **IoTHubClient** library.</span></span> <span data-ttu-id="769cf-258">Le [prochain article](iot-hub-device-sdk-c-serializer.md) fournit des détails similaires sur la bibliothèque **sérialiseur** .</span><span class="sxs-lookup"><span data-stu-id="769cf-258">The [next article](iot-hub-device-sdk-c-serializer.md) provides similar detail on the **serializer** library.</span></span>

<span data-ttu-id="769cf-259">Pour en savoir plus sur le développement pour IoT Hub, consultez les [SDK Azure IoT][lnk-sdks].</span><span class="sxs-lookup"><span data-stu-id="769cf-259">To learn more about developing for IoT Hub, see the [Azure IoT SDKs][lnk-sdks].</span></span>

<span data-ttu-id="769cf-260">Pour explorer davantage les capacités de IoT Hub, consultez :</span><span class="sxs-lookup"><span data-stu-id="769cf-260">To further explore the capabilities of IoT Hub, see:</span></span>

* <span data-ttu-id="769cf-261">[Simulation d’un appareil avec Azure IoT Edge][lnk-iotedge]</span><span class="sxs-lookup"><span data-stu-id="769cf-261">[Simulating a device with Azure IoT Edge][lnk-iotedge]</span></span>

[lnk-sdks]: iot-hub-devguide-sdks.md

[lnk-iotedge]: iot-hub-linux-iot-edge-simulated-device.md
