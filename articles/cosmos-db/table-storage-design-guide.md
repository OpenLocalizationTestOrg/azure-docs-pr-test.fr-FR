---
title: Guide de conception de table Azure Storage | Microsoft Docs
description: "Concevoir des tables évolutives et performantes dans le stockage de tables Azure"
services: cosmos-db
documentationcenter: na
author: mimig1
manager: tadb
editor: tysonn
ms.assetid: 8e228b0c-2998-4462-8101-9f16517393ca
ms.service: cosmos-db
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: storage
ms.date: 02/28/2017
ms.author: mimig
ms.openlocfilehash: fd34fb135c76eed4041c29e00e98dde330dfe3f3
ms.sourcegitcommit: 18ad9bc049589c8e44ed277f8f43dcaa483f3339
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/29/2017
---
# <a name="azure-storage-table-design-guide-designing-scalable-and-performant-tables"></a><span data-ttu-id="10689-103">Guide de conception de table Azure Storage : conception de tables évolutives et performantes</span><span class="sxs-lookup"><span data-stu-id="10689-103">Azure Storage Table Design Guide: Designing Scalable and Performant Tables</span></span>
[!INCLUDE [storage-table-cosmos-db-tip-include](../../includes/storage-table-cosmos-db-tip-include.md)]

<span data-ttu-id="10689-104">Pour concevoir des tables évolutives et performantes, vous devez prendre en compte un certain nombre de facteurs, tels que la performance, l'extensibilité et le coût.</span><span class="sxs-lookup"><span data-stu-id="10689-104">To design scalable and performant tables you must consider a number of factors such as performance, scalability, and cost.</span></span> <span data-ttu-id="10689-105">Si vous avez déjà conçu des schémas pour des bases de données relationnelles, ces considérations doivent vous être familières, mais s'il existe quelques similitudes entre le modèle de stockage du service de Table Azure et les modèles relationnels, il existe également plusieurs différences importantes.</span><span class="sxs-lookup"><span data-stu-id="10689-105">If you have previously designed schemas for relational databases, these considerations will be familiar to you, but while there are some similarities between the Azure Table service storage model and relational models, there are also many important differences.</span></span> <span data-ttu-id="10689-106">Ces différences conduisent généralement à des conceptions très différentes qui peuvent sembler absurdes ou incorrectes à une personne ayant une bonne connaissance des bases de données relationnelles, mais qui sont logiques pour une personne menant une conception pour un magasin de paires clé/valeur NoSQL comme celui du service de Table Azure.</span><span class="sxs-lookup"><span data-stu-id="10689-106">These differences typically lead to very different designs that may look counter-intuitive or wrong to someone familiar with relational databases, but which do make good sense if you are designing for a NoSQL key/value store such as the Azure Table service.</span></span> <span data-ttu-id="10689-107">Bon nombre de différences de conception refléteront le fait que le service de Table est conçu pour prendre en charge des applications à l’échelle du cloud qui peuvent contenir des milliards d’entités (que la terminologie de base de données relationnelle appelle « des lignes ») de données ou des jeux de données devant prendre en charge des volumes de transactions très élevés : par conséquent, vous devez concevoir différemment la façon dont vous stockez vos données et comprendre comment fonctionne le service de Table.</span><span class="sxs-lookup"><span data-stu-id="10689-107">Many of your design differences will reflect the fact that the Table service is designed to support cloud-scale applications that can contain billions of entities (rows in relational database terminology) of data or for datasets that must support very high transaction volumes: therefore, you need to think differently about how you store your data and understand how the Table service works.</span></span> <span data-ttu-id="10689-108">Un magasin de données NoSQL bien conçu améliore l'étendue de la mise à l'échelle de votre solution, pour un coût inférieur à celui d'une solution utilisant une base de données relationnelle.</span><span class="sxs-lookup"><span data-stu-id="10689-108">A well designed NoSQL data store can enable your solution to scale much further (and at a lower cost) than a solution that uses a relational database.</span></span> <span data-ttu-id="10689-109">Ce guide fournit une aide relative à ces sujets.</span><span class="sxs-lookup"><span data-stu-id="10689-109">This guide helps you with these topics.</span></span>  

## <a name="about-the-azure-table-service"></a><span data-ttu-id="10689-110">À propos du service de Table Azure</span><span class="sxs-lookup"><span data-stu-id="10689-110">About the Azure Table service</span></span>
<span data-ttu-id="10689-111">Cette section présente certaines des principales fonctionnalités du service de Table qui sont particulièrement adaptées aux conceptions orientées vers l'amélioration des performances et de l'extensibilité.</span><span class="sxs-lookup"><span data-stu-id="10689-111">This section highlights some of the key features of the Table service that are especially relevant to designing for performance and scalability.</span></span> <span data-ttu-id="10689-112">Si vous ne connaissez pas Azure Storage et le service de Table, nous vous conseillons de commencer par lire les articles [Introduction à Microsoft Azure Storage](../storage/common/storage-introduction.md) et [Prise en main d’Azure Table Storage à l’aide de .NET](table-storage-how-to-use-dotnet.md) avant de lire le reste de cet article.</span><span class="sxs-lookup"><span data-stu-id="10689-112">If you are new to Azure Storage and the Table service, first read [Introduction to Microsoft Azure Storage](../storage/common/storage-introduction.md) and [Get started with Azure Table Storage using .NET](table-storage-how-to-use-dotnet.md) before reading the remainder of this article.</span></span> <span data-ttu-id="10689-113">Bien que ce guide porte sur le service de Table, il aborde également les services de File d'attente et BLOB Azure, en expliquant comment les utiliser avec le service de Table dans une solution.</span><span class="sxs-lookup"><span data-stu-id="10689-113">Although the focus of this guide is on the Table service, it will include some discussion of the Azure Queue and Blob services, and how you might use them along with the Table service in a solution.</span></span>  

<span data-ttu-id="10689-114">Qu'est-ce que le service de Table ?</span><span class="sxs-lookup"><span data-stu-id="10689-114">What is the Table service?</span></span> <span data-ttu-id="10689-115">Comme le laisse entendre son nom, le service de Table utilise un format tabulaire pour stocker des données.</span><span class="sxs-lookup"><span data-stu-id="10689-115">As you might expect from the name, the Table service uses a tabular format to store data.</span></span> <span data-ttu-id="10689-116">Selon la terminologie standard, chaque ligne de la table représente une entité et les colonnes stockent les différentes propriétés de cette entité.</span><span class="sxs-lookup"><span data-stu-id="10689-116">In the standard terminology, each row of the table represents an entity, and the columns store the various properties of that entity.</span></span> <span data-ttu-id="10689-117">Le service de Table identifie chaque entité de façon unique en utilisant une paire de clés. Il procède au suivi de mise à jour des entités en utilisant une colonne d'horodatage (cela se produit automatiquement et vous ne pouvez pas remplacer manuellement l'horodatage par une valeur de votre choix).</span><span class="sxs-lookup"><span data-stu-id="10689-117">Every entity has a pair of keys to uniquely identify it, and a timestamp column that the Table service uses to track when the entity was last updated (this happens automatically and you cannot manually overwrite the timestamp with an arbitrary value).</span></span> <span data-ttu-id="10689-118">Le service de Table utilise le dernier horodatage modifié (ou LMT, pour Last Modified Timestamp) afin de gérer l’accès concurrentiel optimiste.</span><span class="sxs-lookup"><span data-stu-id="10689-118">The Table service uses this last-modified timestamp (LMT) to manage optimistic concurrency.</span></span>  

> [!NOTE]
> <span data-ttu-id="10689-119">Les opérations d’API REST du service de Table renvoient également une valeur **ETag** dérivée du dernier horodatage modifié (LMT).</span><span class="sxs-lookup"><span data-stu-id="10689-119">The Table service REST API operations also return an **ETag** value that it derives from the last-modified timestamp (LMT).</span></span> <span data-ttu-id="10689-120">Dans ce document, nous allons utiliser indifféremment les termes ETag et LMT, car ils font référence aux mêmes données sous-jacentes.</span><span class="sxs-lookup"><span data-stu-id="10689-120">In this document we will use the terms ETag and LMT interchangeably because they refer to the same underlying data.</span></span>  
> 
> 

<span data-ttu-id="10689-121">L'exemple suivant présente la conception d'une table simple pour stocker des entités relatives à des employés (Employee) ainsi qu'à leurs services (Department).</span><span class="sxs-lookup"><span data-stu-id="10689-121">The following example shows a simple table design to store employee and department entities.</span></span> <span data-ttu-id="10689-122">Plusieurs des exemples présentés ultérieurement dans ce guide sont basés sur cette conception simple.</span><span class="sxs-lookup"><span data-stu-id="10689-122">Many of the examples shown later in this guide are based on this simple design.</span></span>  

<table>
<tr>
<th><span data-ttu-id="10689-123">PartitionKey</span><span class="sxs-lookup"><span data-stu-id="10689-123">PartitionKey</span></span></th>
<th><span data-ttu-id="10689-124">RowKey</span><span class="sxs-lookup"><span data-stu-id="10689-124">RowKey</span></span></th>
<th><span data-ttu-id="10689-125">Timestamp</span><span class="sxs-lookup"><span data-stu-id="10689-125">Timestamp</span></span></th>
<th></th>
</tr>
<tr>
<td><span data-ttu-id="10689-126">Marketing</span><span class="sxs-lookup"><span data-stu-id="10689-126">Marketing</span></span></td>
<td><span data-ttu-id="10689-127">00001</span><span class="sxs-lookup"><span data-stu-id="10689-127">00001</span></span></td>
<td><span data-ttu-id="10689-128">2014-08-22T00:50:32Z</span><span class="sxs-lookup"><span data-stu-id="10689-128">2014-08-22T00:50:32Z</span></span></td>
<td>
<table>
<tr>
<th><span data-ttu-id="10689-129">FirstName</span><span class="sxs-lookup"><span data-stu-id="10689-129">FirstName</span></span></th>
<th><span data-ttu-id="10689-130">LastName</span><span class="sxs-lookup"><span data-stu-id="10689-130">LastName</span></span></th>
<th><span data-ttu-id="10689-131">Age</span><span class="sxs-lookup"><span data-stu-id="10689-131">Age</span></span></th>
<th><span data-ttu-id="10689-132">Email</span><span class="sxs-lookup"><span data-stu-id="10689-132">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="10689-133">Don</span><span class="sxs-lookup"><span data-stu-id="10689-133">Don</span></span></td>
<td><span data-ttu-id="10689-134">Hall</span><span class="sxs-lookup"><span data-stu-id="10689-134">Hall</span></span></td>
<td><span data-ttu-id="10689-135">34</span><span class="sxs-lookup"><span data-stu-id="10689-135">34</span></span></td>
<td>donh@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td><span data-ttu-id="10689-136">Marketing</span><span class="sxs-lookup"><span data-stu-id="10689-136">Marketing</span></span></td>
<td><span data-ttu-id="10689-137">00002</span><span class="sxs-lookup"><span data-stu-id="10689-137">00002</span></span></td>
<td><span data-ttu-id="10689-138">2014-08-22T00:50:34Z</span><span class="sxs-lookup"><span data-stu-id="10689-138">2014-08-22T00:50:34Z</span></span></td>
<td>
<table>
<tr>
<th><span data-ttu-id="10689-139">FirstName</span><span class="sxs-lookup"><span data-stu-id="10689-139">FirstName</span></span></th>
<th><span data-ttu-id="10689-140">LastName</span><span class="sxs-lookup"><span data-stu-id="10689-140">LastName</span></span></th>
<th><span data-ttu-id="10689-141">Age</span><span class="sxs-lookup"><span data-stu-id="10689-141">Age</span></span></th>
<th><span data-ttu-id="10689-142">Email</span><span class="sxs-lookup"><span data-stu-id="10689-142">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="10689-143">Jun</span><span class="sxs-lookup"><span data-stu-id="10689-143">Jun</span></span></td>
<td><span data-ttu-id="10689-144">Cao</span><span class="sxs-lookup"><span data-stu-id="10689-144">Cao</span></span></td>
<td><span data-ttu-id="10689-145">47</span><span class="sxs-lookup"><span data-stu-id="10689-145">47</span></span></td>
<td>junc@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td><span data-ttu-id="10689-146">Marketing</span><span class="sxs-lookup"><span data-stu-id="10689-146">Marketing</span></span></td>
<td><span data-ttu-id="10689-147">Département</span><span class="sxs-lookup"><span data-stu-id="10689-147">Department</span></span></td>
<td><span data-ttu-id="10689-148">2014-08-22T00:50:30Z</span><span class="sxs-lookup"><span data-stu-id="10689-148">2014-08-22T00:50:30Z</span></span></td>
<td>
<table>
<tr>
<th><span data-ttu-id="10689-149">DepartmentName</span><span class="sxs-lookup"><span data-stu-id="10689-149">DepartmentName</span></span></th>
<th><span data-ttu-id="10689-150">EmployeeCount</span><span class="sxs-lookup"><span data-stu-id="10689-150">EmployeeCount</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="10689-151">Marketing</span><span class="sxs-lookup"><span data-stu-id="10689-151">Marketing</span></span></td>
<td><span data-ttu-id="10689-152">153</span><span class="sxs-lookup"><span data-stu-id="10689-152">153</span></span></td>
</tr>
</table>
</td>
</tr>
<tr>
<td><span data-ttu-id="10689-153">Sales</span><span class="sxs-lookup"><span data-stu-id="10689-153">Sales</span></span></td>
<td><span data-ttu-id="10689-154">00010</span><span class="sxs-lookup"><span data-stu-id="10689-154">00010</span></span></td>
<td><span data-ttu-id="10689-155">2014-08-22T00:50:44Z</span><span class="sxs-lookup"><span data-stu-id="10689-155">2014-08-22T00:50:44Z</span></span></td>
<td>
<table>
<tr>
<th><span data-ttu-id="10689-156">FirstName</span><span class="sxs-lookup"><span data-stu-id="10689-156">FirstName</span></span></th>
<th><span data-ttu-id="10689-157">LastName</span><span class="sxs-lookup"><span data-stu-id="10689-157">LastName</span></span></th>
<th><span data-ttu-id="10689-158">Age</span><span class="sxs-lookup"><span data-stu-id="10689-158">Age</span></span></th>
<th><span data-ttu-id="10689-159">Email</span><span class="sxs-lookup"><span data-stu-id="10689-159">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="10689-160">Ken</span><span class="sxs-lookup"><span data-stu-id="10689-160">Ken</span></span></td>
<td><span data-ttu-id="10689-161">Kwok</span><span class="sxs-lookup"><span data-stu-id="10689-161">Kwok</span></span></td>
<td><span data-ttu-id="10689-162">23</span><span class="sxs-lookup"><span data-stu-id="10689-162">23</span></span></td>
<td>kenk@contoso.com</td>
</tr>
</table>
</td>
</tr>
</table>


<span data-ttu-id="10689-163">Jusqu'ici, tout ceci ressemble à une table de base de données relationnelle, les principales différences étant les colonnes obligatoires et la possibilité de stocker plusieurs types d'entité dans la même table.</span><span class="sxs-lookup"><span data-stu-id="10689-163">So far, this looks very similar to a table in a relational database with the key differences being the mandatory columns, and the ability to store multiple entity types in the same table.</span></span> <span data-ttu-id="10689-164">En outre, chacune des propriétés définies par l’utilisateur, telles que **FirstName** ou **Age**, est caractérisée par un type de données, par exemple un nombre entier ou une chaîne, tout comme une colonne dans une base de données relationnelle.</span><span class="sxs-lookup"><span data-stu-id="10689-164">In addition, each of the user-defined properties such as **FirstName** or **Age** has a data type, such as integer or string, just like a column in a relational database.</span></span> <span data-ttu-id="10689-165">Bien que, contrairement à une base de données relationnelle, la nature sans schéma du service de Table signifie qu'une propriété n'a pas nécessairement besoin d'avoir les mêmes types de données pour chaque entité.</span><span class="sxs-lookup"><span data-stu-id="10689-165">Although unlike in a relational database, the schema-less nature of the Table service means that a property need not have the same data type on each entity.</span></span> <span data-ttu-id="10689-166">Pour stocker des types de données complexes dans une seule propriété, vous devez utiliser un format sérialisé comme JSON ou XML.</span><span class="sxs-lookup"><span data-stu-id="10689-166">To store complex data types in a single property, you must use a serialized format such as JSON or XML.</span></span> <span data-ttu-id="10689-167">Pour plus d’informations sur les plages de dates et les types de données pris en charge, les règles d’affectation de noms et les contraintes de taille, consultez l’article [Présentation du modèle de données du service de Table](http://msdn.microsoft.com/library/azure/dd179338.aspx).</span><span class="sxs-lookup"><span data-stu-id="10689-167">For more information about the table service such as supported data types, supported date ranges, naming rules, and size constraints, see [Understanding the Table Service Data Model](http://msdn.microsoft.com/library/azure/dd179338.aspx).</span></span>

<span data-ttu-id="10689-168">Comme vous le verrez, le choix d’une valeur de **PartitionKey** et de **RowKey** est important pour une bonne conception de table.</span><span class="sxs-lookup"><span data-stu-id="10689-168">As you will see, your choice of **PartitionKey** and **RowKey** is fundamental to good table design.</span></span> <span data-ttu-id="10689-169">Toutes les entités stockées dans une table doivent avoir une combinaison unique de **PartitionKey** et **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="10689-169">Every entity stored in a table must have a unique combination of **PartitionKey** and **RowKey**.</span></span> <span data-ttu-id="10689-170">Comme avec les clés d’une table de base de données relationnelle, les valeurs de **PartitionKey** et de **RowKey** sont indexées pour créer un index ordonné en clusters qui permet la recherche rapide. Toutefois, le service de Table ne crée pas d’index secondaires : ces deux propriétés sont donc les seules indexées (certains des modèles décrits plus loin montrent comment vous pouvez contourner cette limitation).</span><span class="sxs-lookup"><span data-stu-id="10689-170">As with keys in a relational database table, the **PartitionKey** and **RowKey** values are indexed to create a clustered index that enables fast look-ups; however, the Table service does not create any secondary indexes so these are the only two indexed properties (some of the patterns described later show how you can work around this apparent limitation).</span></span>  

<span data-ttu-id="10689-171">Une table est constituée d’une ou plusieurs partitions et comme vous le verrez, la plupart des décisions de conception que vous prendrez consisteront à choisir une valeur de **PartitionKey** et de **RowKey** adaptée pour optimiser votre solution.</span><span class="sxs-lookup"><span data-stu-id="10689-171">A table is made up of one or more partitions, and as you will see, many of the design decisions you make will be around choosing a suitable **PartitionKey** and **RowKey** to optimize your solution.</span></span> <span data-ttu-id="10689-172">En guise de solution, vous pouvez utiliser une seule table contenant toutes vos entités organisées en partitions, mais généralement, une solution possède plusieurs tables.</span><span class="sxs-lookup"><span data-stu-id="10689-172">A solution could consist of just a single table that contains all your entities organized into partitions, but typically a solution will have multiple tables.</span></span> <span data-ttu-id="10689-173">Les tables vous permettent d'organiser vos entités logiquement, de gérer l'accès aux données en utilisant des listes de contrôle d'accès, et de supprimer une table entière à l'aide d'une opération de stockage unique.</span><span class="sxs-lookup"><span data-stu-id="10689-173">Tables help you to logically organize your entities, help you manage access to the data using access control lists, and you can drop an entire table using a single storage operation.</span></span>  

### <a name="table-partitions"></a><span data-ttu-id="10689-174">Partitions de table</span><span class="sxs-lookup"><span data-stu-id="10689-174">Table partitions</span></span>
<span data-ttu-id="10689-175">Le nom du compte, le nom de la table et la valeur de **PartitionKey** identifient la partition dans le service de stockage où le service de Table stocke l’entité.</span><span class="sxs-lookup"><span data-stu-id="10689-175">The account name, table name and **PartitionKey** together identify the partition within the storage service where the table service stores the entity.</span></span> <span data-ttu-id="10689-176">Tout en appartenant au schéma d’adressage des entités, les partitions définissent une étendue pour les transactions (pour en savoir plus, consultez [Transactions de groupe d’entités](#entity-group-transactions) ci-dessous) et constituent la base de la méthode de mise à l’échelle du service de Table.</span><span class="sxs-lookup"><span data-stu-id="10689-176">As well as being part of the addressing scheme for entities, partitions define a scope for transactions (see [Entity Group Transactions](#entity-group-transactions) below), and form the basis of how the table service scales.</span></span> <span data-ttu-id="10689-177">Pour plus d’informations sur les partitions, consultez [Objectifs d’évolutivité et de performances d’Azure Storage](../storage/common/storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="10689-177">For more information on partitions see [Azure Storage Scalability and Performance Targets](../storage/common/storage-scalability-targets.md).</span></span>  

<span data-ttu-id="10689-178">Dans le service de Table, un nœud individuel traite une ou plusieurs partitions complètes et le service se met à l'échelle en procédant à l'équilibrage de charge dynamique des partitions sur les nœuds.</span><span class="sxs-lookup"><span data-stu-id="10689-178">In the Table service, an individual node services one or more complete partitions and the service scales by dynamically load-balancing partitions across nodes.</span></span> <span data-ttu-id="10689-179">Si un nœud est en sous-charge, le service de Table peut *fractionner* la plage de partitions traitées par ce nœud en différents nœuds. En cas de réduction du trafic, le service peut *fusionner* les plages de partitions à partir des nœuds silencieux en un nœud unique.</span><span class="sxs-lookup"><span data-stu-id="10689-179">If a node is under load, the table service can *split* the range of partitions serviced by that node onto different nodes; when traffic subsides, the service can *merge* the partition ranges from quiet nodes back onto a single node.</span></span>  

<span data-ttu-id="10689-180">Pour plus d’informations sur les détails internes du service de Table et notamment la façon dont le service gère les partitions, consultez la documentation [Microsoft Azure Storage : service de stockage sur le cloud à haute disponibilité et à cohérence forte](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx).</span><span class="sxs-lookup"><span data-stu-id="10689-180">For more information about the internal details of the Table service, and in particular how the service manages partitions, see the paper [Microsoft Azure Storage: A Highly Available Cloud Storage Service with Strong Consistency](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx).</span></span>  

### <a name="entity-group-transactions"></a><span data-ttu-id="10689-181">Transactions de groupe d’entités</span><span class="sxs-lookup"><span data-stu-id="10689-181">Entity Group Transactions</span></span>
<span data-ttu-id="10689-182">Dans le service de Table, les transactions de groupe d'entités (EGT) constituent l'unique mécanisme intégré pour effectuer des mises à jour atomiques entre plusieurs entités.</span><span class="sxs-lookup"><span data-stu-id="10689-182">In the Table service, Entity Group Transactions (EGTs) are the only built-in mechanism for performing atomic updates across multiple entities.</span></span> <span data-ttu-id="10689-183">Les transactions EGT sont également appelées *transactions par lots* dans certaines documentations.</span><span class="sxs-lookup"><span data-stu-id="10689-183">EGTs are also referred to as *batch transactions* in some documentation.</span></span> <span data-ttu-id="10689-184">Les transactions EGT peuvent uniquement utiliser des entités stockées dans la même partition (partage de la même clé de partition dans une table donnée). Par conséquent, quand vous avez besoin d'un comportement transactionnel atomique entre plusieurs entités, vous devez vérifier que ces entités sont dans la même partition.</span><span class="sxs-lookup"><span data-stu-id="10689-184">EGTs can only operate on entities stored in the same partition (share the same partition key in a given table), so anytime you need atomic transactional behavior across multiple entities you need to ensure that those entities are in the same partition.</span></span> <span data-ttu-id="10689-185">Ceci justifie souvent la conservation de plusieurs types d'entité dans la même table (et partition) au lieu de l'utilisation de plusieurs tables pour différents types d'entité.</span><span class="sxs-lookup"><span data-stu-id="10689-185">This is often a reason for keeping multiple entity types in the same table (and partition) and not using multiple tables for different entity types.</span></span> <span data-ttu-id="10689-186">Une seule EGT peut traiter jusqu'à 100 entités.</span><span class="sxs-lookup"><span data-stu-id="10689-186">A single EGT can operate on at most 100 entities.</span></span>  <span data-ttu-id="10689-187">Si vous envoyez plusieurs EGT simultanées pour traitement, il est important de s’assurer que ces EGT n’utilisent pas des entités communes aux différentes EGT. Sinon, le traitement risque d’être retardé.</span><span class="sxs-lookup"><span data-stu-id="10689-187">If you submit multiple concurrent EGTs for processing it is important to ensure  those EGTs do not operate on entities that are common across EGTs as otherwise processing can be delayed.</span></span>

<span data-ttu-id="10689-188">Les EGT entraînent également un compromis potentiel à évaluer dans votre conception : l'utilisation de plusieurs partitions augmente l'extensibilité de votre application, car Azure dispose de davantage d'opportunités pour les demandes d'équilibrage entre les nœuds, mais cela peut limiter la capacité de votre application à effectuer des transactions atomiques et à maintenir une forte cohérence de vos données.</span><span class="sxs-lookup"><span data-stu-id="10689-188">EGTs also introduce a potential trade-off for you to evaluate in your design: using more partitions will increase the scalability of your application because Azure has more opportunities for load balancing requests across nodes, but this might limit the ability of your application to perform atomic transactions and maintain strong consistency for your data.</span></span> <span data-ttu-id="10689-189">En outre, certains objectifs d’extensibilité spécifiques au niveau d’une partition peuvent limiter le débit des transactions que vous pouvez attendre pour un même nœud : pour plus d’informations sur les objectifs d’extensibilité pour les comptes de stockage Azure et le service de Table, consultez [Objectifs d’extensibilité et de performances d’Azure Storage](../storage/common/storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="10689-189">Furthermore, there are specific scalability targets at the level of a partition that might limit the throughput of transactions you can expect for a single node: for more information about the scalability targets for Azure storage accounts and the table service, see [Azure Storage Scalability and Performance Targets](../storage/common/storage-scalability-targets.md).</span></span> <span data-ttu-id="10689-190">Les sections ultérieures de ce guide présenteront différentes stratégies de conception pour vous aider à gérer les compromis tels que celui-ci et décrivent les meilleures méthodes pour choisir votre clé de partition en fonction des exigences spécifiques de votre application cliente.</span><span class="sxs-lookup"><span data-stu-id="10689-190">Later sections of this guide discuss various design strategies that help you manage trade-offs such as this one, and discuss how best to choose your partition key based on the specific requirements of your client application.</span></span>  

### <a name="capacity-considerations"></a><span data-ttu-id="10689-191">Considérations relatives à la capacité</span><span class="sxs-lookup"><span data-stu-id="10689-191">Capacity considerations</span></span>
<span data-ttu-id="10689-192">Le tableau suivant présente certaines des valeurs de clés à connaître lorsque vous concevez une solution de service de Table :</span><span class="sxs-lookup"><span data-stu-id="10689-192">The following table includes some of the key values to be aware of when you are designing a Table service solution:</span></span>  

| <span data-ttu-id="10689-193">Capacité totale d'un compte de stockage Azure</span><span class="sxs-lookup"><span data-stu-id="10689-193">Total capacity of an Azure storage account</span></span> | <span data-ttu-id="10689-194">500 To</span><span class="sxs-lookup"><span data-stu-id="10689-194">500 TB</span></span> |
| --- | --- |
| <span data-ttu-id="10689-195">Nombre de tables dans un compte de stockage Azure</span><span class="sxs-lookup"><span data-stu-id="10689-195">Number of tables in an Azure storage account</span></span> |<span data-ttu-id="10689-196">Limité uniquement par la capacité du compte de stockage</span><span class="sxs-lookup"><span data-stu-id="10689-196">Limited only by the capacity of the storage account</span></span> |
| <span data-ttu-id="10689-197">Nombre de partitions dans une table</span><span class="sxs-lookup"><span data-stu-id="10689-197">Number of partitions in a table</span></span> |<span data-ttu-id="10689-198">Limité uniquement par la capacité du compte de stockage</span><span class="sxs-lookup"><span data-stu-id="10689-198">Limited only by the capacity of the storage account</span></span> |
| <span data-ttu-id="10689-199">Nombre d'entités dans une partition</span><span class="sxs-lookup"><span data-stu-id="10689-199">Number of entities in a partition</span></span> |<span data-ttu-id="10689-200">Limité uniquement par la capacité du compte de stockage</span><span class="sxs-lookup"><span data-stu-id="10689-200">Limited only by the capacity of the storage account</span></span> |
| <span data-ttu-id="10689-201">Taille d'une entité individuelle</span><span class="sxs-lookup"><span data-stu-id="10689-201">Size of an individual entity</span></span> |<span data-ttu-id="10689-202">Jusqu’à 1 Mo, avec un maximum de 255 propriétés (y compris **PartitionKey**, **RowKey** et **Timestamp**)</span><span class="sxs-lookup"><span data-stu-id="10689-202">Up to 1 MB with a maximum of 255 properties (including the **PartitionKey**, **RowKey**, and **Timestamp**)</span></span> |
| <span data-ttu-id="10689-203">Taille de la **PartitionKey**</span><span class="sxs-lookup"><span data-stu-id="10689-203">Size of the **PartitionKey**</span></span> |<span data-ttu-id="10689-204">Chaîne jusqu'à 1 Ko</span><span class="sxs-lookup"><span data-stu-id="10689-204">A string up to 1 KB in size</span></span> |
| <span data-ttu-id="10689-205">Taille de la **RowKey**</span><span class="sxs-lookup"><span data-stu-id="10689-205">Size of the **RowKey**</span></span> |<span data-ttu-id="10689-206">Chaîne jusqu'à 1 Ko</span><span class="sxs-lookup"><span data-stu-id="10689-206">A string up to 1 KB in size</span></span> |
| <span data-ttu-id="10689-207">Taille d'une transaction ETG</span><span class="sxs-lookup"><span data-stu-id="10689-207">Size of an Entity Group Transaction</span></span> |<span data-ttu-id="10689-208">Une transaction peut inclure au plus 100 entités et la charge utile doit être inférieure à 4 Mo.</span><span class="sxs-lookup"><span data-stu-id="10689-208">A transaction can include at most 100 entities and the payload must be less than 4 MB in size.</span></span> <span data-ttu-id="10689-209">Une transaction EGT ne peut mettre à jour une entité qu'une seule fois.</span><span class="sxs-lookup"><span data-stu-id="10689-209">An EGT can only update an entity once.</span></span> |

<span data-ttu-id="10689-210">Pour plus d'informations, consultez la rubrique [Présentation du modèle de données du service de Table](http://msdn.microsoft.com/library/azure/dd179338.aspx).</span><span class="sxs-lookup"><span data-stu-id="10689-210">For more information, see [Understanding the Table Service Data Model](http://msdn.microsoft.com/library/azure/dd179338.aspx).</span></span>  

### <a name="cost-considerations"></a><span data-ttu-id="10689-211">Considérations relatives au coût</span><span class="sxs-lookup"><span data-stu-id="10689-211">Cost considerations</span></span>
<span data-ttu-id="10689-212">Le stockage de table est relativement peu coûteux, mais vous devez y inclure les estimations de coût pour l'utilisation des capacités et la quantité de transactions dans le cadre de l'évaluation d'une solution qui utilise le service de Table.</span><span class="sxs-lookup"><span data-stu-id="10689-212">Table storage is relatively inexpensive, but you should include cost estimates for both capacity usage and the quantity of transactions as part of your evaluation of any solution that uses the Table service.</span></span> <span data-ttu-id="10689-213">Toutefois, dans de nombreux scénarios, le stockage de données dénormalisées ou dupliquées afin d'améliorer les performances ou l'extensibilité de votre solution est une approche appropriée.</span><span class="sxs-lookup"><span data-stu-id="10689-213">However, in many scenarios storing denormalized or duplicate data in order to improve the performance or scalability of your solution is a valid approach to take.</span></span> <span data-ttu-id="10689-214">Pour plus d’informations sur la tarification, consultez la page [Tarification Azure Storage](https://azure.microsoft.com/pricing/details/storage/).</span><span class="sxs-lookup"><span data-stu-id="10689-214">For more information about pricing, see [Azure Storage Pricing](https://azure.microsoft.com/pricing/details/storage/).</span></span>  

## <a name="guidelines-for-table-design"></a><span data-ttu-id="10689-215">Conseils pour la conception de table</span><span class="sxs-lookup"><span data-stu-id="10689-215">Guidelines for table design</span></span>
<span data-ttu-id="10689-216">Ces listes résument certains des principaux conseils que vous devez garder à l’esprit lorsque vous concevez vos tables. Ces conseils seront détaillés ultérieurement dans ce guide.</span><span class="sxs-lookup"><span data-stu-id="10689-216">These lists summarize some of the key guidelines you should keep in mind when you are designing your tables, and this guide will address them all in more detail later in.</span></span> <span data-ttu-id="10689-217">Ils sont très différents de ceux généralement prodigués pour la conception d’une base de données relationnelle.</span><span class="sxs-lookup"><span data-stu-id="10689-217">These guidelines are very different from the guidelines you would typically follow for relational database design.</span></span>  

<span data-ttu-id="10689-218">Conception de votre solution de service de Table pour une *lecture* efficace :</span><span class="sxs-lookup"><span data-stu-id="10689-218">Designing your Table service solution to be *read* efficient:</span></span>

* <span data-ttu-id="10689-219">***Pensez votre conception pour l’interrogation dans des applications à lecture intensive.***</span><span class="sxs-lookup"><span data-stu-id="10689-219">***Design for querying in read-heavy applications.***</span></span> <span data-ttu-id="10689-220">Lorsque vous concevez vos tables, pensez aux requêtes que vous allez exécuter (en particulier celles sensibles à la latence) avant de réfléchir à la méthode de mise à jour de vos entités.</span><span class="sxs-lookup"><span data-stu-id="10689-220">When you are designing your tables, think about the queries (especially the latency sensitive ones) that you will execute before you think about how you will update your entities.</span></span> <span data-ttu-id="10689-221">Cela permet généralement d’élaborer une solution efficace et performante.</span><span class="sxs-lookup"><span data-stu-id="10689-221">This typically results in an efficient and performant solution.</span></span>  
* <span data-ttu-id="10689-222">***Spécifiez les valeurs de PartitionKey et de RowKey dans vos requêtes.***</span><span class="sxs-lookup"><span data-stu-id="10689-222">***Specify both PartitionKey and RowKey in your queries.***</span></span> <span data-ttu-id="10689-223">*requêtes de pointage* telles que celles-ci sont les requêtes de service de Table les plus efficaces.</span><span class="sxs-lookup"><span data-stu-id="10689-223">*Point queries* such as these are the most efficient table service queries.</span></span>  
* <span data-ttu-id="10689-224">***Envisagez de stocker des copies dupliquées des entités.***</span><span class="sxs-lookup"><span data-stu-id="10689-224">***Consider storing duplicate copies of entities.***</span></span> <span data-ttu-id="10689-225">Le stockage de table est bon marché. Vous pourriez donc stocker la même entité plusieurs fois (avec différentes clés) pour rendre les requêtes plus efficaces.</span><span class="sxs-lookup"><span data-stu-id="10689-225">Table storage is cheap so consider storing the same entity multiple times (with different keys) to enable more efficient queries.</span></span>  
* <span data-ttu-id="10689-226">***Envisagez de dénormaliser vos données.***</span><span class="sxs-lookup"><span data-stu-id="10689-226">***Consider denormalizing your data.***</span></span> <span data-ttu-id="10689-227">Le stockage de tables est bon marché. Nous vous recommandons donc d’envisager la dénormalisation de vos données.</span><span class="sxs-lookup"><span data-stu-id="10689-227">Table storage is cheap so consider denormalizing your data.</span></span> <span data-ttu-id="10689-228">Par exemple, stockez des entités de résumé pour que les requêtes d’agrégation de données aient seulement besoin d’accéder à une entité unique.</span><span class="sxs-lookup"><span data-stu-id="10689-228">For example, store summary entities so that queries for aggregate data only need to access a single entity.</span></span>  
* <span data-ttu-id="10689-229">***Utilisez des valeurs de clé composées.***</span><span class="sxs-lookup"><span data-stu-id="10689-229">***Use compound key values.***</span></span> <span data-ttu-id="10689-230">Les seules clés dont vous disposez sont **PartitionKey** et **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="10689-230">The only keys you have are **PartitionKey** and **RowKey**.</span></span> <span data-ttu-id="10689-231">Par exemple, utilisez des valeurs de clé composées pour activer les chemins d’accès de clé de substitution pour les entités.</span><span class="sxs-lookup"><span data-stu-id="10689-231">For example, use compound key values to enable alternate keyed access paths to entities.</span></span>  
* <span data-ttu-id="10689-232">***Utilisez la projection de requête.***</span><span class="sxs-lookup"><span data-stu-id="10689-232">***Use query projection.***</span></span> <span data-ttu-id="10689-233">Vous pouvez réduire la quantité de données que vous transférez sur le réseau en utilisant des requêtes qui sélectionnent uniquement les champs dont vous avez besoin.</span><span class="sxs-lookup"><span data-stu-id="10689-233">You can reduce the amount of data that you transfer over the network by using queries that select just the fields you need.</span></span>  

<span data-ttu-id="10689-234">Conception de votre solution de service de Table pour une *écriture* efficace :</span><span class="sxs-lookup"><span data-stu-id="10689-234">Designing your Table service solution to be *write* efficient:</span></span>  

* <span data-ttu-id="10689-235">***Ne créez pas de partitions à chaud.***</span><span class="sxs-lookup"><span data-stu-id="10689-235">***Do not create hot partitions.***</span></span> <span data-ttu-id="10689-236">Choisissez des clés qui vous permettent de répartir vos requêtes sur plusieurs partitions à tout moment.</span><span class="sxs-lookup"><span data-stu-id="10689-236">Choose keys that enable you to spread your requests across multiple partitions at any point of time.</span></span>  
* <span data-ttu-id="10689-237">***Évitez les pics de trafic.***</span><span class="sxs-lookup"><span data-stu-id="10689-237">***Avoid spikes in traffic.***</span></span> <span data-ttu-id="10689-238">Fluidifiez le trafic sur une période de temps raisonnable et évitez les pics de trafic.</span><span class="sxs-lookup"><span data-stu-id="10689-238">Smooth the traffic over a reasonable period of time and avoid spikes in traffic.</span></span>
* <span data-ttu-id="10689-239">***Ne créez pas nécessairement une table distincte pour chaque type d’entité.***</span><span class="sxs-lookup"><span data-stu-id="10689-239">***Don't necessarily create a separate table for each type of entity.***</span></span> <span data-ttu-id="10689-240">Lorsque vous avez besoin d’utiliser des transactions atomiques sur des types d’entité, vous pouvez stocker ces types d’entité multiples dans la même partition de la même table.</span><span class="sxs-lookup"><span data-stu-id="10689-240">When you require atomic transactions across entity types, you can store these multiple entity types in the same partition in the same table.</span></span>
* <span data-ttu-id="10689-241">***Prévoyez le débit maximal nécessaire.***</span><span class="sxs-lookup"><span data-stu-id="10689-241">***Consider the maximum throughput you must achieve.***</span></span> <span data-ttu-id="10689-242">Vous devez connaître les objectifs d'extensibilité du service de Table et vous assurer que votre conception n'entraînera pas de dépassement.</span><span class="sxs-lookup"><span data-stu-id="10689-242">You must be aware of the scalability targets for the Table service and ensure that your design will not cause you to exceed them.</span></span>  

<span data-ttu-id="10689-243">En lisant ce guide, vous rencontrerez des exemples mettant ces principes en pratique.</span><span class="sxs-lookup"><span data-stu-id="10689-243">As you read this guide, you will see examples that put all of these principles into practice.</span></span>  

## <a name="design-for-querying"></a><span data-ttu-id="10689-244">Conception pour l'interrogation</span><span class="sxs-lookup"><span data-stu-id="10689-244">Design for querying</span></span>
<span data-ttu-id="10689-245">Les solutions de service de Table peuvent lire ou écrire de façon intensive, ou effectuer une combinaison des deux.</span><span class="sxs-lookup"><span data-stu-id="10689-245">Table service solutions may be read intensive, write intensive, or a mix of the two.</span></span> <span data-ttu-id="10689-246">Cette section se concentre sur les éléments à prendre en compte lors de la conception de votre service de Table pour prendre en charge efficacement les opérations de lecture.</span><span class="sxs-lookup"><span data-stu-id="10689-246">This section focuses on the things to bear in mind when you are designing your Table service to support read operations efficiently.</span></span> <span data-ttu-id="10689-247">En règle générale, une conception qui prend en charge les opérations de lecture de manière efficace le sera également pour des opérations d'écriture.</span><span class="sxs-lookup"><span data-stu-id="10689-247">Typically, a design that supports read operations efficiently is also efficient for write operations.</span></span> <span data-ttu-id="10689-248">Toutefois, vous devez prendre en compte d’autres éléments lors de votre conception afin de prendre en charge les opérations d’écriture. Ces éléments sont abordés dans la section suivante intitulée [Conception pour la modification de données](#design-for-data-modification).</span><span class="sxs-lookup"><span data-stu-id="10689-248">However, there are additional considerations to bear in mind when designing to support write operations, discussed in the next section, [Design for data modification](#design-for-data-modification).</span></span>

<span data-ttu-id="10689-249">Un bon point de départ pour concevoir votre solution de service de Table afin de vous permettre de lire les données efficacement consiste à vous demander quelles requêtes votre application devra exécuter pour extraire du service de Table les données dont elle aura besoin.</span><span class="sxs-lookup"><span data-stu-id="10689-249">A good starting point for designing your Table service solution to enable you to read data efficiently is to ask "What queries will my application need to execute to retrieve the data it needs from the Table service?"</span></span>  

> [!NOTE]
> <span data-ttu-id="10689-250">Avec le service de Table, il est important de mettre en place une conception efficace dès le début, car il est difficile et coûteux de la modifier ultérieurement.</span><span class="sxs-lookup"><span data-stu-id="10689-250">With the Table service, it's important to get the design correct up front because it's difficult and expensive to change it later.</span></span> <span data-ttu-id="10689-251">Par exemple, dans une base de données relationnelle, il est souvent possible de résoudre les problèmes de performances simplement en ajoutant des index à une base de données existante : cela n’est pas possible avec le service de Table.</span><span class="sxs-lookup"><span data-stu-id="10689-251">For example, in a relational database it's often possible to address performance issues simply by adding indexes to an existing database: this is not an option with the Table service.</span></span>  
> 
> 

<span data-ttu-id="10689-252">Cette section se concentre sur les problèmes à traiter lors de la conception de vos tables pour l'interrogation.</span><span class="sxs-lookup"><span data-stu-id="10689-252">This section focuses on the key issues you must address when you design your tables for querying.</span></span> <span data-ttu-id="10689-253">Les sujets abordés dans cette section sont les suivants :</span><span class="sxs-lookup"><span data-stu-id="10689-253">The topics covered in this section include:</span></span>

* [<span data-ttu-id="10689-254">Impact de votre choix de PartitionKey et RowKey sur les performances des requêtes</span><span class="sxs-lookup"><span data-stu-id="10689-254">How your choice of PartitionKey and RowKey impacts query performance</span></span>](#how-your-choice-of-partitionkey-and-rowkey-impacts-query-performance)
* [<span data-ttu-id="10689-255">Choix d’une PartitionKey appropriée</span><span class="sxs-lookup"><span data-stu-id="10689-255">Choosing an appropriate PartitionKey</span></span>](#choosing-an-appropriate-partitionkey)
* [<span data-ttu-id="10689-256">Optimisation des requêtes pour le service de Table</span><span class="sxs-lookup"><span data-stu-id="10689-256">Optimizing queries for the Table service</span></span>](#optimizing-queries-for-the-table-service)
* [<span data-ttu-id="10689-257">Tri des données dans le service de Table</span><span class="sxs-lookup"><span data-stu-id="10689-257">Sorting data in the Table service</span></span>](#sorting-data-in-the-table-service)

### <a name="how-your-choice-of-partitionkey-and-rowkey-impacts-query-performance"></a><span data-ttu-id="10689-258">Impact de votre choix de PartitionKey et RowKey sur les performances des requêtes</span><span class="sxs-lookup"><span data-stu-id="10689-258">How your choice of PartitionKey and RowKey impacts query performance</span></span>
<span data-ttu-id="10689-259">Les exemples suivants supposent que le service de Table stocke les entités relatives aux employés (employee) en utilisant la structure suivante (la plupart des exemples omettent la propriété **Timestamp** par souci de clarté) :</span><span class="sxs-lookup"><span data-stu-id="10689-259">The following examples assume the table service is storing employee entities with the following structure (most of the examples omit the **Timestamp** property for clarity):</span></span>  

| <span data-ttu-id="10689-260">*Nom de la colonne*</span><span class="sxs-lookup"><span data-stu-id="10689-260">*Column name*</span></span> | <span data-ttu-id="10689-261">*Type de données*</span><span class="sxs-lookup"><span data-stu-id="10689-261">*Data type*</span></span> |
| --- | --- |
| <span data-ttu-id="10689-262">**PartitionKey** (nom du service)</span><span class="sxs-lookup"><span data-stu-id="10689-262">**PartitionKey** (Department Name)</span></span> |<span data-ttu-id="10689-263">String</span><span class="sxs-lookup"><span data-stu-id="10689-263">String</span></span> |
| <span data-ttu-id="10689-264">**RowKey** (ID d’employé)</span><span class="sxs-lookup"><span data-stu-id="10689-264">**RowKey** (Employee Id)</span></span> |<span data-ttu-id="10689-265">String</span><span class="sxs-lookup"><span data-stu-id="10689-265">String</span></span> |
| <span data-ttu-id="10689-266">**FirstName**</span><span class="sxs-lookup"><span data-stu-id="10689-266">**FirstName**</span></span> |<span data-ttu-id="10689-267">String</span><span class="sxs-lookup"><span data-stu-id="10689-267">String</span></span> |
| <span data-ttu-id="10689-268">**LastName**</span><span class="sxs-lookup"><span data-stu-id="10689-268">**LastName**</span></span> |<span data-ttu-id="10689-269">String</span><span class="sxs-lookup"><span data-stu-id="10689-269">String</span></span> |
| <span data-ttu-id="10689-270">**Age**</span><span class="sxs-lookup"><span data-stu-id="10689-270">**Age**</span></span> |<span data-ttu-id="10689-271">Integer</span><span class="sxs-lookup"><span data-stu-id="10689-271">Integer</span></span> |
| <span data-ttu-id="10689-272">**EmailAddress**</span><span class="sxs-lookup"><span data-stu-id="10689-272">**EmailAddress**</span></span> |<span data-ttu-id="10689-273">String</span><span class="sxs-lookup"><span data-stu-id="10689-273">String</span></span> |

<span data-ttu-id="10689-274">La section précédente [Présentation du service de Table Azure](#overview) décrit quelques-unes des principales fonctionnalités du service de Table Azure qui ont un impact direct sur la conception des requêtes.</span><span class="sxs-lookup"><span data-stu-id="10689-274">The earlier section [Azure Table service overview](#overview) describes some of the key features of the Azure Table service that have a direct influence on designing for query.</span></span> <span data-ttu-id="10689-275">Il en résulte les conseils suivants, qui vous aideront à concevoir des requêtes de service de Table.</span><span class="sxs-lookup"><span data-stu-id="10689-275">These result in the following general guidelines for designing Table service queries.</span></span> <span data-ttu-id="10689-276">Notez que la syntaxe de filtre utilisée dans les exemples ci-dessous provient de l’API REST du service de Table. Pour en savoir plus, consultez la rubrique [Interrogation d’entités](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span><span class="sxs-lookup"><span data-stu-id="10689-276">Note that the filter syntax used in the examples below is from the Table service REST API, for more information see [Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span></span>  

* <span data-ttu-id="10689-277">Une ***requête de pointage*** constitue la méthode de recherche la plus efficace. Elle est recommandée pour les recherches sur de gros volumes ou des recherches nécessitant la latence la plus faible.</span><span class="sxs-lookup"><span data-stu-id="10689-277">A ***Point Query*** is the most efficient lookup to use and is recommended to be used for high-volume lookups or lookups requiring lowest latency.</span></span> <span data-ttu-id="10689-278">Une telle requête peut utiliser les index pour localiser une entité individuelle très efficacement en spécifiant les valeurs de **PartitionKey** et de **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="10689-278">Such a query can use the indexes to locate an individual entity very efficiently by specifying both the **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="10689-279">Par exemple : $filter=(PartitionKey eq ’Sales’) and (RowKey eq ’2’)</span><span class="sxs-lookup"><span data-stu-id="10689-279">For example: $filter=(PartitionKey eq 'Sales') and (RowKey eq '2')</span></span>  
* <span data-ttu-id="10689-280">La deuxième méthode conseillée consiste à utiliser une ***requête de plage*** de données qui utilise la valeur de **PartitionKey** et des filtres sur une plage de valeurs de **RowKey** pour retourner plusieurs entités.</span><span class="sxs-lookup"><span data-stu-id="10689-280">Second best is a ***Range Query*** that uses the **PartitionKey** and filters on a range of **RowKey** values to return more than one entity.</span></span> <span data-ttu-id="10689-281">La valeur de **PartitionKey** identifie une partition spécifique, tandis que la valeur de **RowKey** identifie un sous-ensemble des entités de cette partition.</span><span class="sxs-lookup"><span data-stu-id="10689-281">The **PartitionKey** value identifies a specific partition, and the **RowKey** values identify a subset of the entities in that partition.</span></span> <span data-ttu-id="10689-282">Par exemple : $filter=PartitionKey eq ’Sales’ and RowKey ge ’S’ and RowKey lt ’T’</span><span class="sxs-lookup"><span data-stu-id="10689-282">For example: $filter=PartitionKey eq 'Sales' and RowKey ge 'S' and RowKey lt 'T'</span></span>  
* <span data-ttu-id="10689-283">La troisième méthode conseillée consiste à effectuer une ***analyse de partition*** qui utilise la valeur de **PartitionKey** et des filtres sur une autre propriété sans clé afin de renvoyer plusieurs entités.</span><span class="sxs-lookup"><span data-stu-id="10689-283">Third best is a ***Partition Scan*** that uses the **PartitionKey** and filters on another non-key property and that may return more than one entity.</span></span> <span data-ttu-id="10689-284">La valeur de **PartitionKey** identifie une partition spécifique et les valeurs des propriétés sélectionnent un sous-ensemble d’entités dans cette partition.</span><span class="sxs-lookup"><span data-stu-id="10689-284">The **PartitionKey** value identifies a specific partition, and the property values select for a subset of the entities in that partition.</span></span> <span data-ttu-id="10689-285">Par exemple : $filter=PartitionKey eq ’Sales’ and LastName eq ’Smith’</span><span class="sxs-lookup"><span data-stu-id="10689-285">For example: $filter=PartitionKey eq 'Sales' and LastName eq 'Smith'</span></span>  
* <span data-ttu-id="10689-286">Une ***analyse de table*** n’inclut pas la valeur de **PartitionKey** et s’avère particulièrement inefficace, car elle lance une recherche sur toutes les partitions qui composent la table pour toutes les entités correspondantes.</span><span class="sxs-lookup"><span data-stu-id="10689-286">A ***Table Scan*** does not include the **PartitionKey** and is very inefficient because it searches all of the partitions that make up your table in turn for any matching entities.</span></span> <span data-ttu-id="10689-287">Elle effectue une analyse de table, que votre filtre utilise la valeur de **RowKey**ou non.</span><span class="sxs-lookup"><span data-stu-id="10689-287">It will perform a table scan regardless of whether or not your filter uses the **RowKey**.</span></span> <span data-ttu-id="10689-288">Par exemple : $filter=LastName eq ’Jones’</span><span class="sxs-lookup"><span data-stu-id="10689-288">For example: $filter=LastName eq 'Jones'</span></span>  
* <span data-ttu-id="10689-289">Les requêtes qui retournent plusieurs entités les retournent triées dans l’ordre de la **PartitionKey** et de la **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="10689-289">Queries that return multiple entities return them sorted in **PartitionKey** and **RowKey** order.</span></span> <span data-ttu-id="10689-290">Pour éviter un nouveau tri des entités dans le client, sélectionnez une valeur de **RowKey** qui définit l’ordre de tri le plus répandu.</span><span class="sxs-lookup"><span data-stu-id="10689-290">To avoid resorting the entities in the client, choose a **RowKey** that defines the most common sort order.</span></span>  

<span data-ttu-id="10689-291">Notez que l’utilisation d’un connecteur « **or** » pour spécifier un filtre selon les valeurs de **RowKey** déclenche une analyse de partition et n’est pas traitée en tant que requête de plage de données.</span><span class="sxs-lookup"><span data-stu-id="10689-291">Note that using an "**or**" to specify a filter based on **RowKey** values results in a partition scan and is not treated as a range query.</span></span> <span data-ttu-id="10689-292">Par conséquent, vous devez éviter les requêtes qui utilisent des filtres comme : $filter=PartitionKey eq ’Sales’ and (RowKey eq ’121’ or RowKey eq ’322’)</span><span class="sxs-lookup"><span data-stu-id="10689-292">Therefore, you should avoid queries that use filters such as: $filter=PartitionKey eq 'Sales' and (RowKey eq '121' or RowKey eq '322')</span></span>  

<span data-ttu-id="10689-293">Pour obtenir des exemples de code côté client qui utilisent la bibliothèque cliente de stockage pour exécuter des requêtes efficaces, consultez les pages suivantes :</span><span class="sxs-lookup"><span data-stu-id="10689-293">For examples of client-side code that use the Storage Client Library to execute efficient queries, see:</span></span>  

* [<span data-ttu-id="10689-294">Exécution d'une requête de pointage à l'aide de la bibliothèque cliente de stockage</span><span class="sxs-lookup"><span data-stu-id="10689-294">Executing a point query using the Storage Client Library</span></span>](#executing-a-point-query-using-the-storage-client-library)
* [<span data-ttu-id="10689-295">Récupération de plusieurs entités à l’aide de LINQ</span><span class="sxs-lookup"><span data-stu-id="10689-295">Retrieving multiple entities using LINQ</span></span>](#retrieving-multiple-entities-using-linq)
* [<span data-ttu-id="10689-296">Projection côté serveur</span><span class="sxs-lookup"><span data-stu-id="10689-296">Server-side projection</span></span>](#server-side-projection)  

<span data-ttu-id="10689-297">Pour obtenir des exemples de code côté client pouvant gérer plusieurs types d'entité stockés dans la même table, consultez la page :</span><span class="sxs-lookup"><span data-stu-id="10689-297">For examples of client-side code that can handle multiple entity types stored in the same table, see:</span></span>  

* [<span data-ttu-id="10689-298">Utilisation des types d’entités hétérogènes</span><span class="sxs-lookup"><span data-stu-id="10689-298">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)  

### <a name="choosing-an-appropriate-partitionkey"></a><span data-ttu-id="10689-299">Choix d’une PartitionKey appropriée</span><span class="sxs-lookup"><span data-stu-id="10689-299">Choosing an appropriate PartitionKey</span></span>
<span data-ttu-id="10689-300">Votre choix de **PartitionKey** doit équilibrer la nécessité d’utiliser des EGT (pour assurer la cohérence) et la nécessité de répartir les entités sur plusieurs partitions (pour garantir une solution évolutive).</span><span class="sxs-lookup"><span data-stu-id="10689-300">Your choice of **PartitionKey** should balance the need to enables the use of EGTs (to ensure consistency) against the requirement to distribute your entities across multiple partitions (to ensure a scalable solution).</span></span>  

<span data-ttu-id="10689-301">D'un côté, vous pouvez stocker toutes vos entités dans une seule partition, mais cela peut limiter l'extensibilité de votre solution et empêcher le service de Table d'équilibrer les demandes.</span><span class="sxs-lookup"><span data-stu-id="10689-301">At one extreme, you could store all your entities in a single partition, but this may limit the scalability of your solution and would prevent the table service from being able to load-balance requests.</span></span> <span data-ttu-id="10689-302">D’un autre côté, vous pouvez stocker une seule entité par partition, ce qui améliorerait sensiblement l’extensibilité et permet au service de Table d’équilibrer la charge des demandes, mais vous empêcherait d’utiliser des transactions de groupe d’entités.</span><span class="sxs-lookup"><span data-stu-id="10689-302">At the other extreme, you could store one entity per partition, which would be highly scalable and which enables the table service to load-balance requests, but which would prevent you from using entity group transactions.</span></span>  

<span data-ttu-id="10689-303">Une **PartitionKey** idéale vous permet d’utiliser des requêtes efficaces et possède assez de partitions pour garantir l’extensibilité de votre solution.</span><span class="sxs-lookup"><span data-stu-id="10689-303">An ideal **PartitionKey** is one that enables you to use efficient queries and that has sufficient partitions to ensure your solution is scalable.</span></span> <span data-ttu-id="10689-304">En règle générale, vous trouverez que vos entités auront une propriété appropriée qui les distribue sur des partitions suffisantes.</span><span class="sxs-lookup"><span data-stu-id="10689-304">Typically, you will find that your entities will have a suitable property that distributes your entities across sufficient partitions.</span></span>

> [!NOTE]
> <span data-ttu-id="10689-305">Par exemple, dans un système qui stocke des informations sur des utilisateurs ou des employés, l’ID utilisateur peut être une bonne PartitionKey.</span><span class="sxs-lookup"><span data-stu-id="10689-305">For example, in a system that stores information about users or employees, UserID may be a good PartitionKey.</span></span> <span data-ttu-id="10689-306">Vous pouvez avoir plusieurs entités qui utilisent un ID utilisateur donné comme clé de partition.</span><span class="sxs-lookup"><span data-stu-id="10689-306">You may have several entities that use a given UserID as the partition key.</span></span> <span data-ttu-id="10689-307">Les différentes entités qui stockent des données relatives à un utilisateur sont regroupées en une seule partition et sont ainsi accessibles via des transactions de groupe d’entités, tout en étant hautement évolutives.</span><span class="sxs-lookup"><span data-stu-id="10689-307">Each entity that stores data about a user is grouped into a single partition, and so these entities are accessible via entity group transactions, while still being highly scalable.</span></span>
> 
> 

<span data-ttu-id="10689-308">Il existe des considérations supplémentaires sur le choix de **PartitionKey** qui sont liées à la façon dont vous allez insérer, mettre à jour et supprimer des entités : pour en savoir plus, consultez la section [Conception pour la modification de données](#design-for-data-modification) ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="10689-308">There are additional considerations in your choice of **PartitionKey** that relate to how you will insert, update, and delete entities: see the section [Design for data modification](#design-for-data-modification) below.</span></span>  

### <a name="optimizing-queries-for-the-table-service"></a><span data-ttu-id="10689-309">Optimisation des requêtes pour le service de Table</span><span class="sxs-lookup"><span data-stu-id="10689-309">Optimizing queries for the Table service</span></span>
<span data-ttu-id="10689-310">Le service de Table indexe automatiquement vos entités en utilisant les valeurs de **PartitionKey** et **RowKey** dans un seul index en cluster. Voilà pourquoi les requêtes de pointage sont les plus efficaces.</span><span class="sxs-lookup"><span data-stu-id="10689-310">The Table service automatically indexes your entities using the **PartitionKey** and **RowKey** values in a single clustered index, hence the reason that point queries are the most efficient to use.</span></span> <span data-ttu-id="10689-311">Toutefois, il n’existe aucun autre index que celui de l’index en cluster sur la **PartitionKey** et la **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="10689-311">However, there are no indexes other than that on the clustered index on the **PartitionKey** and **RowKey**.</span></span>

<span data-ttu-id="10689-312">De nombreuses conceptions doivent répondre aux conditions requises pour permettre la recherche d'entités basée sur plusieurs critères.</span><span class="sxs-lookup"><span data-stu-id="10689-312">Many designs must meet requirements to enable lookup of entities based on multiple criteria.</span></span> <span data-ttu-id="10689-313">Par exemple, la localisation des entités relatives aux employés (employee) en fonction de leurs adresses de messagerie électronique, de leur ID employé ou de leur nom.</span><span class="sxs-lookup"><span data-stu-id="10689-313">For example, locating employee entities based on email, employee id, or last name.</span></span> <span data-ttu-id="10689-314">Les modèles suivants de la section [Modèles de conception de table](#table-design-patterns) répondent à ces types de besoin et décrivent les différentes manières de contourner le fait que le service de Table ne fournit pas d’index secondaire :</span><span class="sxs-lookup"><span data-stu-id="10689-314">The following patterns in the section [Table Design Patterns](#table-design-patterns) address these types of requirement and describe ways of working around the fact that the Table service does not provide secondary indexes:</span></span>  

* <span data-ttu-id="10689-315">[Modèle d’index secondaire intra-partition](#intra-partition-secondary-index-pattern) : stockez plusieurs copies de chaque entité en utilisant différentes valeurs de **RowKey** (dans la même partition) pour pouvoir mener des recherches rapides et efficaces et alterner des commandes de tri à l’aide de différentes valeurs de **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="10689-315">[Intra-partition secondary index pattern](#intra-partition-secondary-index-pattern) - Store multiple copies of each entity using different **RowKey** values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  
* <span data-ttu-id="10689-316">[Modèle d’index secondaire entre les partitions](#inter-partition-secondary-index-pattern) : stockez plusieurs copies de chaque entité à l’aide de différentes valeurs de RowKey dans des partitions ou des tables distinctes pour mener des recherches rapides et efficaces et alterner des commandes de tri à l’aide de différentes valeurs de **RowKey** .</span><span class="sxs-lookup"><span data-stu-id="10689-316">[Inter-partition secondary index pattern](#inter-partition-secondary-index-pattern) - Store multiple copies of each entity using different RowKey values in separate partitions or in separate tables to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  
* <span data-ttu-id="10689-317">[Modèle d’entités d’index](#index-entities-pattern) : mettez à jour des entités d’index pour mener des recherches efficaces renvoyant des listes d’entités.</span><span class="sxs-lookup"><span data-stu-id="10689-317">[Index Entities Pattern](#index-entities-pattern) - Maintain index entities to enable efficient searches that return lists of entities.</span></span>  

### <a name="sorting-data-in-the-table-service"></a><span data-ttu-id="10689-318">Tri des données dans le service de Table</span><span class="sxs-lookup"><span data-stu-id="10689-318">Sorting data in the Table service</span></span>
<span data-ttu-id="10689-319">Le service de Table renvoie des entités triées dans l’ordre croissant selon la **PartitionKey**, puis la **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="10689-319">The Table service returns entities sorted in ascending order based on **PartitionKey** and then by **RowKey**.</span></span> <span data-ttu-id="10689-320">Ces clés correspondent à des valeurs de chaîne. Pour vous assurer que les valeurs numériques permettent des tris corrects, vous devez les convertir en une longueur fixe et les remplir avec des zéros.</span><span class="sxs-lookup"><span data-stu-id="10689-320">These keys are string values and to ensure that numeric values sort correctly, you should convert them to a fixed length and pad them with zeroes.</span></span> <span data-ttu-id="10689-321">Par exemple, si la valeur d’ID d’un employé que vous utilisez comme **RowKey** est une valeur de nombre entier, vous devez convertir l’ID de cet employé, **123**, en **00000123**.</span><span class="sxs-lookup"><span data-stu-id="10689-321">For example, if the employee id value you use as the **RowKey** is an integer value, you should convert employee id **123** to **00000123**.</span></span>  

<span data-ttu-id="10689-322">De nombreuses applications ont des conditions d'utilisation pour l'utilisation des données triées dans différents ordres : par exemple, le tri des employés par nom ou par date d'arrivée.</span><span class="sxs-lookup"><span data-stu-id="10689-322">Many applications have requirements to use data sorted in different orders: for example, sorting employees by name, or by joining date.</span></span> <span data-ttu-id="10689-323">Les modèles suivants de la section [Modèles de conception de table](#table-design-patterns) permettent de comprendre comment alterner des commandes de tri pour vos entités :</span><span class="sxs-lookup"><span data-stu-id="10689-323">The following patterns in the section [Table Design Patterns](#table-design-patterns) address how to alternate sort orders for your entities:</span></span>  

* <span data-ttu-id="10689-324">[Modèle d’index secondaire intra-partition](#intra-partition-secondary-index-pattern) : stockez plusieurs copies de chaque entité en utilisant différentes valeurs de RowKey (dans la même partition) pour pouvoir mener des recherches rapides et efficaces et alterner des commandes de tri à l’aide de différentes valeurs de RowKey.</span><span class="sxs-lookup"><span data-stu-id="10689-324">[Intra-partition secondary index pattern](#intra-partition-secondary-index-pattern) - Store multiple copies of each entity using different RowKey values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different RowKey values.</span></span>  
* <span data-ttu-id="10689-325">[Modèle d’index secondaire entre les partitions](#inter-partition-secondary-index-pattern) : stockez plusieurs copies de chaque entité à l’aide de différentes valeurs de RowKey dans des partitions ou des tables distinctes pour mener des recherches rapides et efficaces et alterner des commandes de tri à l’aide de différentes valeurs de RowKey.</span><span class="sxs-lookup"><span data-stu-id="10689-325">[Inter-partition secondary index pattern](#inter-partition-secondary-index-pattern) - Store multiple copies of each entity using different RowKey values in separate partitions in separate tables to enable fast and efficient lookups and alternate sort orders by using different RowKey values.</span></span>
* <span data-ttu-id="10689-326">[Modèle de fin de journal](#log-tail-pattern) : récupérez les entités *n* récemment ajoutées à une partition en utilisant une valeur de **RowKey** qui effectue un tri dans l’ordre inverse de la date et de l’heure.</span><span class="sxs-lookup"><span data-stu-id="10689-326">[Log tail pattern](#log-tail-pattern) - Retrieve the *n* entities most recently added to a partition by using a **RowKey** value that sorts in reverse date and time order.</span></span>  

## <a name="design-for-data-modification"></a><span data-ttu-id="10689-327">Conception pour la modification de données</span><span class="sxs-lookup"><span data-stu-id="10689-327">Design for data modification</span></span>
<span data-ttu-id="10689-328">Cette section se concentre sur les considérations de conception pour optimiser les insertions, les mises à jour et les suppressions.</span><span class="sxs-lookup"><span data-stu-id="10689-328">This section focuses on the design considerations for optimizing inserts, updates, and deletes.</span></span> <span data-ttu-id="10689-329">Dans certains cas, vous devez évaluer le compromis entre les conceptions optimisées pour l'interrogation et celles optimisées pour la modification des données, comme vous le feriez dans les conceptions de bases de données relationnelles (bien que les techniques permettant de gérer les compromis de conception sont différentes dans une base de données relationnelle).</span><span class="sxs-lookup"><span data-stu-id="10689-329">In some cases, you will need to evaluate the trade-off between designs that optimize for querying against designs that optimize for data modification just as you do in designs for relational databases (although the techniques for managing the design trade-offs are different in a relational database).</span></span> <span data-ttu-id="10689-330">La section [Modèles de conception de table](#table-design-patterns) décrit plusieurs modèles de conception détaillés pour le service de Table et apporte des informations sur certains de ces compromis.</span><span class="sxs-lookup"><span data-stu-id="10689-330">The section [Table Design Patterns](#table-design-patterns) describes some detailed design patterns for the Table service and highlights some these trade-offs.</span></span> <span data-ttu-id="10689-331">En pratique, vous constaterez que les nombreuses conceptions optimisées pour l'interrogation des entités fonctionnent aussi bien pour la modification des entités.</span><span class="sxs-lookup"><span data-stu-id="10689-331">In practice, you will find that many designs optimized for querying entities also work well for modifying entities.</span></span>  

### <a name="optimizing-the-performance-of-insert-update-and-delete-operations"></a><span data-ttu-id="10689-332">Optimisation des performances des opérations d'insertion, de mise à jour et de suppression</span><span class="sxs-lookup"><span data-stu-id="10689-332">Optimizing the performance of insert, update, and delete operations</span></span>
<span data-ttu-id="10689-333">Pour mettre à jour ou supprimer une entité, vous devez être en mesure de l’identifier à l’aide des valeurs de **PartitionKey** et de **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="10689-333">To update or delete an entity, you must be able to identify it by using the **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="10689-334">À cet égard, le choix de la **PartitionKey** et de la **RowKey** pour la modification des entités doit respecter les mêmes critères que ceux déterminant votre choix de prise en charge des requêtes de pointage, afin d’identifier les entités aussi efficacement que possible.</span><span class="sxs-lookup"><span data-stu-id="10689-334">In this respect, your choice of **PartitionKey** and **RowKey** for modifying entities should follow similar criteria to your choice to support point queries because you want to identify entities as efficiently as possible.</span></span> <span data-ttu-id="10689-335">Il ne vaut mieux pas utiliser d’analyse de table ou de partition inefficace pour localiser une entité afin de découvrir les valeurs de **PartitionKey** et de **RowKey** que vous devez mettre à jour ou supprimer.</span><span class="sxs-lookup"><span data-stu-id="10689-335">You do not want to use an inefficient partition or table scan to locate an entity in order to discover the **PartitionKey** and **RowKey** values you need to update or delete it.</span></span>  

<span data-ttu-id="10689-336">Les modèles suivants de la section [Modèles de conception de table](#table-design-patterns) permettent d’optimiser les performances ou vos opérations d’insertion, de mise à jour et de suppression :</span><span class="sxs-lookup"><span data-stu-id="10689-336">The following patterns in the section [Table Design Patterns](#table-design-patterns) address optimizing the performance or your insert, update, and delete operations:</span></span>  

* <span data-ttu-id="10689-337">[Modèle de suppression de volume élevé](#high-volume-delete-pattern) : permet de supprimer un volume élevé d’entités en stockant toutes les entités en vue d’une suppression simultanée à partir de leurs propres tables distinctes. Vous supprimez les entités en supprimant la table.</span><span class="sxs-lookup"><span data-stu-id="10689-337">[High volume delete pattern](#high-volume-delete-pattern) - Enable the deletion of a high volume of entities by storing all the entities for simultaneous deletion in their own separate table; you delete the entities by deleting the table.</span></span>  
* <span data-ttu-id="10689-338">[Modèle de série de données](#data-series-pattern) : stocke des séries de données complètes dans une seule entité pour réduire le nombre de vos demandes.</span><span class="sxs-lookup"><span data-stu-id="10689-338">[Data series pattern](#data-series-pattern) - Store complete data series in a single entity to minimize the number of requests you make.</span></span>  
* <span data-ttu-id="10689-339">[Modèle d’entités larges](#wide-entities-pattern) : utilisez plusieurs entités physiques pour stocker des entités logiques avec plus de 252 propriétés.</span><span class="sxs-lookup"><span data-stu-id="10689-339">[Wide entities pattern](#wide-entities-pattern) - Use multiple physical entities to store logical entities with more than 252 properties.</span></span>  
* <span data-ttu-id="10689-340">[Modèle d’entités volumineuses](#large-entities-pattern) : utilisez le stockage d’objets blob pour stocker des valeurs de propriétés volumineuses.</span><span class="sxs-lookup"><span data-stu-id="10689-340">[Large entities pattern](#large-entities-pattern) - Use blob storage to store large property values.</span></span>  

### <a name="ensuring-consistency-in-your-stored-entities"></a><span data-ttu-id="10689-341">Vérification de la cohérence de vos entités stockées</span><span class="sxs-lookup"><span data-stu-id="10689-341">Ensuring consistency in your stored entities</span></span>
<span data-ttu-id="10689-342">L'autre facteur déterminant pour votre choix de clés en vue de l'optimisation des modifications de données consiste à assurer la cohérence à l'aide de transactions atomiques.</span><span class="sxs-lookup"><span data-stu-id="10689-342">The other key factor that influences your choice of keys for optimizing data modifications is how to ensure consistency by using atomic transactions.</span></span> <span data-ttu-id="10689-343">Vous pouvez uniquement utiliser une EGT pour mener des opérations sur des entités stockées dans la même partition.</span><span class="sxs-lookup"><span data-stu-id="10689-343">You can only use an EGT to operate on entities stored in the same partition.</span></span>  

<span data-ttu-id="10689-344">Les modèles suivants de la section [Modèles de conception de table](#table-design-patterns) permettent de gérer la cohérence :</span><span class="sxs-lookup"><span data-stu-id="10689-344">The following patterns in the section [Table Design Patterns](#table-design-patterns) address managing consistency:</span></span>  

* <span data-ttu-id="10689-345">[Modèle d’index secondaire intra-partition](#intra-partition-secondary-index-pattern) : stockez plusieurs copies de chaque entité en utilisant différentes valeurs de **RowKey** (dans la même partition) pour pouvoir mener des recherches rapides et efficaces et alterner des commandes de tri à l’aide de différentes valeurs de **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="10689-345">[Intra-partition secondary index pattern](#intra-partition-secondary-index-pattern) - Store multiple copies of each entity using different **RowKey** values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  
* <span data-ttu-id="10689-346">[Modèle d’index secondaire entre les partitions](#inter-partition-secondary-index-pattern) : stockez plusieurs copies de chaque entité à l’aide de différentes valeurs de RowKey dans des partitions ou des tables distinctes pour mener des recherches rapides et efficaces et alterner des commandes de tri à l’aide de différentes valeurs de **RowKey** .</span><span class="sxs-lookup"><span data-stu-id="10689-346">[Inter-partition secondary index pattern](#inter-partition-secondary-index-pattern) - Store multiple copies of each entity using different RowKey values in separate partitions or in separate tables to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  
* <span data-ttu-id="10689-347">[Modèle de transactions cohérentes](#eventually-consistent-transactions-pattern) : permet de conserver un comportement cohérent entre les limites de partition ou les limites du système de stockage à l’aide des files d’attente Azure.</span><span class="sxs-lookup"><span data-stu-id="10689-347">[Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) - Enable eventually consistent behavior across partition boundaries or storage system boundaries by using Azure queues.</span></span>
* <span data-ttu-id="10689-348">[Modèle d’entités d’index](#index-entities-pattern) : mettez à jour des entités d’index pour mener des recherches efficaces renvoyant des listes d’entités.</span><span class="sxs-lookup"><span data-stu-id="10689-348">[Index Entities Pattern](#index-entities-pattern) - Maintain index entities to enable efficient searches that return lists of entities.</span></span>  
* <span data-ttu-id="10689-349">[Modèle de dénormalisation](#denormalization-pattern) : combinez des données liées dans une seule entité pour pouvoir récupérer toutes les données dont vous avez besoin en utilisant une seule requête de pointage.</span><span class="sxs-lookup"><span data-stu-id="10689-349">[Denormalization pattern](#denormalization-pattern) - Combine related data together in a single entity to enable you to retrieve all the data you need with a single point query.</span></span>  
* <span data-ttu-id="10689-350">[Modèle de série de données](#data-series-pattern) : stocke des séries de données complètes dans une seule entité pour réduire le nombre de vos demandes.</span><span class="sxs-lookup"><span data-stu-id="10689-350">[Data series pattern](#data-series-pattern) - Store complete data series in a single entity to minimize the number of requests you make.</span></span>  

<span data-ttu-id="10689-351">Pour plus d’informations sur les transactions de groupe d’entités, consultez la section [Transactions de groupe d’entités](#entity-group-transactions).</span><span class="sxs-lookup"><span data-stu-id="10689-351">For information about entity group transactions, see the section [Entity Group Transactions](#entity-group-transactions).</span></span>  

### <a name="ensuring-your-design-for-efficient-modifications-facilitates-efficient-queries"></a><span data-ttu-id="10689-352">Garantie que votre conception visant à effectuer des modifications efficaces facilite les requêtes efficaces</span><span class="sxs-lookup"><span data-stu-id="10689-352">Ensuring your design for efficient modifications facilitates efficient queries</span></span>
<span data-ttu-id="10689-353">Dans de nombreux cas, une conception visant à obtenir une interrogation efficace entraîne des modifications efficaces, mais vous devez toujours évaluer si cela est le cas pour votre scénario.</span><span class="sxs-lookup"><span data-stu-id="10689-353">In many cases, a design for efficient querying results in efficient modifications, but you should always evaluate whether this is the case for your specific scenario.</span></span> <span data-ttu-id="10689-354">Certains des modèles de la section [Modèles de conception de table](#table-design-patterns) évaluent clairement les compromis entre l’interrogation et la modification des entités. Vous devez toujours prendre en compte le nombre de chaque type d’opération.</span><span class="sxs-lookup"><span data-stu-id="10689-354">Some of the patterns in the section [Table Design Patterns](#table-design-patterns) explicitly evaluate trade-offs between querying and modifying entities, and you should always take into account the number of each type of operation.</span></span>  

<span data-ttu-id="10689-355">Les modèles suivants de la section [Modèles de conception de table](#table-design-patterns) répondent aux compromis entre la conception en vue d’une interrogation efficace et la conception en vue d’une modification de données efficace :</span><span class="sxs-lookup"><span data-stu-id="10689-355">The following patterns in the section [Table Design Patterns](#table-design-patterns) address trade-offs between designing for efficient queries and designing for efficient data modification:</span></span>  

* <span data-ttu-id="10689-356">[Modèle de clé composée](#compound-key-pattern) : utilisez les valeurs de **RowKey** composée pour permettre à un client de rechercher des données associées en utilisant une seule requête de pointage.</span><span class="sxs-lookup"><span data-stu-id="10689-356">[Compound key pattern](#compound-key-pattern) - Use compound **RowKey** values to enable a client to lookup related data with a single point query.</span></span>  
* <span data-ttu-id="10689-357">[Modèle de fin de journal](#log-tail-pattern) : récupérez les *n* entités récemment ajoutées à une partition en utilisant une valeur de **RowKey** qui effectue un tri dans l’ordre inverse de la date et de l’heure.</span><span class="sxs-lookup"><span data-stu-id="10689-357">[Log tail pattern](#log-tail-pattern) - Retrieve the *n* entities most recently added to a partition by using a **RowKey** value that sorts in reverse date and time order.</span></span>  

## <a name="encrypting-table-data"></a><span data-ttu-id="10689-358">Chiffrement de données de table</span><span class="sxs-lookup"><span data-stu-id="10689-358">Encrypting Table Data</span></span>
<span data-ttu-id="10689-359">La bibliothèque cliente de stockage .NET Azure Storage prend en charge le chiffrement des propriétés de l’entité de chaîne pour les opérations d’insertion et de remplacement.</span><span class="sxs-lookup"><span data-stu-id="10689-359">The .NET Azure Storage Client Library supports encryption of string entity properties for insert and replace operations.</span></span> <span data-ttu-id="10689-360">Les chaînes chiffrées sont stockées sur le service en tant que propriétés binaires, et elles sont converties en chaînes après le déchiffrement.</span><span class="sxs-lookup"><span data-stu-id="10689-360">The encrypted strings are stored on the service as binary properties, and they are converted back to strings after decryption.</span></span>    

<span data-ttu-id="10689-361">Pour les tables, outre la stratégie de chiffrement, les utilisateurs doivent spécifier les propriétés à chiffrer.</span><span class="sxs-lookup"><span data-stu-id="10689-361">For tables, in addition to the encryption policy, users must specify the properties to be encrypted.</span></span> <span data-ttu-id="10689-362">Pour ce faire, il faut spécifier un attribut EncryptProperty \(pour les entités POCO qui dérivent de TableEntity) ou un programme de résolution de chiffrement dans les options de requête.</span><span class="sxs-lookup"><span data-stu-id="10689-362">This can be done by either specifying an [EncryptProperty] attribute (for POCO entities that derive from TableEntity) or an encryption resolver in request options.</span></span> <span data-ttu-id="10689-363">Un programme de résolution de chiffrement est un délégué qui prend une clé de partition, une clé de ligne et un nom de propriété, puis renvoie une valeur booléenne indiquant si cette propriété doit être chiffrée.</span><span class="sxs-lookup"><span data-stu-id="10689-363">An encryption resolver is a delegate that takes a partition key, row key, and property name and returns a Boolean that indicates whether that property should be encrypted.</span></span> <span data-ttu-id="10689-364">Au cours du chiffrement, la bibliothèque cliente utilise ces informations pour décider si une propriété doit être chiffrée lors de l’écriture en ligne.</span><span class="sxs-lookup"><span data-stu-id="10689-364">During encryption, the client library will use this information to decide whether a property should be encrypted while writing to the wire.</span></span> <span data-ttu-id="10689-365">Le délégué fournit également la possibilité de définir la manière dont les propriétés sont chiffrées l’aide d’un programme logique.</span><span class="sxs-lookup"><span data-stu-id="10689-365">The delegate also provides for the possibility of logic around how properties are encrypted.</span></span> <span data-ttu-id="10689-366">(Par exemple, si X, alors chiffrer la propriété A ; sinon chiffrer les propriétés A et B.) Notez qu’il n’est pas nécessaire de fournir ces informations lors de la lecture ou de l’interrogation des entités.</span><span class="sxs-lookup"><span data-stu-id="10689-366">(For example, if X, then encrypt property A; otherwise encrypt properties A and B.) Note that it is not necessary to provide this information while reading or querying entities.</span></span>

<span data-ttu-id="10689-367">Notez que la fusion n’est pas prise en charge pour le moment.</span><span class="sxs-lookup"><span data-stu-id="10689-367">Note that merge is not currently supported.</span></span> <span data-ttu-id="10689-368">Si un sous-ensemble de propriétés a été chiffré précédemment à l’aide d’une clé différente, la fusion des nouvelles propriétés et la mise à jour des métadonnées entraîne une perte de données.</span><span class="sxs-lookup"><span data-stu-id="10689-368">Since a subset of properties may have been encrypted previously using a different key, simply merging the new properties and updating the metadata will result in data loss.</span></span> <span data-ttu-id="10689-369">L’opération de fusion nécessite d’effectuer des appels de service supplémentaires pour lire l’entité pré-existante à partir du service ou d’utiliser une nouvelle clé par propriété. Ces deux solutions ne conviennent pas pour des raisons de performances.</span><span class="sxs-lookup"><span data-stu-id="10689-369">Merging either requires making extra service calls to read the pre-existing entity from the service, or using a new key per property, both of which are not suitable for performance reasons.</span></span>     

<span data-ttu-id="10689-370">Pour plus d’informations sur le chiffrement des données de table, consultez [Chiffrement côté client et coffre de clés Azure pour Microsoft Azure Storage](../storage/common/storage-client-side-encryption.md).</span><span class="sxs-lookup"><span data-stu-id="10689-370">For information about encrypting table data, see [Client-Side Encryption and Azure Key Vault for Microsoft Azure Storage](../storage/common/storage-client-side-encryption.md).</span></span>  

## <a name="modelling-relationships"></a><span data-ttu-id="10689-371">Modélisation des relations</span><span class="sxs-lookup"><span data-stu-id="10689-371">Modelling relationships</span></span>
<span data-ttu-id="10689-372">La création de modèles de domaine est une étape importante pour concevoir des systèmes complexes.</span><span class="sxs-lookup"><span data-stu-id="10689-372">Building domain models is a key step in the design of complex systems.</span></span> <span data-ttu-id="10689-373">En règle générale, le processus de modélisation permet d'identifier les entités et les relations entre eux, pour mieux comprendre le domaine de l'entreprise et concevoir votre système.</span><span class="sxs-lookup"><span data-stu-id="10689-373">Typically, you use the modelling process to identify entities and the relationships between them as a way to understand the business domain and inform the design of your system.</span></span> <span data-ttu-id="10689-374">Cette section se concentre sur la manière dont vous pouvez traduire certains des types de relations courantes découverts dans les modèles du domaine pour les conceptions du service de Table.</span><span class="sxs-lookup"><span data-stu-id="10689-374">This section focuses on how you can translate some of the common relationship types found in domain models to designs for the Table service.</span></span> <span data-ttu-id="10689-375">Le processus de mappage à partir d'un modèle de données logique vers un modèle de données NoSQL physique est très différent de celui utilisé lors de la conception d'une base de données relationnelle.</span><span class="sxs-lookup"><span data-stu-id="10689-375">The process of mapping from a logical data-model to a physical NoSQL based data-model is very different from that used when designing a relational database.</span></span> <span data-ttu-id="10689-376">La conception de bases de données relationnelles suppose généralement un processus de normalisation des données optimisé pour réduire la redondance, ainsi qu'une fonctionnalité de requête déclarative qui résume la façon dont fonctionne l'implémentation de la base de données.</span><span class="sxs-lookup"><span data-stu-id="10689-376">Relational databases design typically assumes a data normalization process optimized for minimizing redundancy – and a declarative querying capability that abstracts how the implementation of how the database works.</span></span>  

### <a name="one-to-many-relationships"></a><span data-ttu-id="10689-377">Relations un-à-plusieurs</span><span class="sxs-lookup"><span data-stu-id="10689-377">One-to-many relationships</span></span>
<span data-ttu-id="10689-378">Les relations un-à-plusieurs entre des objets de domaine d'entreprise se produisent très fréquemment : par exemple, un service a de nombreux employés.</span><span class="sxs-lookup"><span data-stu-id="10689-378">One-to-many relationships between business domain objects occur very frequently: for example, one department has many employees.</span></span> <span data-ttu-id="10689-379">Il existe plusieurs méthodes pour implémenter des relations un-à-plusieurs dans le service de Table. Chacune d'elles a des inconvénients et des avantages qui peuvent être pertinents pour un scénario particulier.</span><span class="sxs-lookup"><span data-stu-id="10689-379">There are several ways to implement one-to-many relationships in the Table service each with pros and cons that may be relevant to the particular scenario.</span></span>  

<span data-ttu-id="10689-380">Prenons l'exemple d'une grande entreprise multinationale ayant des dizaines de milliers d'entités relatives aux services (department) et aux employés (employee) où chaque service a de nombreux employés et chaque employé est associé à un service spécifique.</span><span class="sxs-lookup"><span data-stu-id="10689-380">Consider the example of a large multi-national corporation with tens of thousands of departments and employee entities where every department has many employees and each employee as associated with one specific department.</span></span> <span data-ttu-id="10689-381">Une approche consiste à stocker séparément les entités relatives aux services (department) et aux employés (employee), comme ceci :</span><span class="sxs-lookup"><span data-stu-id="10689-381">One approach is to store separate department and employee entities such as these:</span></span>  

![][1]

<span data-ttu-id="10689-382">Cet exemple montre une relation un-à-plusieurs implicite entre les types selon la valeur de **PartitionKey** .</span><span class="sxs-lookup"><span data-stu-id="10689-382">This example shows an implicit one-to-many relationship between the types based on the **PartitionKey** value.</span></span> <span data-ttu-id="10689-383">Chaque service peut avoir de nombreux employés.</span><span class="sxs-lookup"><span data-stu-id="10689-383">Each department can have many employees.</span></span>  

<span data-ttu-id="10689-384">Cet exemple montre également une entité de service (department) et ses entités d'employés (employee) dans la même partition.</span><span class="sxs-lookup"><span data-stu-id="10689-384">This example also shows a department entity and its related employee entities in the same partition.</span></span> <span data-ttu-id="10689-385">Vous pouvez choisir d'utiliser des partitions, des tables ou même des comptes de stockage différents pour les différents types d'entité.</span><span class="sxs-lookup"><span data-stu-id="10689-385">You could choose to use different partitions, tables, or even storage accounts for the different entity types.</span></span>  

<span data-ttu-id="10689-386">Une autre approche consiste à dénormaliser vos données et à stocker uniquement les entités d'employés (employee) avec les données de services (department) dénormalisées, comme indiqué dans l'exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="10689-386">An alternative approach is to denormalize your data and store only employee entities with denormalized department data as shown in the following example.</span></span> <span data-ttu-id="10689-387">Cette approche dénormalisée n'est peut-être pas la meilleure pour ce scénario si vous avez besoin de modifier les détails d'un responsable de service, car pour ce faire, vous devez mettre à jour chaque employé du service.</span><span class="sxs-lookup"><span data-stu-id="10689-387">In this particular scenario, this denormalized approach may not be the best if you have a requirement to be able to change the details of a department manager because to do this you need to update every employee in the department.</span></span>  

![][2]

<span data-ttu-id="10689-388">Pour plus d’informations, consultez la section [Modèle de dénormalisation](#denormalization-pattern) plus loin dans ce guide.</span><span class="sxs-lookup"><span data-stu-id="10689-388">For more information, see the [Denormalization pattern](#denormalization-pattern) later in this guide.</span></span>  

<span data-ttu-id="10689-389">Le tableau suivant récapitule les avantages et les inconvénients de chacune des approches décrites ci-dessus pour le stockage des entités d'employés et de services qui partagent une relation un-à-plusieurs.</span><span class="sxs-lookup"><span data-stu-id="10689-389">The following table summarizes the pros and cons of each of the approaches outlined above for storing employee and department entities that have a one-to-many relationship.</span></span> <span data-ttu-id="10689-390">Vous devez également envisager la fréquence à laquelle vous pensez effectuer diverses opérations : il peut être raisonnable d'avoir une conception qui inclut une opération coûteuse si cette opération ne se produit que rarement.</span><span class="sxs-lookup"><span data-stu-id="10689-390">You should also consider how often you expect to perform various operations: it may be acceptable to have a design that includes an expensive operation if that operation only happens infrequently.</span></span>  

<table>
<tr>
<th><span data-ttu-id="10689-391">Approche</span><span class="sxs-lookup"><span data-stu-id="10689-391">Approach</span></span></th>
<th><span data-ttu-id="10689-392">Avantages</span><span class="sxs-lookup"><span data-stu-id="10689-392">Pros</span></span></th>
<th><span data-ttu-id="10689-393">Inconvénients</span><span class="sxs-lookup"><span data-stu-id="10689-393">Cons</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="10689-394">Séparation des types d'entités, même partition, même table</span><span class="sxs-lookup"><span data-stu-id="10689-394">Separate entity types, same partition, same table</span></span></td>
<td>
<ul>
<li><span data-ttu-id="10689-395">Vous pouvez mettre à jour une entité de service en une seule opération.</span><span class="sxs-lookup"><span data-stu-id="10689-395">You can update a department entity with a single operation.</span></span></li>
<li><span data-ttu-id="10689-396">Vous pouvez utiliser une EGT pour maintenir la cohérence si vous avez besoin de modifier une entité de service à chaque mise à jour/insertion/suppression d'une entité d'employé.</span><span class="sxs-lookup"><span data-stu-id="10689-396">You can use an EGT to maintain consistency if you have a requirement to modify a department entity whenever you update/insert/delete an employee entity.</span></span> <span data-ttu-id="10689-397">Par exemple, si vous conservez un nombre d'employés de service pour chaque service.</span><span class="sxs-lookup"><span data-stu-id="10689-397">For example if you maintain a departmental employee count for each department.</span></span></li>
</ul>
</td>
<td>
<ul>
<li><span data-ttu-id="10689-398">Vous devrez peut-être récupérer une entité d'employé et de service pour certaines activités du client.</span><span class="sxs-lookup"><span data-stu-id="10689-398">You may need to retrieve both an employee and a department entity for some client activities.</span></span></li>
<li><span data-ttu-id="10689-399">Les opérations de stockage se produisent dans la même partition.</span><span class="sxs-lookup"><span data-stu-id="10689-399">Storage operations happen in the same partition.</span></span> <span data-ttu-id="10689-400">Si les volumes de transactions sont élevés, cela peut entraîner une zone sensible.</span><span class="sxs-lookup"><span data-stu-id="10689-400">At high transaction volumes, this may result in a hotspot.</span></span></li>
<li><span data-ttu-id="10689-401">Vous ne pouvez pas déplacer un employé vers un nouveau service à l'aide d'une EGT.</span><span class="sxs-lookup"><span data-stu-id="10689-401">You cannot move an employee to a new department using an EGT.</span></span></li>
</ul>
</td>
</tr>
<tr>
<td><span data-ttu-id="10689-402">Types d'entités distincts, différentes partitions ou différentes tables ou différents comptes de stockage</span><span class="sxs-lookup"><span data-stu-id="10689-402">Separate entity types, different partitions or tables or storage accounts</span></span></td>
<td>
<ul>
<li><span data-ttu-id="10689-403">Vous pouvez mettre à jour une entité de service ou une entité d'employé avec une seule opération.</span><span class="sxs-lookup"><span data-stu-id="10689-403">You can update a department entity or employee entity with a single operation.</span></span></li>
<li><span data-ttu-id="10689-404">Si les volumes de transactions sont élevés, ceci peut permettre de répartir la charge sur plusieurs partitions.</span><span class="sxs-lookup"><span data-stu-id="10689-404">At high transaction volumes, this may help spread the load across more partitions.</span></span></li>
</ul>
</td>
<td>
<ul>
<li><span data-ttu-id="10689-405">Vous devrez peut-être récupérer une entité d'employé et de service pour certaines activités du client.</span><span class="sxs-lookup"><span data-stu-id="10689-405">You may need to retrieve both an employee and a department entity for some client activities.</span></span></li>
<li><span data-ttu-id="10689-406">Vous ne pouvez pas utiliser des EGT pour maintenir la cohérence lors d'une mise à jour/insertion/suppression d'employé et d'une mise à jour de service.</span><span class="sxs-lookup"><span data-stu-id="10689-406">You cannot use EGTs to maintain consistency when you update/insert/delete an employee and update a department.</span></span> <span data-ttu-id="10689-407">Par exemple, la mise à jour d'un nombre d'employés dans une entité de service.</span><span class="sxs-lookup"><span data-stu-id="10689-407">For example, updating an employee count in a department entity.</span></span></li>
<li><span data-ttu-id="10689-408">Vous ne pouvez pas déplacer un employé vers un nouveau service à l'aide d'une EGT.</span><span class="sxs-lookup"><span data-stu-id="10689-408">You cannot move an employee to a new department using an EGT.</span></span></li>
</ul>
</td>
</tr>
<tr>
<td><span data-ttu-id="10689-409">Dénormaliser en type d'entité unique</span><span class="sxs-lookup"><span data-stu-id="10689-409">Denormalize into single entity type</span></span></td>
<td>
<ul>
<li><span data-ttu-id="10689-410">Vous pouvez récupérer toutes les informations dont vous avez besoin en utilisant une seule demande.</span><span class="sxs-lookup"><span data-stu-id="10689-410">You can retrieve all the information you need with a single request.</span></span></li>
</ul>
</td>
<td>
<ul>
<li><span data-ttu-id="10689-411">Il peut être coûteux de maintenir la cohérence si vous devez mettre à jour les informations d'un service (cela vous oblige à mettre à jour tous les employés d'un service).</span><span class="sxs-lookup"><span data-stu-id="10689-411">It may be expensive to maintain consistency if you need to update department information (this would require you to update all the employees in a department).</span></span></li>
</ul>
</td>
</tr>
</table>

<span data-ttu-id="10689-412">Votre choix entre ces options, ainsi que la détermination des avantages et des inconvénients les plus significatifs, tout cela dépend de votre scénario d'application.</span><span class="sxs-lookup"><span data-stu-id="10689-412">How you choose between these options, and which of the pros and cons are most significant, depends on your specific application scenarios.</span></span> <span data-ttu-id="10689-413">Par exemple, quelle sera la fréquence de modification des entités de service ; toutes les requêtes de vos employés ont-elles besoin d'informations de services supplémentaires ; êtes-vous proche des limites d'évolutivité de vos partitions ou de votre compte de stockage ?</span><span class="sxs-lookup"><span data-stu-id="10689-413">For example, how often do you modify department entities; do all your employee queries need the additional departmental information; how close are you to the scalability limits on your partitions or your storage account?</span></span>  

### <a name="one-to-one-relationships"></a><span data-ttu-id="10689-414">Relations un à un</span><span class="sxs-lookup"><span data-stu-id="10689-414">One-to-one relationships</span></span>
<span data-ttu-id="10689-415">Les modèles de domaines peuvent inclure des relations un à un entre les entités.</span><span class="sxs-lookup"><span data-stu-id="10689-415">Domain models may include one-to-one relationships between entities.</span></span> <span data-ttu-id="10689-416">Si vous devez implémenter une relation un à un dans le service de Table, vous devez également choisir comment lier les deux entités associées lorsque vous avez besoin de récupérer les deux.</span><span class="sxs-lookup"><span data-stu-id="10689-416">If you need to implement a one-to-one relationship in the Table service, you must also choose how to link the two related entities when you need to retrieve them both.</span></span> <span data-ttu-id="10689-417">Ce lien peut être implicite s’il est basé sur une convention dans les valeurs de clé, ou explicite si l’on stocke un lien sous forme de valeurs de **PartitionKey** et de **RowKey** dans chaque entité et son entité associée.</span><span class="sxs-lookup"><span data-stu-id="10689-417">This link can be either implicit, based on a convention in the key values, or explicit by storing a link in the form of **PartitionKey** and **RowKey** values in each entity to its related entity.</span></span> <span data-ttu-id="10689-418">Pour savoir quand stocker les entités associées dans la même partition, consultez la section [Relations un à plusieurs](#one-to-many-relationships).</span><span class="sxs-lookup"><span data-stu-id="10689-418">For a discussion of whether you should store the related entities in the same partition, see the section [One-to-many relationships](#one-to-many-relationships).</span></span>  

<span data-ttu-id="10689-419">Notez que certaines considérations sur l'implémentation peuvent vous conduire à implémenter des relations un à un dans le service de Table :</span><span class="sxs-lookup"><span data-stu-id="10689-419">Note that there are also implementation considerations that might lead you to implement one-to-one relationships in the Table service:</span></span>  

* <span data-ttu-id="10689-420">Gestion des entités volumineuses (pour plus d’informations, consultez [Modèle d’entités volumineuses](#large-entities-pattern))</span><span class="sxs-lookup"><span data-stu-id="10689-420">Handling large entities (for more information, see [Large Entities Pattern](#large-entities-pattern)).</span></span>  
* <span data-ttu-id="10689-421">L’implémentation de contrôles d’accès (pour plus d’informations, consultez [Contrôle d’accès avec des signatures d’accès partagé](#controlling-access-with-shared-access-signatures))</span><span class="sxs-lookup"><span data-stu-id="10689-421">Implementing access controls (for more information, see [Controlling access with Shared Access Signatures](#controlling-access-with-shared-access-signatures)).</span></span>  

### <a name="join-in-the-client"></a><span data-ttu-id="10689-422">Joindre le client</span><span class="sxs-lookup"><span data-stu-id="10689-422">Join in the client</span></span>
<span data-ttu-id="10689-423">Bien qu'il existe des façons de modéliser des relations dans le service de Table, n'oubliez pas que les deux principaux motifs pour utiliser le service de Table sont l'évolutivité et les performances.</span><span class="sxs-lookup"><span data-stu-id="10689-423">Although there are ways to model relationships in the Table service, you should not forget that the two prime reasons for using the Table service are scalability and performance.</span></span> <span data-ttu-id="10689-424">Si vous devez modéliser plusieurs relations pouvant compromettre les performances et l'évolutivité de votre solution, demandez-vous s'il est nécessaire de générer toutes les relations de données dans votre conception de table.</span><span class="sxs-lookup"><span data-stu-id="10689-424">If you find you are modelling many relationships that compromise the performance and scalability of your solution, you should ask yourself if it is necessary to build all the data relationships into your table design.</span></span> <span data-ttu-id="10689-425">Vous pouvez peut-être simplifier la conception et améliorer l'évolutivité et les performances de votre solution si vous laissez votre application cliente effectuer les jointures nécessaires.</span><span class="sxs-lookup"><span data-stu-id="10689-425">You may be able to simplify the design and improve the scalability and performance of your solution if you let your client application perform any necessary joins.</span></span>  

<span data-ttu-id="10689-426">Par exemple, si vous avez des petites tables qui contiennent des données qui ne changent pas très souvent, vous pouvez récupérer ces données une fois et les mettre en cache sur le client.</span><span class="sxs-lookup"><span data-stu-id="10689-426">For example, if you have small tables that contain data that does not change very often, then you can retrieve this data once and cache it on the client.</span></span> <span data-ttu-id="10689-427">Cela peut éviter des allers-retours répétés pour récupérer les mêmes données.</span><span class="sxs-lookup"><span data-stu-id="10689-427">This can avoid repeated roundtrips to retrieve the same data.</span></span> <span data-ttu-id="10689-428">Dans les exemples que nous avons vus dans ce guide, l'ensemble des services d'une petite entreprise sera réduit et ne risque pas d'être modifié très souvent, ce qui en fait un bon candidat pour l'emploi de données que l'application cliente peut télécharger une fois et mettre en cache en tant que données de recherche.</span><span class="sxs-lookup"><span data-stu-id="10689-428">In the examples we have looked at in this guide, the set of departments in a small organization is likely to be small and change infrequently making it a good candidate for data that client application can download once and cache as look up data.</span></span>  

### <a name="inheritance-relationships"></a><span data-ttu-id="10689-429">Relations d'héritage</span><span class="sxs-lookup"><span data-stu-id="10689-429">Inheritance relationships</span></span>
<span data-ttu-id="10689-430">Si votre application cliente utilise un ensemble de classes qui font partie d'une relation d'héritage pour représenter des entités métier, vous pouvez facilement conserver ces entités dans le service de Table.</span><span class="sxs-lookup"><span data-stu-id="10689-430">If your client application uses a set of classes that form part of an inheritance relationship to represent business entities, you can easily persist those entities in the Table service.</span></span> <span data-ttu-id="10689-431">Par exemple, l’ensemble de classes suivant peut être défini dans votre application cliente, **Person** étant une classe abstraite.</span><span class="sxs-lookup"><span data-stu-id="10689-431">For example, you might have the following set of classes defined in your client application where **Person** is an abstract class.</span></span>

![][3]

<span data-ttu-id="10689-432">Vous pouvez conserver les instances de deux classes concrètes dans le service de Table à l'aide d'une seule table Person à l'aide d'entités qui ressemblent à ceci :</span><span class="sxs-lookup"><span data-stu-id="10689-432">You can persist instances of the two concrete classes in the Table service using a single Person table using entities in that look like this:</span></span>  

![][4]

<span data-ttu-id="10689-433">Pour plus d’informations sur l’utilisation de plusieurs types d’entités dans la même table dans le code client, consultez la section [Utilisation des types d’entités hétérogènes](#working-with-heterogeneous-entity-types) plus loin dans ce guide.</span><span class="sxs-lookup"><span data-stu-id="10689-433">For more information about working with multiple entity types in the same table in client code, see the section [Working with heterogeneous entity types](#working-with-heterogeneous-entity-types) later in this guide.</span></span> <span data-ttu-id="10689-434">Vous y trouverez des exemples montrant comment reconnaître le type d'entité dans le code client.</span><span class="sxs-lookup"><span data-stu-id="10689-434">This provides examples of how to recognize the entity type in client code.</span></span>  

## <a name="table-design-patterns"></a><span data-ttu-id="10689-435">Modèles de conception de table</span><span class="sxs-lookup"><span data-stu-id="10689-435">Table Design Patterns</span></span>
<span data-ttu-id="10689-436">Dans les sections précédentes, vous avez consulté des explications détaillées sur la façon d'optimiser votre conception de table pour la récupération des données d'entité à l'aide de requêtes et l'insertion, la mise à jour et la suppression des données d'entité.</span><span class="sxs-lookup"><span data-stu-id="10689-436">In previous sections, you have seen some detailed discussions about how to optimize your table design for both retrieving entity data using queries and for inserting, updating, and deleting entity data.</span></span> <span data-ttu-id="10689-437">Cette section décrit certains modèles appropriés pour une utilisation avec des solutions de service de Table.</span><span class="sxs-lookup"><span data-stu-id="10689-437">This section describes some patterns appropriate for use with Table service solutions.</span></span> <span data-ttu-id="10689-438">En outre, vous verrez comment traiter certains problèmes et compromis abordés précédemment dans ce guide.</span><span class="sxs-lookup"><span data-stu-id="10689-438">In addition, you will see how you can practically address some of the issues and trade-offs raised previously in this guide.</span></span> <span data-ttu-id="10689-439">Le diagramme suivant récapitule les relations entre les différents modèles :</span><span class="sxs-lookup"><span data-stu-id="10689-439">The following diagram summarizes the relationships between the different patterns:</span></span>  

![][5]

<span data-ttu-id="10689-440">Le plan des modèles ci-dessus met en évidence les relations entre les modèles (bleus) et les anti-modèles (orange) qui sont décrits dans ce guide.</span><span class="sxs-lookup"><span data-stu-id="10689-440">The pattern map above highlights some relationships between patterns (blue) and anti-patterns (orange) that are documented in this guide.</span></span> <span data-ttu-id="10689-441">Il existe bien sûr bien d'autres modèles qui méritent votre attention.</span><span class="sxs-lookup"><span data-stu-id="10689-441">There are of course many other patterns that are worth considering.</span></span> <span data-ttu-id="10689-442">Par exemple, l’un des principaux scénarios pour un service de Table consiste à utiliser des [modèles d’affichages matérialisés](https://msdn.microsoft.com/library/azure/dn589782.aspx) à partir du modèle [Répartition de la responsabilité de requête de commande](https://msdn.microsoft.com/library/azure/jj554200.aspx) (CQRS).</span><span class="sxs-lookup"><span data-stu-id="10689-442">For example, one of the key scenarios for Table Service is to use the [Materialized View Pattern](https://msdn.microsoft.com/library/azure/dn589782.aspx) from the [Command Query Responsibility Segregation (CQRS)](https://msdn.microsoft.com/library/azure/jj554200.aspx) pattern.</span></span>  

### <a name="intra-partition-secondary-index-pattern"></a><span data-ttu-id="10689-443">Modèle d’index secondaire intra-partition</span><span class="sxs-lookup"><span data-stu-id="10689-443">Intra-partition secondary index pattern</span></span>
<span data-ttu-id="10689-444">Stockez plusieurs copies de chaque entité en utilisant différentes valeurs de **RowKey** (dans la même partition) pour pouvoir mener des recherches rapides et efficaces et alterner des commandes de tri à l’aide de différentes valeurs de **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="10689-444">Store multiple copies of each entity using different **RowKey** values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span> <span data-ttu-id="10689-445">La cohérence des mises à jour entre les copies peut être assurée à l’aide d’une EGT.</span><span class="sxs-lookup"><span data-stu-id="10689-445">Updates between copies can be kept consistent using EGT's.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="10689-446">Contexte et problème</span><span class="sxs-lookup"><span data-stu-id="10689-446">Context and problem</span></span>
<span data-ttu-id="10689-447">Le service de Table indexe automatiquement les entités en utilisant les valeurs de **PartitionKey** et de **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="10689-447">The Table service automatically indexes entities using the **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="10689-448">Ainsi, une application cliente peut récupérer une entité efficacement à l'aide de ces valeurs.</span><span class="sxs-lookup"><span data-stu-id="10689-448">This enables a client application to retrieve an entity efficiently using these values.</span></span> <span data-ttu-id="10689-449">Par exemple, en utilisant la structure de table ci-dessous, une application cliente peut utiliser une requête de pointage pour récupérer une entité d’employé individuel en utilisant le nom de son service et son ID d’employé (les valeurs de **PartitionKey** et de **RowKey**).</span><span class="sxs-lookup"><span data-stu-id="10689-449">For example, using the table structure shown below, a client application can use a point query to retrieve an individual employee entity by using the department name and the employee id (the **PartitionKey** and **RowKey** values).</span></span> <span data-ttu-id="10689-450">Un client peut également récupérer des entités, triées par ID d'employé au sein de chaque service.</span><span class="sxs-lookup"><span data-stu-id="10689-450">A client can also retrieve entities sorted by employee id within each department.</span></span>

![][6]

<span data-ttu-id="10689-451">Si vous voulez également pouvoir trouver une entité d'employé en fonction de la valeur d'une autre propriété, comme l'adresse de messagerie, vous devez utiliser une analyse de partition moins efficace pour rechercher une correspondance.</span><span class="sxs-lookup"><span data-stu-id="10689-451">If you also want to be able to find an employee entity based on the value of another property, such as email address, you must use a less efficient partition scan to find a match.</span></span> <span data-ttu-id="10689-452">En effet, le service de Table ne fournit pas d'index secondaires.</span><span class="sxs-lookup"><span data-stu-id="10689-452">This is because the table service does not provide secondary indexes.</span></span> <span data-ttu-id="10689-453">De plus, vous ne pouvez pas demander une liste des employés triés dans un ordre différent de celui de **RowKey** .</span><span class="sxs-lookup"><span data-stu-id="10689-453">In addition, there is no option to request a list of employees sorted in a different order than **RowKey** order.</span></span>  

#### <a name="solution"></a><span data-ttu-id="10689-454">Solution</span><span class="sxs-lookup"><span data-stu-id="10689-454">Solution</span></span>
<span data-ttu-id="10689-455">Pour contourner l’absence d’index secondaires, vous pouvez stocker plusieurs copies de chaque entité avec chaque copie en utilisant une autre valeur de **RowKey** .</span><span class="sxs-lookup"><span data-stu-id="10689-455">To work around the lack of secondary indexes, you can store multiple copies of each entity with each copy using a different **RowKey** value.</span></span> <span data-ttu-id="10689-456">Si vous stockez une entité avec les structures indiquées ci-dessous, vous pouvez récupérer efficacement des entités d’employés selon leur adresse de messagerie ou leur ID d’employé. Les valeurs de préfixe pour **RowKey**, « empid » et « email » permettent d’interroger un seul employé ou une plage d’employés à l’aide d’une plage d’adresses de messagerie ou d’ID d’employé.</span><span class="sxs-lookup"><span data-stu-id="10689-456">If you store an entity with the structures shown below, you can efficiently retrieve employee entities based on email address or employee id. The prefix values for the **RowKey**, "empid_" and "email_" enable you to query for a single employee or a range of employees by using a range of email addresses or employee ids.</span></span>  

![][7]

<span data-ttu-id="10689-457">Les deux critères de filtre suivants (l'un recherchant selon l'ID d'employé et l'autre selon l'adresse de messagerie) spécifient tous deux des requêtes de pointage :</span><span class="sxs-lookup"><span data-stu-id="10689-457">The following two filter criteria (one looking up by employee id and one looking up by email address) both specify point queries:</span></span>  

* <span data-ttu-id="10689-458">$filter=(PartitionKey eq ’Sales’) and (RowKey eq ’empid_000223’)</span><span class="sxs-lookup"><span data-stu-id="10689-458">$filter=(PartitionKey eq 'Sales') and (RowKey eq 'empid_000223')</span></span>  
* <span data-ttu-id="10689-459">$filter=(PartitionKey eq 'Sales') and (RowKey eq email_jonesj@contoso.com</span><span class="sxs-lookup"><span data-stu-id="10689-459">$filter=(PartitionKey eq 'Sales') and (RowKey eq 'email_jonesj@contoso.com')</span></span>  

<span data-ttu-id="10689-460">Si vous interrogez un ensemble d’entités d’employés, vous pouvez spécifier une plage triée dans l’ordre des ID d’employé, ou une plage triée dans l’ordre des adresses de messagerie en interrogeant des entités avec le préfixe approprié ajouté à la **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="10689-460">If you query for a range of employee entities, you can specify a range sorted in employee id order, or a range sorted in email address order by querying for entities with the appropriate prefix in the **RowKey**.</span></span>  

* <span data-ttu-id="10689-461">Pour rechercher tous les employés du service des ventes ayant un ID d’employé situé dans la plage de 000100 à 000199, utilisez : $filter=(PartitionKey eq ’Sales’) and (RowKey ge ’empid_000100’) and (RowKey le ’empid_000199’)</span><span class="sxs-lookup"><span data-stu-id="10689-461">To find all the employees in the Sales department with an employee id in the range 000100 to 000199 use: $filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000100') and (RowKey le 'empid_000199')</span></span>  
* <span data-ttu-id="10689-462">Pour rechercher tous les employés du service des ventes dont l’adresse de messagerie commence par la lettre « a », utilisez : $filter=(PartitionKey eq ’Sales’) and (RowKey ge ’email_a’) and (RowKey lt ’email_b’)</span><span class="sxs-lookup"><span data-stu-id="10689-462">To find all the employees in the Sales department with an email address starting with the letter 'a' use: $filter=(PartitionKey eq 'Sales') and (RowKey ge 'email_a') and (RowKey lt 'email_b')</span></span>  
  
  <span data-ttu-id="10689-463">Notez que la syntaxe de filtre utilisée dans les exemples ci-dessus provient de l’API REST Service de Table. Pour en savoir plus, consultez [Interrogation d’entités](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span><span class="sxs-lookup"><span data-stu-id="10689-463">Note that the filter syntax used in the examples above is from the Table service REST API, for more information see [Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="10689-464">Problèmes et considérations</span><span class="sxs-lookup"><span data-stu-id="10689-464">Issues and considerations</span></span>
<span data-ttu-id="10689-465">Prenez en compte les points suivants lorsque vous choisissez comment implémenter ce modèle :</span><span class="sxs-lookup"><span data-stu-id="10689-465">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="10689-466">L'utilisation du stockage de tables est relativement bon marché. Le coût réel du stockage des données en double ne doit donc pas être une préoccupation majeure.</span><span class="sxs-lookup"><span data-stu-id="10689-466">Table storage is relatively cheap to use so the cost overhead of storing duplicate data should not be a major concern.</span></span> <span data-ttu-id="10689-467">Toutefois, vous devez toujours évaluer le coût de la conception en fonction de vos besoins en stockage anticipés et ajouter uniquement des entités en double pour prendre en charge les requêtes que votre application cliente exécutera.</span><span class="sxs-lookup"><span data-stu-id="10689-467">However, you should always evaluate the cost of your design based on your anticipated storage requirements and only add duplicate entities to support the queries your client application will execute.</span></span>  
* <span data-ttu-id="10689-468">Comme les entités d'index secondaires sont stockées dans la même partition que les entités d'origine, vous devez vous assurer que vous ne dépassez pas les objectifs d'évolutivité pour une partition individuelle.</span><span class="sxs-lookup"><span data-stu-id="10689-468">Because the secondary index entities are stored in the same partition as the original entities, you should ensure that you do not exceed the scalability targets for an individual partition.</span></span>  
* <span data-ttu-id="10689-469">Vous pouvez maintenir la cohérence de vos entités en double en utilisant des EGT pour mettre à jour de façon atomique les deux copies d'une même entité.</span><span class="sxs-lookup"><span data-stu-id="10689-469">You can keep your duplicate entities consistent with each other by using EGTs to update the two copies of the entity atomically.</span></span> <span data-ttu-id="10689-470">Cela implique un stockage de toutes les copies d'une entité dans la même partition.</span><span class="sxs-lookup"><span data-stu-id="10689-470">This implies that you should store all copies of an entity in the same partition.</span></span> <span data-ttu-id="10689-471">Pour en savoir plus, consultez la section [Utilisation des transactions de groupe d’entités](#entity-group-transactions).</span><span class="sxs-lookup"><span data-stu-id="10689-471">For more information, see the section [Using Entity Group Transactions](#entity-group-transactions).</span></span>  
* <span data-ttu-id="10689-472">La valeur de la **RowKey** doit être unique pour chaque entité.</span><span class="sxs-lookup"><span data-stu-id="10689-472">The value used for the **RowKey** must be unique for each entity.</span></span> <span data-ttu-id="10689-473">Nous vous conseillons d'utiliser des valeurs de clé composée.</span><span class="sxs-lookup"><span data-stu-id="10689-473">Consider using compound key values.</span></span>  
* <span data-ttu-id="10689-474">Le remplissage des valeurs numériques dans les **RowKey** (par exemple, l’ID d’employé 000223) permet de corriger le tri et le filtrage en fonction des limites inférieure et supérieure.</span><span class="sxs-lookup"><span data-stu-id="10689-474">Padding numeric values in the **RowKey** (for example, the employee id 000223), enables correct sorting and filtering based on upper and lower bounds.</span></span>  
* <span data-ttu-id="10689-475">Vous n'avez pas toujours besoin de dupliquer toutes les propriétés de votre entité.</span><span class="sxs-lookup"><span data-stu-id="10689-475">You do not necessarily need to duplicate all the properties of your entity.</span></span> <span data-ttu-id="10689-476">Par exemple, si les requêtes de recherche des entités à l’aide de l’adresse de messagerie dans la **RowKey** n’ont jamais besoin de l’âge de l’employé, ces entités peuvent présenter la structure suivante :</span><span class="sxs-lookup"><span data-stu-id="10689-476">For example, if the queries that lookup the entities using the email address in the **RowKey** never need the employee's age, these entities could have the following structure:</span></span>

![][8]

* <span data-ttu-id="10689-477">Il est généralement préférable de stocker les données en double et de vous assurer que vous pouvez récupérer toutes les données dont vous avez besoin avec une seule requête, plutôt que d'utiliser une requête pour rechercher une entité et une autre pour rechercher les données requises.</span><span class="sxs-lookup"><span data-stu-id="10689-477">It is typically better to store duplicate data and ensure that you can retrieve all the data you need with a single query, than to use one query to locate an entity and another to lookup the required data.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="10689-478">Quand utiliser ce modèle</span><span class="sxs-lookup"><span data-stu-id="10689-478">When to use this pattern</span></span>
<span data-ttu-id="10689-479">Utilisez ce modèle lorsque votre application cliente a besoin de récupérer des entités en utilisant des clés différentes, lorsque votre client a besoin de récupérer des entités dans différents ordres de tri et où vous pouvez identifier chaque entité à l'aide d'une variété de valeurs uniques.</span><span class="sxs-lookup"><span data-stu-id="10689-479">Use this pattern when your client application needs to retrieve entities using a variety of different keys, when your client needs to retrieve entities in different sort orders, and where you can identify each entity using a variety of unique values.</span></span> <span data-ttu-id="10689-480">Toutefois, vous devez être sûr de ne pas dépasser les limites d’extensibilité de partition lorsque vous effectuez des recherches d’entité à l’aide des différentes valeurs de **RowKey** .</span><span class="sxs-lookup"><span data-stu-id="10689-480">However, you should be sure that you do not exceed the partition scalability limits when you are performing entity lookups using the different **RowKey** values.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="10689-481">Conseils et modèles connexes</span><span class="sxs-lookup"><span data-stu-id="10689-481">Related patterns and guidance</span></span>
<span data-ttu-id="10689-482">Les modèles et les conseils suivants peuvent également être pertinents lors de l'implémentation de ce modèle :</span><span class="sxs-lookup"><span data-stu-id="10689-482">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="10689-483">Modèle d’index secondaire entre les partitions</span><span class="sxs-lookup"><span data-stu-id="10689-483">Inter-partition secondary index pattern</span></span>](#inter-partition-secondary-index-pattern)
* [<span data-ttu-id="10689-484">Modèle de clé composée</span><span class="sxs-lookup"><span data-stu-id="10689-484">Compound key pattern</span></span>](#compound-key-pattern)
* [<span data-ttu-id="10689-485">Transactions de groupe d’entités</span><span class="sxs-lookup"><span data-stu-id="10689-485">Entity Group Transactions</span></span>](#entity-group-transactions)
* [<span data-ttu-id="10689-486">Utilisation des types d’entités hétérogènes</span><span class="sxs-lookup"><span data-stu-id="10689-486">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)

### <a name="inter-partition-secondary-index-pattern"></a><span data-ttu-id="10689-487">Modèle d’index secondaire entre les partitions</span><span class="sxs-lookup"><span data-stu-id="10689-487">Inter-partition secondary index pattern</span></span>
<span data-ttu-id="10689-488">Stockez plusieurs copies de chaque entité à l’aide de différentes valeurs de **RowKey** dans des partitions ou des tables distinctes pour mener des recherches rapides et efficaces et alterner des commandes de tri à l’aide de différentes valeurs de **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="10689-488">Store multiple copies of each entity using different **RowKey** values in separate partitions or in separate tables to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="10689-489">Contexte et problème</span><span class="sxs-lookup"><span data-stu-id="10689-489">Context and problem</span></span>
<span data-ttu-id="10689-490">Le service de Table indexe automatiquement les entités en utilisant les valeurs de **PartitionKey** et de **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="10689-490">The Table service automatically indexes entities using the **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="10689-491">Ainsi, une application cliente peut récupérer une entité efficacement à l'aide de ces valeurs.</span><span class="sxs-lookup"><span data-stu-id="10689-491">This enables a client application to retrieve an entity efficiently using these values.</span></span> <span data-ttu-id="10689-492">Par exemple, en utilisant la structure de table ci-dessous, une application cliente peut utiliser une requête de pointage pour récupérer une entité d’employé individuel en utilisant le nom de son service et son ID d’employé (les valeurs de **PartitionKey** et de **RowKey**).</span><span class="sxs-lookup"><span data-stu-id="10689-492">For example, using the table structure shown below, a client application can use a point query to retrieve an individual employee entity by using the department name and the employee id (the **PartitionKey** and **RowKey** values).</span></span> <span data-ttu-id="10689-493">Un client peut également récupérer des entités, triées par ID d'employé au sein de chaque service.</span><span class="sxs-lookup"><span data-stu-id="10689-493">A client can also retrieve entities sorted by employee id within each department.</span></span>  

![][9]

<span data-ttu-id="10689-494">Si vous voulez également pouvoir trouver une entité d'employé en fonction de la valeur d'une autre propriété, comme l'adresse de messagerie, vous devez utiliser une analyse de partition moins efficace pour rechercher une correspondance.</span><span class="sxs-lookup"><span data-stu-id="10689-494">If you also want to be able to find an employee entity based on the value of another property, such as email address, you must use a less efficient partition scan to find a match.</span></span> <span data-ttu-id="10689-495">En effet, le service de Table ne fournit pas d'index secondaires.</span><span class="sxs-lookup"><span data-stu-id="10689-495">This is because the table service does not provide secondary indexes.</span></span> <span data-ttu-id="10689-496">De plus, vous ne pouvez pas demander une liste des employés triés dans un ordre différent de celui de **RowKey** .</span><span class="sxs-lookup"><span data-stu-id="10689-496">In addition, there is no option to request a list of employees sorted in a different order than **RowKey** order.</span></span>  

<span data-ttu-id="10689-497">Vous prévoyez un volume très élevé de transactions sur ces entités et vous souhaitez réduire le risque de limitation de votre client par le service de Table.</span><span class="sxs-lookup"><span data-stu-id="10689-497">You are anticipating a very high volume of transactions against these entities and want to minimize the risk of the Table service throttling your client.</span></span>  

#### <a name="solution"></a><span data-ttu-id="10689-498">Solution</span><span class="sxs-lookup"><span data-stu-id="10689-498">Solution</span></span>
<span data-ttu-id="10689-499">Pour contourner l’absence d’index secondaires, vous pouvez stocker plusieurs copies de chaque entité avec chaque copie à l’aide de différentes valeurs de **PartitionKey** et de **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="10689-499">To work around the lack of secondary indexes, you can store multiple copies of each entity with each copy using different **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="10689-500">Si vous stockez une entité avec les structures indiquées ci-dessous, vous pouvez récupérer efficacement des entités d’employés selon leur adresse de messagerie ou leur ID d’employé. Les valeurs de préfixe pour **PartitionKey**, « empid » et « email » permettent d’identifier l’index à utiliser pour une requête.</span><span class="sxs-lookup"><span data-stu-id="10689-500">If you store an entity with the structures shown below, you can efficiently retrieve employee entities based on email address or employee id. The prefix values for the **PartitionKey**, "empid_" and "email_" enable you to identify which index you want to use for a query.</span></span>  

![][10]

<span data-ttu-id="10689-501">Les deux critères de filtre suivants (l'un recherchant selon l'ID d'employé et l'autre selon l'adresse de messagerie) spécifient tous deux des requêtes de pointage :</span><span class="sxs-lookup"><span data-stu-id="10689-501">The following two filter criteria (one looking up by employee id and one looking up by email address) both specify point queries:</span></span>  

* <span data-ttu-id="10689-502">$filter=(PartitionKey eq ’empid_Sales’) and (RowKey eq ’000223’)</span><span class="sxs-lookup"><span data-stu-id="10689-502">$filter=(PartitionKey eq 'empid_Sales') and (RowKey eq '000223')</span></span>
* <span data-ttu-id="10689-503">$filter=(PartitionKey eq ’email_Sales’) and (RowKey eq jonesj@contoso.com</span><span class="sxs-lookup"><span data-stu-id="10689-503">$filter=(PartitionKey eq 'email_Sales') and (RowKey eq 'jonesj@contoso.com')</span></span>  

<span data-ttu-id="10689-504">Si vous interrogez un ensemble d’entités d’employés, vous pouvez spécifier une plage triée dans l’ordre des ID d’employé, ou une plage triée dans l’ordre des adresses de messagerie en interrogeant des entités avec le préfixe approprié ajouté à la **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="10689-504">If you query for a range of employee entities, you can specify a range sorted in employee id order, or a range sorted in email address order by querying for entities with the appropriate prefix in the **RowKey**.</span></span>  

* <span data-ttu-id="10689-505">Pour rechercher tous les employés du service des ventes ayant un ID d’employé situé dans la plage de **000100** à **000199**, utilisez : $filter=(PartitionKey eq ’empid_Sales’) et (RowKey ge ’000100’) et (RowKey le ’000199’)</span><span class="sxs-lookup"><span data-stu-id="10689-505">To find all the employees in the Sales department with an employee id in the range **000100** to **000199** sorted in employee id order use: $filter=(PartitionKey eq 'empid_Sales') and (RowKey ge '000100') and (RowKey le '000199')</span></span>  
* <span data-ttu-id="10689-506">Pour rechercher tous les employés du service des ventes ayant une adresse de messagerie qui commence par « a » triés dans l’ordre des adresses de messagerie, utilisez : $filter=(PartitionKey eq ’email_Sales’) and (RowKey ge ’a’) and (RowKey lt ’b’)</span><span class="sxs-lookup"><span data-stu-id="10689-506">To find all the employees in the Sales department with an email address that starts with 'a' sorted in email address order use: $filter=(PartitionKey eq 'email_Sales') and (RowKey ge 'a') and (RowKey lt 'b')</span></span>  

<span data-ttu-id="10689-507">Notez que la syntaxe de filtre utilisée dans les exemples ci-dessus provient de l’API REST Service de Table. Pour en savoir plus, consultez [Interrogation d’entités](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span><span class="sxs-lookup"><span data-stu-id="10689-507">Note that the filter syntax used in the examples above is from the Table service REST API, for more information see [Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="10689-508">Problèmes et considérations</span><span class="sxs-lookup"><span data-stu-id="10689-508">Issues and considerations</span></span>
<span data-ttu-id="10689-509">Prenez en compte les points suivants lorsque vous choisissez comment implémenter ce modèle :</span><span class="sxs-lookup"><span data-stu-id="10689-509">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="10689-510">Vous pouvez conserver la cohérence de vos entités en double en utilisant le [modèle de transactions cohérentes](#eventually-consistent-transactions-pattern) pour gérer les entités d’index primaire et secondaire.</span><span class="sxs-lookup"><span data-stu-id="10689-510">You can keep your duplicate entities eventually consistent with each other by using the [Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) to maintain the primary and secondary index entities.</span></span>  
* <span data-ttu-id="10689-511">L'utilisation du stockage de tables est relativement bon marché. Le coût réel du stockage des données en double ne doit donc pas être une préoccupation majeure.</span><span class="sxs-lookup"><span data-stu-id="10689-511">Table storage is relatively cheap to use so the cost overhead of storing duplicate data should not be a major concern.</span></span> <span data-ttu-id="10689-512">Toutefois, vous devez toujours évaluer le coût de la conception en fonction de vos besoins en stockage anticipés et ajouter uniquement des entités en double pour prendre en charge les requêtes que votre application cliente exécutera.</span><span class="sxs-lookup"><span data-stu-id="10689-512">However, you should always evaluate the cost of your design based on your anticipated storage requirements and only add duplicate entities to support the queries your client application will execute.</span></span>  
* <span data-ttu-id="10689-513">La valeur de la **RowKey** doit être unique pour chaque entité.</span><span class="sxs-lookup"><span data-stu-id="10689-513">The value used for the **RowKey** must be unique for each entity.</span></span> <span data-ttu-id="10689-514">Nous vous conseillons d'utiliser des valeurs de clé composée.</span><span class="sxs-lookup"><span data-stu-id="10689-514">Consider using compound key values.</span></span>  
* <span data-ttu-id="10689-515">Le remplissage des valeurs numériques dans les **RowKey** (par exemple, l’ID d’employé 000223) permet de corriger le tri et le filtrage en fonction des limites inférieure et supérieure.</span><span class="sxs-lookup"><span data-stu-id="10689-515">Padding numeric values in the **RowKey** (for example, the employee id 000223), enables correct sorting and filtering based on upper and lower bounds.</span></span>  
* <span data-ttu-id="10689-516">Vous n'avez pas toujours besoin de dupliquer toutes les propriétés de votre entité.</span><span class="sxs-lookup"><span data-stu-id="10689-516">You do not necessarily need to duplicate all the properties of your entity.</span></span> <span data-ttu-id="10689-517">Par exemple, si les requêtes de recherche des entités à l’aide de l’adresse de messagerie dans la **RowKey** n’ont jamais besoin de l’âge de l’employé, ces entités peuvent présenter la structure suivante :</span><span class="sxs-lookup"><span data-stu-id="10689-517">For example, if the queries that lookup the entities using the email address in the **RowKey** never need the employee's age, these entities could have the following structure:</span></span>
  
  ![][11]
* <span data-ttu-id="10689-518">Il est généralement préférable de stocker les données en double et de vous assurer que vous pouvez récupérer toutes les données dont vous avez besoin en utilisant une seule requête, plutôt que d'utiliser une requête pour rechercher une entité à l'aide de l'index secondaire et une autre pour rechercher les données requises dans l'index primaire.</span><span class="sxs-lookup"><span data-stu-id="10689-518">It is typically better to store duplicate data and ensure that you can retrieve all the data you need with a single query than to use one query to locate an entity using the secondary index and another to lookup the required data in the primary index.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="10689-519">Quand utiliser ce modèle</span><span class="sxs-lookup"><span data-stu-id="10689-519">When to use this pattern</span></span>
<span data-ttu-id="10689-520">Utilisez ce modèle lorsque votre application cliente a besoin de récupérer des entités en utilisant des clés différentes, lorsque votre client a besoin de récupérer des entités dans différents ordres de tri et où vous pouvez identifier chaque entité à l'aide d'une variété de valeurs uniques.</span><span class="sxs-lookup"><span data-stu-id="10689-520">Use this pattern when your client application needs to retrieve entities using a variety of different keys, when your client needs to retrieve entities in different sort orders, and where you can identify each entity using a variety of unique values.</span></span> <span data-ttu-id="10689-521">Utilisez ce modèle si vous voulez éviter le dépassement des limites d’extensibilité de partition quand vous effectuez des recherches d’entité à l’aide des différentes valeurs de **RowKey** .</span><span class="sxs-lookup"><span data-stu-id="10689-521">Use this pattern when you want to avoid exceeding the partition scalability limits when you are performing entity lookups using the different **RowKey** values.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="10689-522">Conseils et modèles connexes</span><span class="sxs-lookup"><span data-stu-id="10689-522">Related patterns and guidance</span></span>
<span data-ttu-id="10689-523">Les modèles et les conseils suivants peuvent également être pertinents lors de l'implémentation de ce modèle :</span><span class="sxs-lookup"><span data-stu-id="10689-523">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="10689-524">Modèle de transactions cohérentes</span><span class="sxs-lookup"><span data-stu-id="10689-524">Eventually consistent transactions pattern</span></span>](#eventually-consistent-transactions-pattern)  
* [<span data-ttu-id="10689-525">Modèle d’index secondaire intra-partition</span><span class="sxs-lookup"><span data-stu-id="10689-525">Intra-partition secondary index pattern</span></span>](#intra-partition-secondary-index-pattern)  
* [<span data-ttu-id="10689-526">Modèle de clé composée</span><span class="sxs-lookup"><span data-stu-id="10689-526">Compound key pattern</span></span>](#compound-key-pattern)  
* [<span data-ttu-id="10689-527">Transactions de groupe d’entités</span><span class="sxs-lookup"><span data-stu-id="10689-527">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="10689-528">Utilisation des types d’entités hétérogènes</span><span class="sxs-lookup"><span data-stu-id="10689-528">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)  

### <a name="eventually-consistent-transactions-pattern"></a><span data-ttu-id="10689-529">Modèle de transactions cohérentes</span><span class="sxs-lookup"><span data-stu-id="10689-529">Eventually consistent transactions pattern</span></span>
<span data-ttu-id="10689-530">Permet de conserver un comportement cohérent entre les limites de partition ou les limites du système de stockage à l'aide des files d'attente Azure.</span><span class="sxs-lookup"><span data-stu-id="10689-530">Enable eventually consistent behavior across partition boundaries or storage system boundaries by using Azure queues.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="10689-531">Contexte et problème</span><span class="sxs-lookup"><span data-stu-id="10689-531">Context and problem</span></span>
<span data-ttu-id="10689-532">Les EGT activent les transactions atomiques de plusieurs entités qui partagent la même clé de partition.</span><span class="sxs-lookup"><span data-stu-id="10689-532">EGTs enable atomic transactions across multiple entities that share the same partition key.</span></span> <span data-ttu-id="10689-533">Pour des raisons d'évolutivité et de performances, vous pouvez décider de stocker des entités ayant des exigences de cohérence dans des partitions distinctes ou dans un système de stockage distinct : dans ce scénario, vous ne pouvez pas utiliser les EGT pour maintenir la cohérence.</span><span class="sxs-lookup"><span data-stu-id="10689-533">For performance and scalability reasons, you might decide to store entities that have consistency requirements in separate partitions or in a separate storage system: in such a scenario, you cannot use EGTs to maintain consistency.</span></span> <span data-ttu-id="10689-534">Par exemple, vous pouvez avoir besoin de maintenir la cohérence entre :</span><span class="sxs-lookup"><span data-stu-id="10689-534">For example, you might have a requirement to maintain eventual consistency between:</span></span>  

* <span data-ttu-id="10689-535">des entités stockées dans deux partitions différentes dans la même table, dans des tables différentes, dans différents comptes de stockage ;</span><span class="sxs-lookup"><span data-stu-id="10689-535">Entities stored in two different partitions in the same table, in different tables, in in different storage accounts.</span></span>  
* <span data-ttu-id="10689-536">une entité stockée dans le service de Table et un objet blob stocké dans le service d'objets blob ;</span><span class="sxs-lookup"><span data-stu-id="10689-536">An entity stored in the Table service and a blob stored in the Blob service.</span></span>  
* <span data-ttu-id="10689-537">une entité stockée dans le service de Table et un fichier dans un système de fichiers ;</span><span class="sxs-lookup"><span data-stu-id="10689-537">An entity stored in the Table service and a file in a file system.</span></span>  
* <span data-ttu-id="10689-538">un magasin d'entités du service de Table encore indexé en utilisant le service Azure Search.</span><span class="sxs-lookup"><span data-stu-id="10689-538">An entity store in the Table service yet indexed using the Azure Search service.</span></span>  

#### <a name="solution"></a><span data-ttu-id="10689-539">Solution</span><span class="sxs-lookup"><span data-stu-id="10689-539">Solution</span></span>
<span data-ttu-id="10689-540">À l'aide des files d'attente Azure, vous pouvez implémenter une solution cohérente entre plusieurs partitions ou systèmes de stockage.</span><span class="sxs-lookup"><span data-stu-id="10689-540">By using Azure queues, you can implement a solution that delivers eventual consistency across two or more partitions or storage systems.</span></span>
<span data-ttu-id="10689-541">Pour illustrer cette approche, supposons que vous ayez besoin d'archiver d'anciennes entités d'employés.</span><span class="sxs-lookup"><span data-stu-id="10689-541">To illustrate this approach, assume you have a requirement to be able to archive old employee entities.</span></span> <span data-ttu-id="10689-542">Les anciennes entités d'employés sont rarement interrogées et doivent être exclues de toutes les activités impliquant des employés actuels.</span><span class="sxs-lookup"><span data-stu-id="10689-542">Old employee entities are rarely queried and should be excluded from any activities that deal with current employees.</span></span> <span data-ttu-id="10689-543">Pour implémenter cette exigence, vous stockez des employés actifs dans la table **Current** et les anciens employés dans la table **Archive**.</span><span class="sxs-lookup"><span data-stu-id="10689-543">To implement this requirement you store active employees in the **Current** table and old employees in the **Archive** table.</span></span> <span data-ttu-id="10689-544">L’archivage d’un employé nécessite la suppression de son entité de la table **Current** et son ajout à la table **Archive**, mais vous ne pouvez pas utiliser une EGT pour effectuer ces deux opérations.</span><span class="sxs-lookup"><span data-stu-id="10689-544">Archiving an employee requires you to delete the entity from the **Current** table and add the entity to the **Archive** table, but you cannot use an EGT to perform these two operations.</span></span> <span data-ttu-id="10689-545">Pour éviter le risque qu'une défaillance provoque l'apparition d'une entité dans les deux tables ou dans aucune d'elles, l'opération d'archivage doit être cohérente.</span><span class="sxs-lookup"><span data-stu-id="10689-545">To avoid the risk that a failure causes an entity to appear in both or neither tables, the archive operation must be eventually consistent.</span></span> <span data-ttu-id="10689-546">Le diagramme de séquence suivant décrit les étapes de cette opération.</span><span class="sxs-lookup"><span data-stu-id="10689-546">The following sequence diagram outlines the steps in this operation.</span></span> <span data-ttu-id="10689-547">Le texte suivant fournit plus de détails au sujet des chemins d'accès de l'exception.</span><span class="sxs-lookup"><span data-stu-id="10689-547">More detail is provided for exception paths in the text following.</span></span>  

![][12]

<span data-ttu-id="10689-548">Un client lance l'opération d'archivage en plaçant un message dans une file d'attente Azure, dans cet exemple pour archiver l'employé #456.</span><span class="sxs-lookup"><span data-stu-id="10689-548">A client initiates the archive operation by placing a message on an Azure queue, in this example to archive employee #456.</span></span> <span data-ttu-id="10689-549">Un rôle de travail interroge la file d'attente à la recherche de nouveaux messages ; lorsqu'il en trouve un, il le lit et laisse une copie masquée dans la file d'attente.</span><span class="sxs-lookup"><span data-stu-id="10689-549">A worker role polls the queue for new messages; when it finds one, it reads the message and leaves a hidden copy on the queue.</span></span> <span data-ttu-id="10689-550">Le rôle de travail extrait ensuite une copie de l’entité à partir de la table **Current**, insère une copie dans la table **Archive** et supprime l’original de la table **Current**.</span><span class="sxs-lookup"><span data-stu-id="10689-550">The worker role next fetches a copy of the entity from the **Current** table, inserts a copy in the **Archive** table, and then deletes the original from the **Current** table.</span></span> <span data-ttu-id="10689-551">Enfin, si aucune erreur n'est survenue lors des étapes précédentes, le rôle de travail supprime le message masqué de la file d'attente.</span><span class="sxs-lookup"><span data-stu-id="10689-551">Finally, if there were no errors from the previous steps, the worker role deletes the hidden message from the queue.</span></span>  

<span data-ttu-id="10689-552">Dans cet exemple, l’étape 4 permet d’insérer l’employé dans la table **Archive** .</span><span class="sxs-lookup"><span data-stu-id="10689-552">In this example, step 4 inserts the employee into the **Archive** table.</span></span> <span data-ttu-id="10689-553">L'employé peut être ajouté à un objet blob dans le service d'objets blob ou à un fichier dans un système de fichiers.</span><span class="sxs-lookup"><span data-stu-id="10689-553">It could add the employee to a blob in the Blob service or a file in a file system.</span></span>  

#### <a name="recovering-from-failures"></a><span data-ttu-id="10689-554">Récupération après échec</span><span class="sxs-lookup"><span data-stu-id="10689-554">Recovering from failures</span></span>
<span data-ttu-id="10689-555">Il est important que les opérations des étapes **4** et **5** soient *idempotentes* au cas où le rôle de travail nécessite un redémarrage de l’opération d’archivage.</span><span class="sxs-lookup"><span data-stu-id="10689-555">It is important that the operations in steps **4** and **5** must be *idempotent* in case the worker role needs to restart the archive operation.</span></span> <span data-ttu-id="10689-556">Si vous utilisez le service de Table, à l’étape **4**, vous devez utiliser une opération « insérer ou remplacer » (insert or replace) ; à l’étape **5**, vous devez faire appel à une opération « supprimer si existe » (delete if exists) dans la bibliothèque cliente que vous utilisez.</span><span class="sxs-lookup"><span data-stu-id="10689-556">If you are using the Table service, for step **4** you should use an "insert or replace" operation; for step **5** you should use a "delete if exists" operation in the client library you are using.</span></span> <span data-ttu-id="10689-557">Si vous utilisez un autre système de stockage, vous devez utiliser une opération idempotent appropriée.</span><span class="sxs-lookup"><span data-stu-id="10689-557">If you are using another storage system, you must use an appropriate idempotent operation.</span></span>  

<span data-ttu-id="10689-558">Si le rôle de travail ne termine jamais l’étape **6**, après un délai d’attente, le message réapparaît dans la file d’attente, prêt pour le rôle de travail qui tentera de le retraiter.</span><span class="sxs-lookup"><span data-stu-id="10689-558">If the worker role never completes step **6**, then after a timeout the message reappears on the queue ready for the worker role to try to reprocess it.</span></span> <span data-ttu-id="10689-559">Le rôle de travail peut vérifier le nombre de fois où un message de file d'attente a été lu et, si nécessaire, l'indiquer comme message « incohérent » en vue d'une investigation en l'envoyant vers une file d'attente distincte.</span><span class="sxs-lookup"><span data-stu-id="10689-559">The worker role can check how many times a message on the queue has been read and, if necessary, flag it is a "poison" message for investigation by sending it to a separate queue.</span></span> <span data-ttu-id="10689-560">Pour plus d’informations sur la lecture des messages de la file d’attente et la vérification du nombre de retraits, consultez [Obtention des messages](https://msdn.microsoft.com/library/azure/dd179474.aspx).</span><span class="sxs-lookup"><span data-stu-id="10689-560">For more information about reading queue messages and checking the dequeue count, see [Get Messages](https://msdn.microsoft.com/library/azure/dd179474.aspx).</span></span>  

<span data-ttu-id="10689-561">Certaines erreurs provenant des services de Table et de File d'attente sont des erreurs temporaires et votre application cliente doit inclure une logique de nouvelle tentative appropriée pour les gérer.</span><span class="sxs-lookup"><span data-stu-id="10689-561">Some errors from the Table and Queue services are transient errors, and your client application should include suitable retry logic to handle them.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="10689-562">Problèmes et considérations</span><span class="sxs-lookup"><span data-stu-id="10689-562">Issues and considerations</span></span>
<span data-ttu-id="10689-563">Prenez en compte les points suivants lorsque vous choisissez comment implémenter ce modèle :</span><span class="sxs-lookup"><span data-stu-id="10689-563">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="10689-564">Cette solution ne fournit pas d'isolation des transactions.</span><span class="sxs-lookup"><span data-stu-id="10689-564">This solution does not provide for transaction isolation.</span></span> <span data-ttu-id="10689-565">Par exemple, un client peut lire les tables **Current** et **Archive** quand le rôle de travail est entre les étapes **4** et **5**, et voir des données incohérentes affichées.</span><span class="sxs-lookup"><span data-stu-id="10689-565">For example, a client could read the **Current** and **Archive** tables when the worker role was between steps **4** and **5**, and see an inconsistent view of the data.</span></span> <span data-ttu-id="10689-566">Notez que les données seront cohérentes par la suite.</span><span class="sxs-lookup"><span data-stu-id="10689-566">Note that the data will be consistent eventually.</span></span>  
* <span data-ttu-id="10689-567">Vous pouvez être amené à vérifier que les étapes 4 et 5 sont idempotent afin d'assurer la cohérence.</span><span class="sxs-lookup"><span data-stu-id="10689-567">You must be sure that steps 4 and 5 are idempotent in order to ensure eventual consistency.</span></span>  
* <span data-ttu-id="10689-568">Vous pouvez mettre à l'échelle la solution en utilisant plusieurs files d'attente et instances de rôle de travail.</span><span class="sxs-lookup"><span data-stu-id="10689-568">You can scale the solution by using multiple queues and worker role instances.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="10689-569">Quand utiliser ce modèle</span><span class="sxs-lookup"><span data-stu-id="10689-569">When to use this pattern</span></span>
<span data-ttu-id="10689-570">Utilisez ce modèle lorsque vous souhaitez maintenir une cohérence entre des entités qui existent dans différentes partitions ou tables.</span><span class="sxs-lookup"><span data-stu-id="10689-570">Use this pattern when you want to guarantee eventual consistency between entities that exist in different partitions or tables.</span></span> <span data-ttu-id="10689-571">Vous pouvez étendre ce modèle pour garantir la cohérence des opérations entre le service de Table, le service BLOB et d'autres sources de données différentes d'Azure Storage, comme une base de données ou un système de fichiers.</span><span class="sxs-lookup"><span data-stu-id="10689-571">You can extend this pattern to ensure eventual consistency for operations across the Table service and the Blob service and other non-Azure Storage data sources such as database or the file system.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="10689-572">Conseils et modèles connexes</span><span class="sxs-lookup"><span data-stu-id="10689-572">Related patterns and guidance</span></span>
<span data-ttu-id="10689-573">Les modèles et les conseils suivants peuvent également être pertinents lors de l'implémentation de ce modèle :</span><span class="sxs-lookup"><span data-stu-id="10689-573">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="10689-574">Transactions de groupe d’entités</span><span class="sxs-lookup"><span data-stu-id="10689-574">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="10689-575">Fusion ou remplacement</span><span class="sxs-lookup"><span data-stu-id="10689-575">Merge or replace</span></span>](#merge-or-replace)  

> [!NOTE]
> <span data-ttu-id="10689-576">Si l'isolation des transactions est importante pour votre solution, vous devez envisager de redéfinir vos tables pour pouvoir utiliser des EGT.</span><span class="sxs-lookup"><span data-stu-id="10689-576">If transaction isolation is important to your solution, you should consider redesigning your tables to enable you to use EGTs.</span></span>  
> 
> 

### <a name="index-entities-pattern"></a><span data-ttu-id="10689-577">Modèle d’entités d’index</span><span class="sxs-lookup"><span data-stu-id="10689-577">Index Entities Pattern</span></span>
<span data-ttu-id="10689-578">Permet de mettre à jour des entités d'index pour mener des recherches efficaces renvoyant des listes d'entités.</span><span class="sxs-lookup"><span data-stu-id="10689-578">Maintain index entities to enable efficient searches that return lists of entities.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="10689-579">Contexte et problème</span><span class="sxs-lookup"><span data-stu-id="10689-579">Context and problem</span></span>
<span data-ttu-id="10689-580">Le service de Table indexe automatiquement les entités en utilisant les valeurs de **PartitionKey** et de **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="10689-580">The Table service automatically indexes entities using the **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="10689-581">Ainsi, une application cliente peut récupérer une entité efficacement à l'aide d'une requête de pointage.</span><span class="sxs-lookup"><span data-stu-id="10689-581">This enables a client application to retrieve an entity efficiently using a point query.</span></span> <span data-ttu-id="10689-582">Par exemple, en utilisant la structure de la table ci-dessous, une application cliente peut récupérer efficacement une entité d’employé individuel en utilisant le nom du service et l’ID de cet employé (la valeur de **PartitionKey** et de **RowKey**).</span><span class="sxs-lookup"><span data-stu-id="10689-582">For example, using the table structure shown below, a client application can efficiently retrieve an individual employee entity by using the department name and the employee id (the **PartitionKey** and **RowKey**).</span></span>  

![][13]

<span data-ttu-id="10689-583">Si vous voulez également récupérer la liste des entités d'employés en fonction de la valeur d'une autre propriété qui n'est pas unique (par exemple, son nom), vous devez utiliser une analyse de partition moins efficace pour rechercher des correspondances, plutôt que d'utiliser un index pour rechercher directement.</span><span class="sxs-lookup"><span data-stu-id="10689-583">If you also want to be able to retrieve a list of employee entities based on the value of another non-unique property, such as their last name, you must use a less efficient partition scan to find matches rather than using an index to look them up directly.</span></span> <span data-ttu-id="10689-584">En effet, le service de Table ne fournit pas d'index secondaires.</span><span class="sxs-lookup"><span data-stu-id="10689-584">This is because the table service does not provide secondary indexes.</span></span>  

#### <a name="solution"></a><span data-ttu-id="10689-585">Solution</span><span class="sxs-lookup"><span data-stu-id="10689-585">Solution</span></span>
<span data-ttu-id="10689-586">Pour permettre la recherche par nom de famille en utilisant la structure d'entité indiquée ci-dessus, vous devez gérer des listes des ID d'employés.</span><span class="sxs-lookup"><span data-stu-id="10689-586">To enable lookup by last name with the entity structure shown above, you must maintain lists of employee ids.</span></span> <span data-ttu-id="10689-587">Si vous voulez récupérer les entités d'employés ayant un nom donné (comme Jones), vous devez d'abord localiser la liste des ID d'employés dont le nom est Jones, puis récupérer ces entités d'employés.</span><span class="sxs-lookup"><span data-stu-id="10689-587">If you want to retrieve the employee entities with a particular last name, such as Jones, you must first locate the list of employee ids for employees with Jones as their last name, and then retrieve those employee entities.</span></span> <span data-ttu-id="10689-588">Il existe trois méthodes principales pour stocker les listes d'ID d'employés :</span><span class="sxs-lookup"><span data-stu-id="10689-588">There are three main options for storing the lists of employee ids:</span></span>  

* <span data-ttu-id="10689-589">Le stockage d'objets blob.</span><span class="sxs-lookup"><span data-stu-id="10689-589">Use blob storage.</span></span>  
* <span data-ttu-id="10689-590">La création d'entités d'index dans la même partition que les entités des employés.</span><span class="sxs-lookup"><span data-stu-id="10689-590">Create index entities in the same partition as the employee entities.</span></span>  
* <span data-ttu-id="10689-591">La création d'entités d'index dans une table ou une partition séparée.</span><span class="sxs-lookup"><span data-stu-id="10689-591">Create index entities in a separate partition or table.</span></span>  

<span data-ttu-id="10689-592"><u>Méthode nº 1 : stockage d’objets blob</u></span><span class="sxs-lookup"><span data-stu-id="10689-592"><u>Option #1: Use blob storage</u></span></span>  

<span data-ttu-id="10689-593">Pour la première méthode, vous créez un objet blob pour chaque nom unique et dans chaque magasin d’objets blob vous stockez une liste des valeurs de **PartitionKey** (service) et de **RowKey** (ID d’employé) pour les employés portant ce nom.</span><span class="sxs-lookup"><span data-stu-id="10689-593">For the first option, you create a blob for every unique last name, and in each blob store a list of the **PartitionKey** (department) and **RowKey** (employee id) values for employees that have that last name.</span></span> <span data-ttu-id="10689-594">Lorsque vous ajoutez ou supprimez un employé, vous devez vous assurer que le contenu de l'objet blob adéquat est cohérent avec les entités de l'employé.</span><span class="sxs-lookup"><span data-stu-id="10689-594">When you add or delete an employee you should ensure that the content of the relevant blob is eventually consistent with the employee entities.</span></span>  

<span data-ttu-id="10689-595"><u>Méthode nº 2 :</u> création d’entités d’index dans la même partition</span><span class="sxs-lookup"><span data-stu-id="10689-595"><u>Option #2:</u> Create index entities in the same partition</span></span>  

<span data-ttu-id="10689-596">Pour la seconde méthode, utilisez les entités d'index stockant les données suivantes :</span><span class="sxs-lookup"><span data-stu-id="10689-596">For the second option, use index entities that store the following data:</span></span>  

![][14]

<span data-ttu-id="10689-597">La propriété **EmployeeIDs** contient une liste des ID d’employés pour les employés portant le nom stocké dans la **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="10689-597">The **EmployeeIDs** property contains a list of employee ids for employees with the last name stored in the **RowKey**.</span></span>  

<span data-ttu-id="10689-598">Les étapes suivantes décrivent le processus à suivre lorsque vous ajoutez un nouvel employé si vous utilisez la deuxième option.</span><span class="sxs-lookup"><span data-stu-id="10689-598">The following steps outline the process you should follow when you are adding a new employee if you are using the second option.</span></span> <span data-ttu-id="10689-599">Dans cet exemple, nous ajoutons au service des ventes un employé ayant l'ID 000152 et dont le nom de famille est Jones :</span><span class="sxs-lookup"><span data-stu-id="10689-599">In this example, we are adding an employee with Id 000152 and a last name Jones in the Sales department:</span></span>  

1. <span data-ttu-id="10689-600">Récupérez l’entité de l’index par la valeur de **PartitionKey** « Sales » et la valeur de **RowKey** « Jones ».</span><span class="sxs-lookup"><span data-stu-id="10689-600">Retrieve the index entity with a **PartitionKey** value "Sales" and the **RowKey** value "Jones."</span></span> <span data-ttu-id="10689-601">Enregistrez l'ETag de cette entité pour l'utiliser lors de l'étape 2.</span><span class="sxs-lookup"><span data-stu-id="10689-601">Save the ETag of this entity to use in step 2.</span></span>  
2. <span data-ttu-id="10689-602">Créez une transaction de groupe d’entités (c’est-à-dire une opération par lots) qui insère la nouvelle entité d’employé (valeur de **PartitionKey** « Sales » et valeur de **RowKey** « 000152 ») et met à jour l’entité d’index (valeur de **PartitionKey** « Sales » et valeur de **RowKey** « Jones ») en ajoutant l’ID d’employé à la liste du champ EmployeeIDs.</span><span class="sxs-lookup"><span data-stu-id="10689-602">Create an entity group transaction (that is, a batch operation) that inserts the new employee entity (**PartitionKey** value "Sales" and **RowKey** value "000152"), and updates the index entity (**PartitionKey** value "Sales" and **RowKey** value "Jones") by adding the new employee id to the list in the EmployeeIDs field.</span></span> <span data-ttu-id="10689-603">Pour plus d’informations sur les transactions de groupe d’entités, consultez [Transactions de groupe d’entités](#entity-group-transactions).</span><span class="sxs-lookup"><span data-stu-id="10689-603">For more information about entity group transactions, see [Entity Group Transactions](#entity-group-transactions).</span></span>  
3. <span data-ttu-id="10689-604">Si la transaction de groupe d’entités échoue en raison d’une erreur d’accès concurrentiel optimiste (quelqu’un d’autre vient de modifier l’entité d’index), vous devez recommencer à l’étape 1.</span><span class="sxs-lookup"><span data-stu-id="10689-604">If the entity group transaction fails because of an optimistic concurrency error (someone else has just modified the index entity), then you need to start over at step 1 again.</span></span>  

<span data-ttu-id="10689-605">Vous pouvez utiliser une approche similaire pour supprimer un employé si vous utilisez la deuxième option.</span><span class="sxs-lookup"><span data-stu-id="10689-605">You can use a similar approach to deleting an employee if you are using the second option.</span></span> <span data-ttu-id="10689-606">La modification du nom d’un employé est légèrement plus complexe, car vous devrez exécuter une transaction de groupe d’entités qui met à jour trois entités : l’entité d’employé, l’entité d’index pour l’ancien nom et l’entité d’index pour le nouveau nom.</span><span class="sxs-lookup"><span data-stu-id="10689-606">Changing an employee's last name is slightly more complex because you will need to execute an entity group transaction that updates three entities: the employee entity, the index entity for the old last name, and the index entity for the new last name.</span></span> <span data-ttu-id="10689-607">Vous devez récupérer chaque entité avant d'apporter des modifications afin de récupérer les valeurs ETag que vous pouvez ensuite utiliser pour effectuer les mises à jour à l'aide de l'accès concurrentiel optimiste.</span><span class="sxs-lookup"><span data-stu-id="10689-607">You must retrieve each entity before making any changes in order to retrieve the ETag values that you can then use to perform the updates using optimistic concurrency.</span></span>  

<span data-ttu-id="10689-608">Les étapes suivantes décrivent le processus à suivre lorsque vous devez rechercher tous les employés ayant un nom donné dans un service, si vous utilisez la deuxième méthode.</span><span class="sxs-lookup"><span data-stu-id="10689-608">The following steps outline the process you should follow when you need to look up all the employees with a given last name in a department if you are using the second option.</span></span> <span data-ttu-id="10689-609">Dans cet exemple, nous recherchons tous les employés dont le nom est Jones et qui travaillent dans le service des ventes :</span><span class="sxs-lookup"><span data-stu-id="10689-609">In this example, we are looking up all the employees with last name Jones in the Sales department:</span></span>  

1. <span data-ttu-id="10689-610">Récupérez l’entité de l’index par la valeur de **PartitionKey** « Sales » et la valeur de **RowKey** « Jones ».</span><span class="sxs-lookup"><span data-stu-id="10689-610">Retrieve the index entity with a **PartitionKey** value "Sales" and the **RowKey** value "Jones."</span></span>  
2. <span data-ttu-id="10689-611">Analysez la liste des identificateurs dans le champ EmployeeIDs des employés.</span><span class="sxs-lookup"><span data-stu-id="10689-611">Parse the list of employee Ids in the EmployeeIDs field.</span></span>  
3. <span data-ttu-id="10689-612">Si vous avez besoin de plus d’informations sur chacun de ces employés (par exemple leurs adresses de messagerie), récupérez chacune des entités d’employé à l’aide de la valeur de **PartitionKey** « Sales » et des valeurs de **RowKey** de la liste des employés obtenue à l’étape 2.</span><span class="sxs-lookup"><span data-stu-id="10689-612">If you need additional information about each of these employees (such as their email addresses), retrieve each of the employee entities using **PartitionKey** value "Sales" and **RowKey** values from the list of employees you obtained in step 2.</span></span>  

<span data-ttu-id="10689-613"><u>Méthode nº 3 :</u> création d’entités d’index dans une table ou une partition séparée</span><span class="sxs-lookup"><span data-stu-id="10689-613"><u>Option #3:</u> Create index entities in a separate partition or table</span></span>  

<span data-ttu-id="10689-614">Pour cette troisième méthode, utilisez les entités d'index qui stockent les données suivantes :</span><span class="sxs-lookup"><span data-stu-id="10689-614">For the third option, use index entities that store the following data:</span></span>  

![][15]

<span data-ttu-id="10689-615">La propriété **EmployeeIDs** contient une liste des ID d’employés pour les employés portant le nom stocké dans la **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="10689-615">The **EmployeeIDs** property contains a list of employee ids for employees with the last name stored in the **RowKey**.</span></span>  

<span data-ttu-id="10689-616">Dans la troisième méthode, vous ne pouvez pas utiliser des EGT pour maintenir la cohérence, car les entités d'index sont dans une partition distincte des entités d'employé.</span><span class="sxs-lookup"><span data-stu-id="10689-616">With the third option, you cannot use EGTs to maintain consistency because the index entities are in a separate partition from the employee entities.</span></span> <span data-ttu-id="10689-617">Vous devez vérifier que les entités d'index sont cohérentes avec les entités d'employé.</span><span class="sxs-lookup"><span data-stu-id="10689-617">You should ensure that the index entities are eventually consistent with the employee entities.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="10689-618">Problèmes et considérations</span><span class="sxs-lookup"><span data-stu-id="10689-618">Issues and considerations</span></span>
<span data-ttu-id="10689-619">Prenez en compte les points suivants lorsque vous choisissez comment implémenter ce modèle :</span><span class="sxs-lookup"><span data-stu-id="10689-619">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="10689-620">Cette solution nécessite au moins deux requêtes pour récupérer des entités correspondantes : une pour interroger les entités d’index afin d’obtenir la liste des valeurs **RowKey** , puis des requêtes pour récupérer chaque entité dans la liste.</span><span class="sxs-lookup"><span data-stu-id="10689-620">This solution requires at least two queries to retrieve matching entities: one to query the index entities to obtain the list of **RowKey** values, and then queries to retrieve each entity in the list.</span></span>  
* <span data-ttu-id="10689-621">Étant donné qu'une entité a une taille maximale de 1 Mo, l'utilisation des méthodes #2 et #3 dans la solution supposent que la liste des ID d'employés pour n'importe quel nom donné n'est jamais supérieure à 1 Mo.</span><span class="sxs-lookup"><span data-stu-id="10689-621">Given that an individual entity has a maximum size of 1 MB, option #2 and option #3 in the solution assume that the list of employee ids for any given last name is never greater than 1 MB.</span></span> <span data-ttu-id="10689-622">Si la liste des ID d'employés est susceptible d'être supérieure à 1 Mo, utilisez la méthode #1 et stockez les données d'index dans le stockage d'objet blob.</span><span class="sxs-lookup"><span data-stu-id="10689-622">If the list of employee ids is likely to be greater than 1 MB in size, use option #1 and store the index data in blob storage.</span></span>  
* <span data-ttu-id="10689-623">Si vous utilisez l’option #2 (à l’aide des EGT pour gérer l’ajout et la suppression des employés et la modification du nom d’un employé), vous devez évaluer si le volume des transactions atteint les limites de l’évolutivité dans une partition donnée.</span><span class="sxs-lookup"><span data-stu-id="10689-623">If you use option #2 (using EGTs to handle adding and deleting employees, and changing an employee's last name) you must evaluate if the volume of transactions will approach the scalability limits in a given partition.</span></span> <span data-ttu-id="10689-624">Si c'est le cas, vous devez envisager une solution cohérente (méthode 1# ou #3) qui utilisera des files d'attente pour gérer les demandes de mise à jour et vous permettra de stocker vos entités d'index dans une partition distincte à partir des entités d'employés.</span><span class="sxs-lookup"><span data-stu-id="10689-624">If this is the case, you should consider an eventually consistent solution (option #1 or option #3) that uses queues to handle the update requests and enables you to store your index entities in a separate partition from the employee entities.</span></span>  
* <span data-ttu-id="10689-625">La méthode #2 de cette solution part du principe que vous souhaitez effectuer une recherche par nom de famille dans un service : par exemple, si vous souhaitez récupérer une liste des employés avec un nom de famille Jones dans le service des ventes.</span><span class="sxs-lookup"><span data-stu-id="10689-625">Option #2 in this solution assumes that you want to look up by last name within a department: for example, you want to retrieve a list of employees with a last name Jones in the Sales department.</span></span> <span data-ttu-id="10689-626">Si vous souhaitez être en mesure de rechercher dans toute l'organisation tous les employés portant le nom de famille Jones, suivez la méthode # 1 ou # 3.</span><span class="sxs-lookup"><span data-stu-id="10689-626">If you want to be able to look up all the employees with a last name Jones across the whole organization, use either option #1 or option #3.</span></span>
* <span data-ttu-id="10689-627">Vous pouvez implémenter une solution basée sur la file d’attente qui assure la cohérence éventuelle (pour plus d’informations, voir le [modèle de transactions cohérentes](#eventually-consistent-transactions-pattern) ).</span><span class="sxs-lookup"><span data-stu-id="10689-627">You can implement a queue-based solution that delivers eventual consistency (see the [Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) for more details).</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="10689-628">Quand utiliser ce modèle</span><span class="sxs-lookup"><span data-stu-id="10689-628">When to use this pattern</span></span>
<span data-ttu-id="10689-629">Utilisez ce modèle lorsque vous souhaitez rechercher un jeu d'entités qui partagent toutes une valeur de propriété courante, comme l'ensemble des employés dont le nom de famille est Jones.</span><span class="sxs-lookup"><span data-stu-id="10689-629">Use this pattern when you want to lookup a set of entities that all share a common property value, such as all employees with the last name Jones.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="10689-630">Conseils et modèles connexes</span><span class="sxs-lookup"><span data-stu-id="10689-630">Related patterns and guidance</span></span>
<span data-ttu-id="10689-631">Les modèles et les conseils suivants peuvent également être pertinents lors de l'implémentation de ce modèle :</span><span class="sxs-lookup"><span data-stu-id="10689-631">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="10689-632">Modèle de clé composée</span><span class="sxs-lookup"><span data-stu-id="10689-632">Compound key pattern</span></span>](#compound-key-pattern)  
* [<span data-ttu-id="10689-633">Modèle de transactions cohérentes</span><span class="sxs-lookup"><span data-stu-id="10689-633">Eventually consistent transactions pattern</span></span>](#eventually-consistent-transactions-pattern)  
* [<span data-ttu-id="10689-634">Transactions de groupe d’entités</span><span class="sxs-lookup"><span data-stu-id="10689-634">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="10689-635">Utilisation des types d’entités hétérogènes</span><span class="sxs-lookup"><span data-stu-id="10689-635">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)  

### <a name="denormalization-pattern"></a><span data-ttu-id="10689-636">Modèle de dénormalisation</span><span class="sxs-lookup"><span data-stu-id="10689-636">Denormalization pattern</span></span>
<span data-ttu-id="10689-637">Combinez des données connexes dans une entité unique pour pouvoir récupérer toutes les données dont vous avez besoin avec une seule requête de pointage.</span><span class="sxs-lookup"><span data-stu-id="10689-637">Combine related data together in a single entity to enable you to retrieve all the data you need with a single point query.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="10689-638">Contexte et problème</span><span class="sxs-lookup"><span data-stu-id="10689-638">Context and problem</span></span>
<span data-ttu-id="10689-639">Dans une base de données relationnelle, vous normalisez généralement des données pour supprimer des doublons résultant des requêtes qui extraient des données provenant de plusieurs tables.</span><span class="sxs-lookup"><span data-stu-id="10689-639">In a relational database, you typically normalize data to remove duplication resulting in queries that retrieve data from multiple tables.</span></span> <span data-ttu-id="10689-640">Si vous normalisez des données dans les tables Azure, vous devez effectuer plusieurs allers-retours à partir du client vers le serveur pour récupérer des données associées.</span><span class="sxs-lookup"><span data-stu-id="10689-640">If you normalize your data in Azure tables, you must make multiple round trips from the client to the server to retrieve your related data.</span></span> <span data-ttu-id="10689-641">Par exemple, avec la structure de table indiquée ci-dessous, vous devez effectuer deux opérations complètes pour récupérer les détails d’un service : une pour extraire l’entité de service qui inclut l’ID du responsable, puis une autre pour extraire les détails du responsable dans une entité d’employé.</span><span class="sxs-lookup"><span data-stu-id="10689-641">For example, with the table structure shown below you need two round trips to retrieve the details for a department: one to fetch the department entity that includes the manager's id, and then another request to fetch the manager's details in an employee entity.</span></span>  

![][16]

#### <a name="solution"></a><span data-ttu-id="10689-642">Solution</span><span class="sxs-lookup"><span data-stu-id="10689-642">Solution</span></span>
<span data-ttu-id="10689-643">Au lieu de stocker les données dans les deux entités distinctes, dénormalisez les données et conservez une copie des détails du responsable dans l’entité du service.</span><span class="sxs-lookup"><span data-stu-id="10689-643">Instead of storing the data in two separate entities, denormalize the data and keep a copy of the manager's details in the department entity.</span></span> <span data-ttu-id="10689-644">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="10689-644">For example:</span></span>  

![][17]

<span data-ttu-id="10689-645">Une fois les entités de service stockées avec ces propriétés, vous pouvez récupérer toutes les informations nécessaires sur un service à l'aide d'une requête de pointage.</span><span class="sxs-lookup"><span data-stu-id="10689-645">With department entities stored with these properties, you can now retrieve all the details you need about a department using a point query.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="10689-646">Problèmes et considérations</span><span class="sxs-lookup"><span data-stu-id="10689-646">Issues and considerations</span></span>
<span data-ttu-id="10689-647">Prenez en compte les points suivants lorsque vous choisissez comment implémenter ce modèle :</span><span class="sxs-lookup"><span data-stu-id="10689-647">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="10689-648">Des coûts réels sont associés au stockage des données à deux reprises.</span><span class="sxs-lookup"><span data-stu-id="10689-648">There is some cost overhead associated with storing some data twice.</span></span> <span data-ttu-id="10689-649">Les bénéfices de performance (résultant d'une diminution des demandes relatives au service Azure Storage) dépassent généralement l'augmentation mineure des coûts de stockage (et ce coût est partiellement compensé par une réduction du nombre de transactions dont vous avez besoin pour extraire les détails au service).</span><span class="sxs-lookup"><span data-stu-id="10689-649">The performance benefit (resulting from fewer requests to the storage service) typically outweighs the marginal increase in storage costs (and this cost is partially offset by a reduction in the number of transactions you require to fetch the details of a department).</span></span>  
* <span data-ttu-id="10689-650">Vous devez conserver la cohérence des deux entités qui stockent des informations sur les responsables.</span><span class="sxs-lookup"><span data-stu-id="10689-650">You must maintain the consistency of the two entities that store information about managers.</span></span> <span data-ttu-id="10689-651">Vous pouvez gérer le problème de cohérence à l'aide des EGT pour mettre à jour plusieurs entités dans une transaction atomique unique : dans ce cas, l'entité du service et celle de l'employé pour le responsable du service sont stockées dans la même partition.</span><span class="sxs-lookup"><span data-stu-id="10689-651">You can handle the consistency issue by using EGTs to update multiple entities in a single atomic transaction: in this case, the department entity, and the employee entity for the department manager are stored in the same partition.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="10689-652">Quand utiliser ce modèle</span><span class="sxs-lookup"><span data-stu-id="10689-652">When to use this pattern</span></span>
<span data-ttu-id="10689-653">Utilisez ce modèle lorsque vous devez fréquemment rechercher des informations connexes.</span><span class="sxs-lookup"><span data-stu-id="10689-653">Use this pattern when you frequently need to look up related information.</span></span> <span data-ttu-id="10689-654">Ce modèle réduit le nombre de requêtes que votre client doit effectuer pour récupérer les données requises.</span><span class="sxs-lookup"><span data-stu-id="10689-654">This pattern reduces the number of queries your client must make to retrieve the data it requires.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="10689-655">Conseils et modèles connexes</span><span class="sxs-lookup"><span data-stu-id="10689-655">Related patterns and guidance</span></span>
<span data-ttu-id="10689-656">Les modèles et les conseils suivants peuvent également être pertinents lors de l'implémentation de ce modèle :</span><span class="sxs-lookup"><span data-stu-id="10689-656">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="10689-657">Modèle de clé composée</span><span class="sxs-lookup"><span data-stu-id="10689-657">Compound key pattern</span></span>](#compound-key-pattern)  
* [<span data-ttu-id="10689-658">Transactions de groupe d’entités</span><span class="sxs-lookup"><span data-stu-id="10689-658">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="10689-659">Utilisation des types d’entités hétérogènes</span><span class="sxs-lookup"><span data-stu-id="10689-659">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)

### <a name="compound-key-pattern"></a><span data-ttu-id="10689-660">Modèle de clé composée</span><span class="sxs-lookup"><span data-stu-id="10689-660">Compound key pattern</span></span>
<span data-ttu-id="10689-661">Utilisez les valeurs de **RowKey** composée pour permettre à un client de rechercher des données associées en utilisant une seule requête de pointage.</span><span class="sxs-lookup"><span data-stu-id="10689-661">Use compound **RowKey** values to enable a client to lookup related data with a single point query.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="10689-662">Contexte et problème</span><span class="sxs-lookup"><span data-stu-id="10689-662">Context and problem</span></span>
<span data-ttu-id="10689-663">Dans une base de données relationnelle, il est naturel d'utiliser des jointures dans les requêtes pour renvoyer les ensembles de données au client dans une seule requête.</span><span class="sxs-lookup"><span data-stu-id="10689-663">In a relational database, it is quite natural to use joins in queries to return related pieces of data to the client in a single query.</span></span> <span data-ttu-id="10689-664">Par exemple, vous pouvez utiliser l'ID d'employé pour rechercher une liste d'entités associées qui contiennent des données sur les performances et les évaluations de cet employé.</span><span class="sxs-lookup"><span data-stu-id="10689-664">For example, you might use the employee id to look up a list of related entities that contain performance and review data for that employee.</span></span>  

<span data-ttu-id="10689-665">Supposons que vous stockiez des entités relatives aux employés dans le service de Table à l'aide de la structure suivante :</span><span class="sxs-lookup"><span data-stu-id="10689-665">Assume you are storing employee entities in the Table service using the following structure:</span></span>  

![][18]

<span data-ttu-id="10689-666">Vous devez également stocker les données historiques relatives aux évaluations et aux performances de chaque année durant laquelle l'employé a travaillé pour votre organisation, et vous devez être en mesure d'accéder à ces informations par année.</span><span class="sxs-lookup"><span data-stu-id="10689-666">You also need to store historical data relating to reviews and performance for each year the employee has worked for your organization and you need to be able to access this information by year.</span></span> <span data-ttu-id="10689-667">Une option consiste à créer une autre table qui stocke les entités avec la structure suivante :</span><span class="sxs-lookup"><span data-stu-id="10689-667">One option is to create another table that stores entities with the following structure:</span></span>  

![][19]

<span data-ttu-id="10689-668">Notez que, avec cette approche, vous pouvez décider de dupliquer certaines informations (telles que le prénom et le nom) dans la nouvelle entité afin de pouvoir récupérer vos données avec une requête unique.</span><span class="sxs-lookup"><span data-stu-id="10689-668">Notice that with this approach you may decide to duplicate some information (such as first name and last name) in the new entity to enable you to retrieve your data with a single request.</span></span> <span data-ttu-id="10689-669">Cependant, vous ne pouvez pas conserver une cohérence forte, car vous ne pouvez pas utiliser une EGT pour mettre à jour les deux entités de manière atomique.</span><span class="sxs-lookup"><span data-stu-id="10689-669">However, you cannot maintain strong consistency because you cannot use an EGT to update the two entities atomically.</span></span>  

#### <a name="solution"></a><span data-ttu-id="10689-670">Solution</span><span class="sxs-lookup"><span data-stu-id="10689-670">Solution</span></span>
<span data-ttu-id="10689-671">Stockez un nouveau type d'entité dans votre table d'origine à l'aide d'entités structurées comme suit :</span><span class="sxs-lookup"><span data-stu-id="10689-671">Store a new entity type in your original table using entities with the following structure:</span></span>  

![][20]

<span data-ttu-id="10689-672">Notez que la **RowKey** est à présent une clé composée, basée sur l’ID de l’employé et l’année des données d’évaluation, ce qui vous permet de récupérer les données de performances et d’évaluation de l’employé avec une seule demande pour une seule entité.</span><span class="sxs-lookup"><span data-stu-id="10689-672">Notice how the **RowKey** is now a compound key made up of the employee id and the year of the review data that enables you to retrieve the employee's performance and review data with a single request for a single entity.</span></span>  

<span data-ttu-id="10689-673">L'exemple suivant indique comment vous pouvez récupérer toutes les données d'évaluation d'un employé donné (par exemple, l'employé 000123 du service des ventes) :</span><span class="sxs-lookup"><span data-stu-id="10689-673">The following example outlines how you can retrieve all the review data for a particular employee (such as employee 000123 in the Sales department):</span></span>  

<span data-ttu-id="10689-674">$filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000123') and (RowKey lt 'empid_000124')&$select=RowKey,Manager Rating,Peer Rating,Comments</span><span class="sxs-lookup"><span data-stu-id="10689-674">$filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000123') and (RowKey lt 'empid_000124')&$select=RowKey,Manager Rating,Peer Rating,Comments</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="10689-675">Problèmes et considérations</span><span class="sxs-lookup"><span data-stu-id="10689-675">Issues and considerations</span></span>
<span data-ttu-id="10689-676">Prenez en compte les points suivants lorsque vous choisissez comment implémenter ce modèle :</span><span class="sxs-lookup"><span data-stu-id="10689-676">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="10689-677">Vous devez utiliser un caractère de séparation approprié pour faciliter l’analyse des valeurs de **RowKey** : par exemple, **000123_2012**.</span><span class="sxs-lookup"><span data-stu-id="10689-677">You should use a suitable separator character that makes it easy to parse the **RowKey** value: for example, **000123_2012**.</span></span>  
* <span data-ttu-id="10689-678">Vous stockez également cette entité dans la même partition que les autres entités qui contiennent des données associées au même employé, ce qui signifie que vous pouvez utiliser des EGT pour maintenir une forte cohérence.</span><span class="sxs-lookup"><span data-stu-id="10689-678">You are also storing this entity in the same partition as other entities that contain related data for the same employee, which means you can use EGTs to maintain strong consistency.</span></span>
* <span data-ttu-id="10689-679">Vous devez prendre en compte la fréquence à laquelle vous interrogez les données afin de déterminer si ce modèle est approprié.</span><span class="sxs-lookup"><span data-stu-id="10689-679">You should consider how frequently you will query the data to determine whether this pattern is appropriate.</span></span>  <span data-ttu-id="10689-680">Par exemple, si vous accédez rarement aux données d'évaluation et souvent aux données principales de l'employé, vous devez les conserver en entités distinctes.</span><span class="sxs-lookup"><span data-stu-id="10689-680">For example, if you will access the review data infrequently and the main employee data often you should keep them as separate entities.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="10689-681">Quand utiliser ce modèle</span><span class="sxs-lookup"><span data-stu-id="10689-681">When to use this pattern</span></span>
<span data-ttu-id="10689-682">Utilisez ce modèle lorsque vous devez stocker une ou plusieurs entités connexes que vous interrogez fréquemment.</span><span class="sxs-lookup"><span data-stu-id="10689-682">Use this pattern when you need to store one or more related entities that you query frequently.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="10689-683">Conseils et modèles connexes</span><span class="sxs-lookup"><span data-stu-id="10689-683">Related patterns and guidance</span></span>
<span data-ttu-id="10689-684">Les modèles et les conseils suivants peuvent également être pertinents lors de l'implémentation de ce modèle :</span><span class="sxs-lookup"><span data-stu-id="10689-684">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="10689-685">Transactions de groupe d’entités</span><span class="sxs-lookup"><span data-stu-id="10689-685">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="10689-686">Utilisation des types d’entités hétérogènes</span><span class="sxs-lookup"><span data-stu-id="10689-686">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)  
* [<span data-ttu-id="10689-687">Modèle de transactions cohérentes</span><span class="sxs-lookup"><span data-stu-id="10689-687">Eventually consistent transactions pattern</span></span>](#eventually-consistent-transactions-pattern)  

### <a name="log-tail-pattern"></a><span data-ttu-id="10689-688">Modèle de fin de journal</span><span class="sxs-lookup"><span data-stu-id="10689-688">Log tail pattern</span></span>
<span data-ttu-id="10689-689">Récupérez les entités *n* récemment ajoutées à une partition en utilisant une valeur de **RowKey** qui effectue un tri dans l’ordre inverse de la date et de l’heure.</span><span class="sxs-lookup"><span data-stu-id="10689-689">Retrieve the *n* entities most recently added to a partition by using a **RowKey** value that sorts in reverse date and time order.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="10689-690">Contexte et problème</span><span class="sxs-lookup"><span data-stu-id="10689-690">Context and problem</span></span>
<span data-ttu-id="10689-691">Une exigence courante est de pouvoir récupérer les entités plus récemment créées, par exemple les dix dernières dépenses revendications soumises par un employé.</span><span class="sxs-lookup"><span data-stu-id="10689-691">A common requirement is be able to retrieve the most recently created entities, for example the ten most recent expense claims submitted by an employee.</span></span> <span data-ttu-id="10689-692">Les requêtes de table prennent en charge une opération de requête **$top** pour retourner les premières *n* entités en provenance d’un ensemble. Il n’existe aucune opération de requête équivalente pour retourner les n dernières entités d’un ensemble.</span><span class="sxs-lookup"><span data-stu-id="10689-692">Table queries support a **$top** query operation to return the first *n* entities from a set: there is no equivalent query operation to return the last n entities in a set.</span></span>  

#### <a name="solution"></a><span data-ttu-id="10689-693">Solution</span><span class="sxs-lookup"><span data-stu-id="10689-693">Solution</span></span>
<span data-ttu-id="10689-694">Stockez les entités en utilisant une **RowKey** qui trie naturellement l’ordre inverse de date et d’heure par utilisation, pour que l’entrée la plus récente soit toujours la première dans la table.</span><span class="sxs-lookup"><span data-stu-id="10689-694">Store the entities using a **RowKey** that naturally sorts in reverse date/time order by using so the most recent entry is always the first one in the table.</span></span>  

<span data-ttu-id="10689-695">Par exemple, pour être en mesure de récupérer les dix notes de frais les plus récentes soumises par un employé, vous pouvez utiliser une valeur de graduation inverse dérivée de l'heure actuelle.</span><span class="sxs-lookup"><span data-stu-id="10689-695">For example, to be able to retrieve the ten most recent expense claims submitted by an employee, you can use a reverse tick value derived from the current date/time.</span></span> <span data-ttu-id="10689-696">L’exemple de code C# suivant montre une méthode de création d’une valeur de « graduation inverse » adéquate pour une **RowKey** qui procède à un tri du plus récent au plus ancien :</span><span class="sxs-lookup"><span data-stu-id="10689-696">The following C# code sample shows one way to create a suitable "inverted ticks" value for a **RowKey** that sorts from the most recent to the oldest:</span></span>  

`string invertedTicks = string.Format("{0:D19}", DateTime.MaxValue.Ticks - DateTime.UtcNow.Ticks);`  

<span data-ttu-id="10689-697">Vous pouvez récupérer la valeur de date-heure en utilisant le code suivant :</span><span class="sxs-lookup"><span data-stu-id="10689-697">You can get back to the date time value using the following code:</span></span>  

`DateTime dt = new DateTime(DateTime.MaxValue.Ticks - Int64.Parse(invertedTicks));`  

<span data-ttu-id="10689-698">La requête de table ressemble à ceci :</span><span class="sxs-lookup"><span data-stu-id="10689-698">The table query looks like this:</span></span>  

`https://myaccount.table.core.windows.net/EmployeeExpense(PartitionKey='empid')?$top=10`  

#### <a name="issues-and-considerations"></a><span data-ttu-id="10689-699">Problèmes et considérations</span><span class="sxs-lookup"><span data-stu-id="10689-699">Issues and considerations</span></span>
<span data-ttu-id="10689-700">Prenez en compte les points suivants lorsque vous choisissez comment implémenter ce modèle :</span><span class="sxs-lookup"><span data-stu-id="10689-700">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="10689-701">Vous devez faire précéder la valeur de graduation inverse par des zéros non significatifs pour garantir que la valeur de chaîne trie comme prévu.</span><span class="sxs-lookup"><span data-stu-id="10689-701">You must pad the reverse tick value with leading zeroes to ensure the string value sorts as expected.</span></span>  
* <span data-ttu-id="10689-702">Vous devez être conscient des objectifs d'évolutivité au niveau d'une partition.</span><span class="sxs-lookup"><span data-stu-id="10689-702">You must be aware of the scalability targets at the level of a partition.</span></span> <span data-ttu-id="10689-703">Veillez à ne pas créer des partitions de zone sensible.</span><span class="sxs-lookup"><span data-stu-id="10689-703">Be careful not create hot spot partitions.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="10689-704">Quand utiliser ce modèle</span><span class="sxs-lookup"><span data-stu-id="10689-704">When to use this pattern</span></span>
<span data-ttu-id="10689-705">Utilisez ce modèle lorsque vous avez besoin d'accéder aux entités dans l'ordre inverse de date-heure ou lorsque vous devez accéder aux entités ajoutées récemment.</span><span class="sxs-lookup"><span data-stu-id="10689-705">Use this pattern when you need to access entities in reverse date/time order or when you need to access the most recently added entities.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="10689-706">Conseils et modèles connexes</span><span class="sxs-lookup"><span data-stu-id="10689-706">Related patterns and guidance</span></span>
<span data-ttu-id="10689-707">Les modèles et les conseils suivants peuvent également être pertinents lors de l'implémentation de ce modèle :</span><span class="sxs-lookup"><span data-stu-id="10689-707">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="10689-708">Ajouter un anti-modèle ou un préfixe d’anti-modèle</span><span class="sxs-lookup"><span data-stu-id="10689-708">Prepend / append anti-pattern</span></span>](#prepend-append-anti-pattern)  
* [<span data-ttu-id="10689-709">Récupération des entités</span><span class="sxs-lookup"><span data-stu-id="10689-709">Retrieving entities</span></span>](#retrieving-entities)  

### <a name="high-volume-delete-pattern"></a><span data-ttu-id="10689-710">Modèle de suppression de volume élevé</span><span class="sxs-lookup"><span data-stu-id="10689-710">High volume delete pattern</span></span>
<span data-ttu-id="10689-711">Activez la suppression d'un volume élevé d'entités en stockant toutes les entités pour les supprimer simultanément dans leur propre table distincte ; vous supprimez les entités en supprimant la table.</span><span class="sxs-lookup"><span data-stu-id="10689-711">Enable the deletion of a high volume of entities by storing all the entities for simultaneous deletion in their own separate table; you delete the entities by deleting the table.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="10689-712">Contexte et problème</span><span class="sxs-lookup"><span data-stu-id="10689-712">Context and problem</span></span>
<span data-ttu-id="10689-713">De nombreuses applications suppriment les anciennes données qui n'ont plus besoin d'être disponibles pour une application cliente ou archivées par l'application sur un autre support de stockage.</span><span class="sxs-lookup"><span data-stu-id="10689-713">Many applications delete old data which no longer needs to be available to a client application, or that the application has archived to another storage medium.</span></span> <span data-ttu-id="10689-714">Vous identifiez généralement ces données à une date : par exemple, vous devez supprimer les enregistrements de toutes les demandes de connexion datant de plus de 60 jours.</span><span class="sxs-lookup"><span data-stu-id="10689-714">You typically identify such data by a date: for example, you have a requirement to delete records of all login requests that are more than 60 days old.</span></span>  

<span data-ttu-id="10689-715">Une conception possible consiste à utiliser la date et l’heure de la demande de connexion dans la **RowKey**:</span><span class="sxs-lookup"><span data-stu-id="10689-715">One possible design is to use the date and time of the login request in the **RowKey**:</span></span>  

![][21]

<span data-ttu-id="10689-716">Cette approche évite les zones sensibles de partition, car l'application peut insérer et supprimer des entités de connexion pour chaque utilisateur dans une partition séparée.</span><span class="sxs-lookup"><span data-stu-id="10689-716">This approach avoids partition hotspots because the application can insert and delete login entities for each user in a separate partition.</span></span> <span data-ttu-id="10689-717">Toutefois, cette approche peut être coûteuse et fastidieuse si vous avez beaucoup d'entités, car vous devez d'abord analyser la table pour identifier toutes les entités à supprimer, avant de supprimer chaque ancienne entité.</span><span class="sxs-lookup"><span data-stu-id="10689-717">However, this approach may be costly and time consuming if you have a large number of entities because first you need to perform a table scan in order to identify all the entities to delete, and then you must delete each old entity.</span></span> <span data-ttu-id="10689-718">Notez que vous pouvez réduire le nombre d'allers-retours vers le serveur requis pour supprimer les anciennes entités en traitant par lots plusieurs demandes de suppression dans les TGE.</span><span class="sxs-lookup"><span data-stu-id="10689-718">Note that you can reduce the number of round trips to the server required to delete the old entities by batching multiple delete requests into EGTs.</span></span>  

#### <a name="solution"></a><span data-ttu-id="10689-719">Solution</span><span class="sxs-lookup"><span data-stu-id="10689-719">Solution</span></span>
<span data-ttu-id="10689-720">Utilisez une table distincte pour chaque jour de tentative de connexion.</span><span class="sxs-lookup"><span data-stu-id="10689-720">Use a separate table for each day of login attempts.</span></span> <span data-ttu-id="10689-721">Vous pouvez utiliser la conception de l'entité ci-dessus afin d'éviter les zones sensibles lorsque vous insérez des entités et la suppression des anciennes entités consiste désormais à simplement supprimer une table tous les jours (une seule opération de stockage) au lieu de rechercher et de supprimer des centaines de milliers d'entités de connexion individuelle chaque jour.</span><span class="sxs-lookup"><span data-stu-id="10689-721">You can use the entity design above to avoid hotspots when you are inserting entities, and deleting old entities is now simply a question of deleting one table every day (a single storage operation) instead of finding and deleting hundreds and thousands of individual login entities every day.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="10689-722">Problèmes et considérations</span><span class="sxs-lookup"><span data-stu-id="10689-722">Issues and considerations</span></span>
<span data-ttu-id="10689-723">Prenez en compte les points suivants lorsque vous choisissez comment implémenter ce modèle :</span><span class="sxs-lookup"><span data-stu-id="10689-723">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="10689-724">Votre conception prend-elle en charge les autres méthodes de traitement des données que votre application va utiliser, telles que la recherche des entités spécifiques, les liaisons avec d'autres données ou la génération des informations d'agrégation ?</span><span class="sxs-lookup"><span data-stu-id="10689-724">Does your design support other ways your application will use the data such as looking up specific entities, linking with other data, or generating aggregate information?</span></span>  
* <span data-ttu-id="10689-725">Votre conception évite-t-elle les zones sensibles lorsque vous insérez de nouvelles entités ?</span><span class="sxs-lookup"><span data-stu-id="10689-725">Does your design avoid hot spots when you are inserting new entities?</span></span>  
* <span data-ttu-id="10689-726">Vous devez attendre un délai si vous voulez réutiliser le même nom de table après l'avoir supprimée.</span><span class="sxs-lookup"><span data-stu-id="10689-726">Expect a delay if you want to reuse the same table name after deleting it.</span></span> <span data-ttu-id="10689-727">Il est préférable de toujours utiliser des noms de table uniques.</span><span class="sxs-lookup"><span data-stu-id="10689-727">It's better to always use unique table names.</span></span>  
* <span data-ttu-id="10689-728">Prévoyez une limitation lorsque vous utiliserez tout d'abord une table pendant que le service de Table assimile les modèles d'accès et distribue les partitions entre les nœuds.</span><span class="sxs-lookup"><span data-stu-id="10689-728">Expect some throttling when you first use a new table while the Table service learns the access patterns and distributes the partitions across nodes.</span></span> <span data-ttu-id="10689-729">Vous devez réfléchir à la fréquence à laquelle vous devez créer des tables.</span><span class="sxs-lookup"><span data-stu-id="10689-729">You should consider how frequently you need to create new tables.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="10689-730">Quand utiliser ce modèle</span><span class="sxs-lookup"><span data-stu-id="10689-730">When to use this pattern</span></span>
<span data-ttu-id="10689-731">Utilisez ce modèle lorsque vous avez un volume élevé d'entités, que vous devez supprimer en même temps.</span><span class="sxs-lookup"><span data-stu-id="10689-731">Use this pattern when you have a high volume of entities that you must delete at the same time.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="10689-732">Conseils et modèles connexes</span><span class="sxs-lookup"><span data-stu-id="10689-732">Related patterns and guidance</span></span>
<span data-ttu-id="10689-733">Les modèles et les conseils suivants peuvent également être pertinents lors de l'implémentation de ce modèle :</span><span class="sxs-lookup"><span data-stu-id="10689-733">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="10689-734">Transactions de groupe d’entités</span><span class="sxs-lookup"><span data-stu-id="10689-734">Entity Group Transactions</span></span>](#entity-group-transactions)
* [<span data-ttu-id="10689-735">Modification des entités</span><span class="sxs-lookup"><span data-stu-id="10689-735">Modifying entities</span></span>](#modifying-entities)  

### <a name="data-series-pattern"></a><span data-ttu-id="10689-736">Modèle de série de données</span><span class="sxs-lookup"><span data-stu-id="10689-736">Data series pattern</span></span>
<span data-ttu-id="10689-737">Stockez des séries de données complètes dans une entité unique pour réduire votre nombre de demandes.</span><span class="sxs-lookup"><span data-stu-id="10689-737">Store complete data series in a single entity to minimize the number of requests you make.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="10689-738">Contexte et problème</span><span class="sxs-lookup"><span data-stu-id="10689-738">Context and problem</span></span>
<span data-ttu-id="10689-739">Il arrive qu'une application stocke une série de données qu'elle doit fréquemment récupérer en une seule fois :</span><span class="sxs-lookup"><span data-stu-id="10689-739">A common scenario is for an application to store a series of data that it typically needs to retrieve all at once.</span></span> <span data-ttu-id="10689-740">Par exemple, votre application peut enregistrer combien de messages de messagerie instantanée chaque employé envoie toutes les heures, puis utiliser ces informations pour tracer le nombre de messages envoyés par chaque utilisateur dans les 24 heures précédentes.</span><span class="sxs-lookup"><span data-stu-id="10689-740">For example, your application might record how many IM messages each employee sends every hour, and then use this information to plot how many messages each user sent over the preceding 24 hours.</span></span> <span data-ttu-id="10689-741">Une conception peut consister à stocker 24 entités pour chaque employé :</span><span class="sxs-lookup"><span data-stu-id="10689-741">One design might be to store 24 entities for each employee:</span></span>  

![][22]

<span data-ttu-id="10689-742">Grâce à cette conception, vous pouvez facilement rechercher et mettre à jour l'entité mise à jour pour chaque employé chaque fois que l'application doit mettre à jour la valeur de nombre de messages.</span><span class="sxs-lookup"><span data-stu-id="10689-742">With this design, you can easily locate and update the entity to update for each employee whenever the application needs to update the message count value.</span></span> <span data-ttu-id="10689-743">Cependant, pour récupérer les informations pour tracer un graphique de l'activité des 24 heures précédentes, vous devez récupérer les 24 entités.</span><span class="sxs-lookup"><span data-stu-id="10689-743">However, to retrieve the information to plot a chart of the activity for the preceding 24 hours, you must retrieve 24 entities.</span></span>  

#### <a name="solution"></a><span data-ttu-id="10689-744">Solution</span><span class="sxs-lookup"><span data-stu-id="10689-744">Solution</span></span>
<span data-ttu-id="10689-745">Utilisez la conception suivante avec une propriété distincte pour stocker le nombre de messages pour chaque heure :</span><span class="sxs-lookup"><span data-stu-id="10689-745">Use the following design with a separate property to store the message count for each hour:</span></span>  

![][23]

<span data-ttu-id="10689-746">Grâce à cette conception, vous pouvez utiliser une opération de fusion pour mettre à jour le nombre de messages pour un employé pour une heure spécifique.</span><span class="sxs-lookup"><span data-stu-id="10689-746">With this design, you can use a merge operation to update the message count for an employee for a specific hour.</span></span> <span data-ttu-id="10689-747">À présent, vous pouvez récupérer toutes les informations dont vous avez besoin pour tracer le graphique à l'aide d'une requête pour une seule entité.</span><span class="sxs-lookup"><span data-stu-id="10689-747">Now, you can retrieve all the information you need to plot the chart using a request for a single entity.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="10689-748">Problèmes et considérations</span><span class="sxs-lookup"><span data-stu-id="10689-748">Issues and considerations</span></span>
<span data-ttu-id="10689-749">Prenez en compte les points suivants lorsque vous choisissez comment implémenter ce modèle :</span><span class="sxs-lookup"><span data-stu-id="10689-749">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="10689-750">Si votre série de données complète ne tient pas dans une seule entité (une entité peut avoir jusqu'à 252 propriétés), utilisez un autre magasin de données, comme un objet blob.</span><span class="sxs-lookup"><span data-stu-id="10689-750">If your complete data series does not fit into a single entity (an entity can have up to 252 properties), use an alternative data store such as a blob.</span></span>  
* <span data-ttu-id="10689-751">Si vous avez plusieurs clients qui mettent à jour une entité simultanément, vous devez utiliser le **ETag** pour implémenter l’accès concurrentiel optimiste.</span><span class="sxs-lookup"><span data-stu-id="10689-751">If you have multiple clients updating an entity simultaneously, you will need to use the **ETag** to implement optimistic concurrency.</span></span> <span data-ttu-id="10689-752">Si vous avez de nombreux clients, vous pouvez rencontrer une contention élevée.</span><span class="sxs-lookup"><span data-stu-id="10689-752">If you have many clients, you may experience high contention.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="10689-753">Quand utiliser ce modèle</span><span class="sxs-lookup"><span data-stu-id="10689-753">When to use this pattern</span></span>
<span data-ttu-id="10689-754">Utilisez ce modèle lorsque vous devez mettre à jour et récupérer une série de données associée à une entité individuelle.</span><span class="sxs-lookup"><span data-stu-id="10689-754">Use this pattern when you need to update and retrieve a data series associated with an individual entity.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="10689-755">Conseils et modèles connexes</span><span class="sxs-lookup"><span data-stu-id="10689-755">Related patterns and guidance</span></span>
<span data-ttu-id="10689-756">Les modèles et les conseils suivants peuvent également être pertinents lors de l'implémentation de ce modèle :</span><span class="sxs-lookup"><span data-stu-id="10689-756">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="10689-757">Modèle d'entités volumineuses</span><span class="sxs-lookup"><span data-stu-id="10689-757">Large entities pattern</span></span>](#large-entities-pattern)  
* [<span data-ttu-id="10689-758">Fusion ou remplacement</span><span class="sxs-lookup"><span data-stu-id="10689-758">Merge or replace</span></span>](#merge-or-replace)  
* <span data-ttu-id="10689-759">[Modèle de transactions cohérentes](#eventually-consistent-transactions-pattern) (si vous stockez la série de données dans un objet blob)</span><span class="sxs-lookup"><span data-stu-id="10689-759">[Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) (if you are storing the data series in a blob)</span></span>  

### <a name="wide-entities-pattern"></a><span data-ttu-id="10689-760">Modèle d’entités larges</span><span class="sxs-lookup"><span data-stu-id="10689-760">Wide entities pattern</span></span>
<span data-ttu-id="10689-761">Utilisez plusieurs entités physiques pour stocker des entités logiques ayant plus de 252 propriétés.</span><span class="sxs-lookup"><span data-stu-id="10689-761">Use multiple physical entities to store logical entities with more than 252 properties.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="10689-762">Contexte et problème</span><span class="sxs-lookup"><span data-stu-id="10689-762">Context and problem</span></span>
<span data-ttu-id="10689-763">Une entité individuelle ne peut pas avoir plus de 252 propriétés (à l'exception des propriétés système obligatoires) et ne peut pas stocker plus de 1 Mo de données au total.</span><span class="sxs-lookup"><span data-stu-id="10689-763">An individual entity can have no more than 252 properties (excluding the mandatory system properties) and cannot store more than 1 MB of data in total.</span></span> <span data-ttu-id="10689-764">Dans une base de données relationnelle, vous allez généralement arrondir les limites de taille d'une ligne en ajoutant une nouvelle table et en appliquant une relation 1 à 1 entre elles.</span><span class="sxs-lookup"><span data-stu-id="10689-764">In a relational database, you would typically get round any limits on the size of a row by adding a new table and enforcing a 1-to-1 relationship between them.</span></span>  

#### <a name="solution"></a><span data-ttu-id="10689-765">Solution</span><span class="sxs-lookup"><span data-stu-id="10689-765">Solution</span></span>
<span data-ttu-id="10689-766">À l'aide du service de Table, vous pouvez stocker plusieurs entités pour représenter un objet métier volumineux unique ayant plus de 252 propriétés.</span><span class="sxs-lookup"><span data-stu-id="10689-766">Using the Table service, you can store multiple entities to represent a single large business object with more than 252 properties.</span></span> <span data-ttu-id="10689-767">Par exemple, si vous souhaitez stocker le nombre de messages instantanés envoyés par chaque employé durant les 365 derniers jours, vous pouvez utiliser la conception suivante qui utilise deux entités avec des schémas différents :</span><span class="sxs-lookup"><span data-stu-id="10689-767">For example, if you want to store a count of the number of IM messages sent by each employee for the last 365 days, you could use the following design that uses two entities with different schemas:</span></span>  

![][24]

<span data-ttu-id="10689-768">Si vous souhaitez apporter une modification qui nécessite la mise à jour des deux entités pour les garder mutuellement synchronisées, vous pouvez utiliser une EGT.</span><span class="sxs-lookup"><span data-stu-id="10689-768">If you need to make a change that requires updating both entities to keep them synchronized with each other you can use an EGT.</span></span> <span data-ttu-id="10689-769">Sinon, vous pouvez utiliser une opération de fusion pour mettre à jour le nombre de messages pour un jour spécifique.</span><span class="sxs-lookup"><span data-stu-id="10689-769">Otherwise, you can use a single merge operation to update the message count for a specific day.</span></span> <span data-ttu-id="10689-770">Pour récupérer toutes les données pour un employé individuel, vous devez récupérer les deux entités. Pour ce faire, utilisez deux demandes efficaces qui utilisent toutes deux une valeur de **PartitionKey** et de **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="10689-770">To retrieve all the data for an individual employee you must retrieve both entities, which you can do with two efficient requests that use both a **PartitionKey** and a **RowKey** value.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="10689-771">Problèmes et considérations</span><span class="sxs-lookup"><span data-stu-id="10689-771">Issues and considerations</span></span>
<span data-ttu-id="10689-772">Prenez en compte les points suivants lorsque vous choisissez comment implémenter ce modèle :</span><span class="sxs-lookup"><span data-stu-id="10689-772">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="10689-773">La récupération d'une entité logique complète implique au moins deux transactions de stockage : une pour récupérer chaque entité physique.</span><span class="sxs-lookup"><span data-stu-id="10689-773">Retrieving a complete logical entity involves at least two storage transactions: one to retrieve each physical entity.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="10689-774">Quand utiliser ce modèle</span><span class="sxs-lookup"><span data-stu-id="10689-774">When to use this pattern</span></span>
<span data-ttu-id="10689-775">Utilisez ce modèle lorsque vous avez besoin de stocker des entités dont la taille ou le nombre de propriétés dépassent les limites d'une entité individuelle dans le service de Table.</span><span class="sxs-lookup"><span data-stu-id="10689-775">Use this pattern when  need to store entities whose size or number of properties exceeds the limits for an individual entity in the Table service.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="10689-776">Conseils et modèles connexes</span><span class="sxs-lookup"><span data-stu-id="10689-776">Related patterns and guidance</span></span>
<span data-ttu-id="10689-777">Les modèles et les conseils suivants peuvent également être pertinents lors de l'implémentation de ce modèle :</span><span class="sxs-lookup"><span data-stu-id="10689-777">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="10689-778">Transactions de groupe d’entités</span><span class="sxs-lookup"><span data-stu-id="10689-778">Entity Group Transactions</span></span>](#entity-group-transactions)
* [<span data-ttu-id="10689-779">Fusion ou remplacement</span><span class="sxs-lookup"><span data-stu-id="10689-779">Merge or replace</span></span>](#merge-or-replace)

### <a name="large-entities-pattern"></a><span data-ttu-id="10689-780">Modèle d’entités volumineuses</span><span class="sxs-lookup"><span data-stu-id="10689-780">Large entities pattern</span></span>
<span data-ttu-id="10689-781">Utilisez le stockage d'objets blob pour stocker des valeurs de propriétés volumineuses.</span><span class="sxs-lookup"><span data-stu-id="10689-781">Use blob storage to store large property values.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="10689-782">Contexte et problème</span><span class="sxs-lookup"><span data-stu-id="10689-782">Context and problem</span></span>
<span data-ttu-id="10689-783">Une entité individuelle ne peut pas stocker plus de 1 Mo de données au total.</span><span class="sxs-lookup"><span data-stu-id="10689-783">An individual entity cannot store more than 1 MB of data in total.</span></span> <span data-ttu-id="10689-784">Si une ou plusieurs des propriétés stockent des valeurs qui provoquent un dépassement de la taille totale de votre entité, vous ne pouvez pas stocker l'intégralité de l'entité sur le service de Table.</span><span class="sxs-lookup"><span data-stu-id="10689-784">If one or several of your properties store values that cause the total size of your entity to exceed this value, you cannot store the entire entity in the Table service.</span></span>  

#### <a name="solution"></a><span data-ttu-id="10689-785">Solution</span><span class="sxs-lookup"><span data-stu-id="10689-785">Solution</span></span>
<span data-ttu-id="10689-786">Si votre entité dépasse 1 Mo, car une ou plusieurs propriétés contiennent une grande quantité de données, vous pouvez stocker des données dans le service BLOB et stocker ensuite l'adresse de l'objet blob dans une propriété de l'entité.</span><span class="sxs-lookup"><span data-stu-id="10689-786">If your entity exceeds 1 MB in size because one or more properties contain a large amount of data, you can store data in the Blob service and then store the address of the blob in a property in the entity.</span></span> <span data-ttu-id="10689-787">Par exemple, vous pouvez stocker la photo d’un employé dans le stockage d’objets blob et stocker un lien vers la photo dans la propriété **Photo** de votre entité d’employé :</span><span class="sxs-lookup"><span data-stu-id="10689-787">For example, you can store the photo of an employee in blob storage and store a link to the photo in the **Photo** property of your employee entity:</span></span>  

![][25]

#### <a name="issues-and-considerations"></a><span data-ttu-id="10689-788">Problèmes et considérations</span><span class="sxs-lookup"><span data-stu-id="10689-788">Issues and considerations</span></span>
<span data-ttu-id="10689-789">Prenez en compte les points suivants lorsque vous choisissez comment implémenter ce modèle :</span><span class="sxs-lookup"><span data-stu-id="10689-789">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="10689-790">Pour maintenir la cohérence entre l’entité du service de Table et les données du service BLOB, utilisez le [modèle de transactions cohérentes](#eventually-consistent-transactions-pattern) pour maintenir vos entités.</span><span class="sxs-lookup"><span data-stu-id="10689-790">To maintain eventual consistency between the entity in the Table service and the data in the Blob service, use the [Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) to maintain your entities.</span></span>
* <span data-ttu-id="10689-791">La récupération d'une entité complète implique au moins deux transactions de stockage : une pour récupérer l'entité et l'autre pour récupérer les données blob.</span><span class="sxs-lookup"><span data-stu-id="10689-791">Retrieving a complete entity involves at least two storage transactions: one to retrieve the entity and one to retrieve the blob data.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="10689-792">Quand utiliser ce modèle</span><span class="sxs-lookup"><span data-stu-id="10689-792">When to use this pattern</span></span>
<span data-ttu-id="10689-793">Utilisez ce modèle lorsque vous avez besoin de stocker des entités dont la taille dépasse les limites d'une entité individuelle dans le service de Table.</span><span class="sxs-lookup"><span data-stu-id="10689-793">Use this pattern when you need to store entities whose size exceeds the limits for an individual entity in the Table service.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="10689-794">Conseils et modèles connexes</span><span class="sxs-lookup"><span data-stu-id="10689-794">Related patterns and guidance</span></span>
<span data-ttu-id="10689-795">Les modèles et les conseils suivants peuvent également être pertinents lors de l'implémentation de ce modèle :</span><span class="sxs-lookup"><span data-stu-id="10689-795">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="10689-796">Modèle de transactions cohérentes</span><span class="sxs-lookup"><span data-stu-id="10689-796">Eventually consistent transactions pattern</span></span>](#eventually-consistent-transactions-pattern)  
* [<span data-ttu-id="10689-797">Modèle d’entités larges</span><span class="sxs-lookup"><span data-stu-id="10689-797">Wide entities pattern</span></span>](#wide-entities-pattern)

<a name="prepend-append-anti-pattern"></a>

### <a name="prependappend-anti-pattern"></a><span data-ttu-id="10689-798">Ajouter un anti-modèle ou un préfixe d'anti-modèle</span><span class="sxs-lookup"><span data-stu-id="10689-798">Prepend/append anti-pattern</span></span>
<span data-ttu-id="10689-799">Augmentez l'évolutivité lorsque vous avez un volume élevé d'insertions en répartissant les insertions sur plusieurs partitions.</span><span class="sxs-lookup"><span data-stu-id="10689-799">Increase scalability when you have a high volume of inserts by spreading the inserts across multiple partitions.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="10689-800">Contexte et problème</span><span class="sxs-lookup"><span data-stu-id="10689-800">Context and problem</span></span>
<span data-ttu-id="10689-801">L'ajout d'entité ou de suffixe d'entité à vos entités stockées pousse généralement l'application à ajouter de nouvelles entités à la première ou à la dernière partition d'une séquence.</span><span class="sxs-lookup"><span data-stu-id="10689-801">Prepending or appending entities to your stored entities typically results in the application adding new entities to the first or last partition of a sequence of partitions.</span></span> <span data-ttu-id="10689-802">Dans ce cas, toutes les insertions à tout moment ont lieu dans la même partition, créant une zone sensible qui empêche le service de Table d'équilibrer la charge sur plusieurs nœuds et éventuellement de pousser votre application à atteindre les objectifs d'évolutivité pour la partition.</span><span class="sxs-lookup"><span data-stu-id="10689-802">In this case, all of the inserts at any given time are taking place in the same partition, creating a hotspot that prevents the table service from load balancing inserts across multiple nodes, and possibly causing your application to hit the scalability targets for partition.</span></span> <span data-ttu-id="10689-803">Par exemple, si vous avez une application qui journalise l’accès au réseau et aux ressources des employés, une structure d’entité semblable à celle affichée ci-dessous peut transformer la partition de l’heure actuelle en zone sensible si le volume des transactions atteint l’objectif d’évolutivité pour une partition individuelle :</span><span class="sxs-lookup"><span data-stu-id="10689-803">For example, if you have an application that logs network and resource access by employees, then an entity structure as shown below could result in the current hour's partition becoming a hotspot if the volume of transactions reaches the scalability target for an individual partition:</span></span>  

![][26]

#### <a name="solution"></a><span data-ttu-id="10689-804">Solution</span><span class="sxs-lookup"><span data-stu-id="10689-804">Solution</span></span>
<span data-ttu-id="10689-805">La structure d'entité alternative suivante permet d'éviter une zone sensible dans n'importe quelle partition particulière tandis que l'application journalise les événements :</span><span class="sxs-lookup"><span data-stu-id="10689-805">The following alternative entity structure avoids a hotspot on any particular partition as the application logs events:</span></span>  

![][27]

<span data-ttu-id="10689-806">Dans cet exemple, notez que **PartitionKey** et **RowKey** sont toutes deux des clés composées.</span><span class="sxs-lookup"><span data-stu-id="10689-806">Notice with this example how both the **PartitionKey** and **RowKey** are compound keys.</span></span> <span data-ttu-id="10689-807">La **PartitionKey** utilise les ID de service et d’employé pour distribuer la journalisation sur plusieurs partitions.</span><span class="sxs-lookup"><span data-stu-id="10689-807">The **PartitionKey** uses both the department and employee id to distribute the logging across multiple partitions.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="10689-808">Problèmes et considérations</span><span class="sxs-lookup"><span data-stu-id="10689-808">Issues and considerations</span></span>
<span data-ttu-id="10689-809">Prenez en compte les points suivants lorsque vous choisissez comment implémenter ce modèle :</span><span class="sxs-lookup"><span data-stu-id="10689-809">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="10689-810">La structure clé alternative qui évite de créer efficacement des partitions sensibles sur des insertions prend-elle en charge efficacement les requêtes effectuées par votre application cliente ?</span><span class="sxs-lookup"><span data-stu-id="10689-810">Does the alternative key structure that avoids creating hot partitions on inserts efficiently support the queries your client application makes?</span></span>  
* <span data-ttu-id="10689-811">Le volume prévu de transactions signifie-t-il que vous êtes susceptible d'atteindre les objectifs d'évolutivité pour une partition individuelle et d'être limité par le service de stockage ?</span><span class="sxs-lookup"><span data-stu-id="10689-811">Does your anticipated volume of transactions mean that you are likely to reach the scalability targets for an individual partition and be throttled by the storage service?</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="10689-812">Quand utiliser ce modèle</span><span class="sxs-lookup"><span data-stu-id="10689-812">When to use this pattern</span></span>
<span data-ttu-id="10689-813">Évitez l'ajout d'anti-modèle ou de suffixe d'anti-modèle lorsque votre volume de transactions est susceptible d'entraîner la limitation par le service de stockage lorsque vous accédez à une partition sensible.</span><span class="sxs-lookup"><span data-stu-id="10689-813">Avoid the prepend/append anti-pattern when your volume of transactions is likely to result in throttling by the storage service when you access a hot partition.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="10689-814">Conseils et modèles connexes</span><span class="sxs-lookup"><span data-stu-id="10689-814">Related patterns and guidance</span></span>
<span data-ttu-id="10689-815">Les modèles et les conseils suivants peuvent également être pertinents lors de l'implémentation de ce modèle :</span><span class="sxs-lookup"><span data-stu-id="10689-815">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="10689-816">Modèle de clé composée</span><span class="sxs-lookup"><span data-stu-id="10689-816">Compound key pattern</span></span>](#compound-key-pattern)  
* [<span data-ttu-id="10689-817">Modèle de fin de journal</span><span class="sxs-lookup"><span data-stu-id="10689-817">Log tail pattern</span></span>](#log-tail-pattern)  
* [<span data-ttu-id="10689-818">Modification des entités</span><span class="sxs-lookup"><span data-stu-id="10689-818">Modifying entities</span></span>](#modifying-entities)  

### <a name="log-data-anti-pattern"></a><span data-ttu-id="10689-819">Journalisation de l'anti-modèle de données</span><span class="sxs-lookup"><span data-stu-id="10689-819">Log data anti-pattern</span></span>
<span data-ttu-id="10689-820">En règle générale, vous devez utiliser le service BLOB plutôt que le service de Table pour stocker les données du journal.</span><span class="sxs-lookup"><span data-stu-id="10689-820">Typically, you should use the Blob service instead of the Table service to store log data.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="10689-821">Contexte et problème</span><span class="sxs-lookup"><span data-stu-id="10689-821">Context and problem</span></span>
<span data-ttu-id="10689-822">Un cas d'utilisation courante des données de journal consiste à récupérer une sélection d'entrées de journal pour une plage de date/heure spécifique : par exemple, vous souhaitez rechercher tous les messages d'erreur et critiques enregistrés par votre application entre 15h04 et 15h06 à une date spécifique.</span><span class="sxs-lookup"><span data-stu-id="10689-822">A common use case for log data is to retrieve a selection of log entries for a specific date/time range: for example, you want to find all the error and critical messages that your application logged between 15:04 and 15:06 on a specific date.</span></span> <span data-ttu-id="10689-823">Vous ne souhaitez pas utiliser la date et l’heure du message de journalisation pour déterminer la partition sur laquelle vous enregistrez les entités de journalisation : cela entraîne une partition sensible, car à n’importe quel moment, toutes les entités de journalisation partageront la même valeur de **PartitionKey** (consultez la section [Ajouter un anti-modèle ou un préfixe d’anti-modèle](#prepend-append-anti-pattern)).</span><span class="sxs-lookup"><span data-stu-id="10689-823">You do not want to use the date and time of the log message to determine the partition you save log entities to: that results in a hot partition because at any given time, all the log entities will share the same **PartitionKey** value (see the section [Prepend/append anti-pattern](#prepend-append-anti-pattern)).</span></span> <span data-ttu-id="10689-824">Par exemple, le schéma d'entité suivant d'un message de journalisation génère une partition sensible, car l'application écrit tous les messages de journalisation sur la partition pour la date et l'heure actuelles :</span><span class="sxs-lookup"><span data-stu-id="10689-824">For example, the following entity schema for a log message results in a hot partition because the application writes all log messages to the partition for the current date and hour:</span></span>  

![][28]

<span data-ttu-id="10689-825">Dans cet exemple, la valeur de **RowKey** inclut la date et l’heure du message de journalisation pour vous assurer que les messages de journalisation sont stockés et triés dans l’ordre de date/heure et incluent un ID de message au cas où plusieurs messages de journalisation partagent les mêmes date et heure.</span><span class="sxs-lookup"><span data-stu-id="10689-825">In this example, the **RowKey** includes the date and time of the log message to ensure that log messages are stored sorted in date/time order, and includes a message id in case multiple log messages share the same date and time.</span></span>  

<span data-ttu-id="10689-826">Une autre approche consiste à utiliser une valeur de **PartitionKey** qui garantit que l’application écrit des messages dans une plage de partitions.</span><span class="sxs-lookup"><span data-stu-id="10689-826">Another approach is to use a **PartitionKey** that ensures that the application writes messages across a range of partitions.</span></span> <span data-ttu-id="10689-827">Par exemple, si la source du message de journalisation fournit un moyen de distribuer les messages sur plusieurs partitions, vous pouvez utiliser le schéma de l'entité suivante :</span><span class="sxs-lookup"><span data-stu-id="10689-827">For example, if the source of the log message provides a way to distribute messages across many partitions, you could use the following entity schema:</span></span>  

![][29]

<span data-ttu-id="10689-828">Toutefois, le problème avec ce schéma est que, pour récupérer tous les messages de journalisation pour un intervalle de temps spécifique, vous devez rechercher chaque partition dans la table.</span><span class="sxs-lookup"><span data-stu-id="10689-828">However, the problem with this schema is that to retrieve all the log messages for a specific time span you must search every partition in the table.</span></span>

#### <a name="solution"></a><span data-ttu-id="10689-829">Solution</span><span class="sxs-lookup"><span data-stu-id="10689-829">Solution</span></span>
<span data-ttu-id="10689-830">La section précédente a présenté le problème posé par la tentative d'utilisation du service de Table pour stocker des entrées de journalisation et a suggéré deux conceptions, peu satisfaisantes.</span><span class="sxs-lookup"><span data-stu-id="10689-830">The previous section highlighted the problem of trying to use the Table service to store log entries and suggested two, unsatisfactory, designs.</span></span> <span data-ttu-id="10689-831">Une solution a conduit à une partition sensible, avec le risque de faibles performances d'écriture de messages de journalisation ; l'autre solution a entraîné des performances médiocres, en raison de la nécessité d'analyser chaque partition dans la table pour récupérer les messages du journal pour une période spécifique.</span><span class="sxs-lookup"><span data-stu-id="10689-831">One solution led to a hot partition with the risk of poor performance writing log messages; the other solution resulted in poor query performance because of the requirement to scan every partition in the table to retrieve log messages for a specific time span.</span></span> <span data-ttu-id="10689-832">Le stockage d'objets blob offre une meilleure solution pour ce type de scénario. Voici comment Azure Storage Analytics stocke les données de journalisation collectées.</span><span class="sxs-lookup"><span data-stu-id="10689-832">Blob storage offers a better solution for this type of scenario and this is how Azure Storage Analytics stores the log data it collects.</span></span>  

<span data-ttu-id="10689-833">Cette section décrit comment Storage Analytics stocke les données de journalisation dans le stockage d'objets blob, en guise d'illustration de cette approche pour le stockage des données que vous interrogez généralement par plage.</span><span class="sxs-lookup"><span data-stu-id="10689-833">This section outlines how Storage Analytics stores log data in blob storage as an illustration of this approach to storing data that you typically query by range.</span></span>  

<span data-ttu-id="10689-834">Storage Analytics stocke les messages de journalisation dans un format délimité dans plusieurs objets blob.</span><span class="sxs-lookup"><span data-stu-id="10689-834">Storage Analytics stores log messages in a delimited format in multiple blobs.</span></span> <span data-ttu-id="10689-835">Ce format facilite l'analyse des données du message de journalisation pour une application cliente.</span><span class="sxs-lookup"><span data-stu-id="10689-835">The delimited format makes it easy for a client application to parse the data in the log message.</span></span>  

<span data-ttu-id="10689-836">Storage Analytics utilise une convention d'affectation des noms d'objets blob qui vous permet de localiser le ou les objets blob contenant les messages de journalisation que vous recherchez.</span><span class="sxs-lookup"><span data-stu-id="10689-836">Storage Analytics uses a naming convention for blobs that enables you to locate the blob (or blobs) that contain the log messages for which you are searching.</span></span> <span data-ttu-id="10689-837">Par exemple, un objet blob nommé « queue/2014/07/31/1800/000001.log » contient des messages de journalisation liés au service de File d'attente dont l'heure de début est à 18h00, le 31 juillet 2014.</span><span class="sxs-lookup"><span data-stu-id="10689-837">For example, a blob named "queue/2014/07/31/1800/000001.log" contains log messages that relate to the queue service for the hour starting at 18:00 on 31 July 2014.</span></span> <span data-ttu-id="10689-838">Le « 000001 » indique qu'il s'agit du premier fichier journal pour cette période.</span><span class="sxs-lookup"><span data-stu-id="10689-838">The "000001" indicates that this is the first log file for this period.</span></span> <span data-ttu-id="10689-839">Storage Analytics enregistre également les horodatages du premier et du dernier messages stockés dans le fichier dans le cadre des métadonnées de l’objet blob.</span><span class="sxs-lookup"><span data-stu-id="10689-839">Storage Analytics also records the timestamps of the first and last log messages stored in the file as part of the blob's metadata.</span></span> <span data-ttu-id="10689-840">L'API pour le stockage d'objets blob vous permet de rechercher des objets blob dans un conteneur selon un préfixe de nom : pour rechercher tous les objets blob qui contiennent des données de journalisation des files d'attente correspondant à l'heure de début de 18h00, vous pouvez utiliser le préfixe « queue/2014/07/31/1800 ».</span><span class="sxs-lookup"><span data-stu-id="10689-840">The API for blob storage enables you locate blobs in a container based on a name prefix: to locate all the blobs that contain queue log data for the hour starting at 18:00, you can use the prefix "queue/2014/07/31/1800."</span></span>  

<span data-ttu-id="10689-841">Storage Analytics met en mémoire tampon les messages de journalisation en interne, puis met à jour de façon périodique l'objet blob adéquat ou en crée un autre avec le dernier lot d'entrées de journalisation.</span><span class="sxs-lookup"><span data-stu-id="10689-841">Storage Analytics buffers log messages internally and then periodically updates the appropriate blob or creates a new one with the latest batch of log entries.</span></span> <span data-ttu-id="10689-842">Cela réduit le nombre d'écritures qu'il doit exécuter vers le service BLOB.</span><span class="sxs-lookup"><span data-stu-id="10689-842">This reduces the number of writes it must perform to the blob service.</span></span>  

<span data-ttu-id="10689-843">Si vous implémentez une solution similaire dans votre propre application, vous devez déterminer comment gérer le compromis entre la fiabilité (écrire chaque entrée de journalisation pour le stockage d'objets blob comme cela est le cas) et le coût, ainsi que l'évolutivité (mise en mémoire tampon des mises à jour dans votre application et écriture du stockage d'objet blob par lots).</span><span class="sxs-lookup"><span data-stu-id="10689-843">If you are implementing a similar solution in your own application, you must consider how to manage the trade-off between reliability (writing every log entry to blob storage as it happens) and cost and scalability (buffering updates in your application and writing them to blob storage in batches).</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="10689-844">Problèmes et considérations</span><span class="sxs-lookup"><span data-stu-id="10689-844">Issues and considerations</span></span>
<span data-ttu-id="10689-845">Prenez en compte les points suivants lorsque vous décidez de la manière de stocker des données de journalisation :</span><span class="sxs-lookup"><span data-stu-id="10689-845">Consider the following points when deciding how to store log data:</span></span>  

* <span data-ttu-id="10689-846">Si vous créez une conception de table qui évite les partitions sensibles potentielles, il est possible que l'accès aux données de journalisation ne soit pas très efficace.</span><span class="sxs-lookup"><span data-stu-id="10689-846">If you create a table design that avoids potential hot partitions, you may find that you cannot access your log data efficiently.</span></span>  
* <span data-ttu-id="10689-847">Pour traiter les données de journalisation, un client doit souvent charger de nombreux enregistrements.</span><span class="sxs-lookup"><span data-stu-id="10689-847">To process log data, a client often needs to load many records.</span></span>  
* <span data-ttu-id="10689-848">Bien que les données de journalisation soient souvent structurées, le stockage d'objets blob peut être une meilleure solution.</span><span class="sxs-lookup"><span data-stu-id="10689-848">Although log data is often structured, blob storage may be a better solution.</span></span>  

### <a name="implementation-considerations"></a><span data-ttu-id="10689-849">Considérations relatives à l'implémentation</span><span class="sxs-lookup"><span data-stu-id="10689-849">Implementation considerations</span></span>
<span data-ttu-id="10689-850">Cette section décrit certaines des considérations à prendre en compte lorsque vous implémentez les modèles décrits dans les sections précédentes.</span><span class="sxs-lookup"><span data-stu-id="10689-850">This section discusses some of the considerations to bear in mind when you implement the patterns described in the previous sections.</span></span> <span data-ttu-id="10689-851">La plupart de cette section utilise des exemples rédigés en C#, ainsi que la bibliothèque cliente de stockage (version 4.3.0 au moment de la rédaction).</span><span class="sxs-lookup"><span data-stu-id="10689-851">Most of this section uses examples written in C# that use the Storage Client Library (version 4.3.0 at the time of writing).</span></span>  

### <a name="retrieving-entities"></a><span data-ttu-id="10689-852">Récupération des entités</span><span class="sxs-lookup"><span data-stu-id="10689-852">Retrieving entities</span></span>
<span data-ttu-id="10689-853">Comme indiqué dans la section [Conception pour l’interrogation](#design-for-querying), la requête la plus efficace est une requête de pointage.</span><span class="sxs-lookup"><span data-stu-id="10689-853">As discussed in the section [Design for querying](#design-for-querying), the most efficient query is a point query.</span></span> <span data-ttu-id="10689-854">Toutefois, dans certains scénarios, vous devrez peut-être récupérer plusieurs entités.</span><span class="sxs-lookup"><span data-stu-id="10689-854">However, in some scenarios you may need to retrieve multiple entities.</span></span> <span data-ttu-id="10689-855">Cette section décrit certaines des approches courantes pour récupérer des entités à l'aide de la bibliothèque cliente de stockage.</span><span class="sxs-lookup"><span data-stu-id="10689-855">This section describes some common approaches to retrieving entities using the Storage Client Library.</span></span>  

#### <a name="executing-a-point-query-using-the-storage-client-library"></a><span data-ttu-id="10689-856">Exécution d'une requête de pointage à l'aide de la bibliothèque cliente de stockage</span><span class="sxs-lookup"><span data-stu-id="10689-856">Executing a point query using the Storage Client Library</span></span>
<span data-ttu-id="10689-857">La méthode la plus simple pour exécuter une requête de pointage consiste à utiliser l’opération de table **Retrieve** (récupération), comme indiqué dans l’extrait de code C# suivant, qui récupère une entité avec une **PartitionKey** dont la valeur est « Sales » et une **RowKey** dont la valeur est « 212 » :</span><span class="sxs-lookup"><span data-stu-id="10689-857">The easiest way to execute a point query is to use the **Retrieve** table operation as shown in the following C# code snippet that retrieves an entity with a **PartitionKey** of value "Sales" and a **RowKey** of value "212":</span></span>  

```csharp
TableOperation retrieveOperation = TableOperation.Retrieve<EmployeeEntity>("Sales", "212");
var retrieveResult = employeeTable.Execute(retrieveOperation);
if (retrieveResult.Result != null)
{
    EmployeeEntity employee = (EmployeeEntity)retrieveResult.Result;
    ...
}  
```

<span data-ttu-id="10689-858">Notez que cet exemple part du principe que l’entité extraite doit être de type **EmployeeEntity**.</span><span class="sxs-lookup"><span data-stu-id="10689-858">Notice how this example expects the entity it retrieves to be of type **EmployeeEntity**.</span></span>  

#### <a name="retrieving-multiple-entities-using-linq"></a><span data-ttu-id="10689-859">Récupération de plusieurs entités à l’aide de LINQ</span><span class="sxs-lookup"><span data-stu-id="10689-859">Retrieving multiple entities using LINQ</span></span>
<span data-ttu-id="10689-860">Vous pouvez extraire plusieurs entités à l’aide de LINQ avec la bibliothèque cliente de stockage et en spécifiant une requête avec une clause **where** .</span><span class="sxs-lookup"><span data-stu-id="10689-860">You can retrieve multiple entities by using LINQ with Storage Client Library and specifying a query with a **where** clause.</span></span> <span data-ttu-id="10689-861">Pour éviter une analyse de table, vous devez toujours inclure la valeur de **PartitionKey** dans la clause where, et si possible la valeur de **RowKey** afin d’éviter les analyses de table et de partition.</span><span class="sxs-lookup"><span data-stu-id="10689-861">To avoid a table scan, you should always include the **PartitionKey** value in the where clause, and if possible the **RowKey** value to avoid table and partition scans.</span></span> <span data-ttu-id="10689-862">Le service de Table prend en charge un ensemble limité d'opérateurs de comparaison (greater than, greater than or equal, less than or equal, equal et not equal) (supérieur à, supérieure ou égal à, inférieur ou égal à, égal et différent de).</span><span class="sxs-lookup"><span data-stu-id="10689-862">The table service supports a limited set of comparison operators (greater than, greater than or equal, less than, less than or equal, equal, and not equal) to use in the where clause.</span></span> <span data-ttu-id="10689-863">L’extrait de code C# suivant recherche tous les employés dont le nom commence par « B » (en supposant que la **RowKey** stocke le nom de famille) dans le service des ventes (en supposant que la **PartitionKey** stocke le nom du service) :</span><span class="sxs-lookup"><span data-stu-id="10689-863">The following C# code snippet finds all the employees whose last name starts with "B" (assuming that the **RowKey** stores the last name) in the sales department (assuming the **PartitionKey** stores the department name):</span></span>  

```csharp
TableQuery<EmployeeEntity> employeeQuery = employeeTable.CreateQuery<EmployeeEntity>();
var query = (from employee in employeeQuery
            where employee.PartitionKey == "Sales" &&
            employee.RowKey.CompareTo("B") >= 0 &&
            employee.RowKey.CompareTo("C") < 0
            select employee).AsTableQuery();
var employees = query.Execute();  
```

<span data-ttu-id="10689-864">Notez comment la requête spécifie à la fois une **RowKey** et une **PartitionKey** pour garantir des performances optimales.</span><span class="sxs-lookup"><span data-stu-id="10689-864">Notice how the query specifies both a **RowKey** and a **PartitionKey** to ensure better performance.</span></span>  

<span data-ttu-id="10689-865">L’exemple de code suivant montre une fonctionnalité équivalente faisant appel à l’API Fluent (pour plus d’informations sur cette API, consultez [Meilleures pratiques pour la conception d’une API Fluent](http://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx)) :</span><span class="sxs-lookup"><span data-stu-id="10689-865">The following code sample shows equivalent functionality using the fluent API (for more information about fluent APIs in general, see [Best Practices for Designing a Fluent API](http://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx)):</span></span>  

```csharp
TableQuery<EmployeeEntity> employeeQuery = new TableQuery<EmployeeEntity>().Where(
    TableQuery.CombineFilters(
    TableQuery.CombineFilters(
        TableQuery.GenerateFilterCondition(
    "PartitionKey", QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.GenerateFilterCondition(
    "RowKey", QueryComparisons.GreaterThanOrEqual, "B")
),
TableOperators.And,
TableQuery.GenerateFilterCondition("RowKey", QueryComparisons.LessThan, "C")
    )
);
var employees = employeeTable.ExecuteQuery(employeeQuery);  
```

> [!NOTE]
> <span data-ttu-id="10689-866">L’exemple imbrique plusieurs méthodes **CombineFilters** pour inclure les trois conditions de filtre.</span><span class="sxs-lookup"><span data-stu-id="10689-866">The sample nests multiple **CombineFilters** methods to include the three filter conditions.</span></span>  
> 
> 

#### <a name="retrieving-large-numbers-of-entities-from-a-query"></a><span data-ttu-id="10689-867">Récupération d'un grand nombre d'entités à partir d'une requête</span><span class="sxs-lookup"><span data-stu-id="10689-867">Retrieving large numbers of entities from a query</span></span>
<span data-ttu-id="10689-868">Une requête optimale renvoie une entité individuelle basée sur une valeur de **PartitionKey** et une valeur de **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="10689-868">An optimal query returns an individual entity based on a **PartitionKey** value and a **RowKey** value.</span></span> <span data-ttu-id="10689-869">Toutefois, dans certains scénarios, vous pouvez être obligé de renvoyer de nombreuses entités à partir de la même partition ou même de plusieurs partitions.</span><span class="sxs-lookup"><span data-stu-id="10689-869">However, in some scenarios you may have a requirement to return many entities from the same partition or even from many partitions.</span></span>  

<span data-ttu-id="10689-870">Vous devez toujours tester entièrement les performances de votre application dans de tels scénarios.</span><span class="sxs-lookup"><span data-stu-id="10689-870">You should always fully test the performance of your application in such scenarios.</span></span>  

<span data-ttu-id="10689-871">Une requête sur le service de Table peut renvoyer un maximum de 1 000 entités à la fois et peut s'exécuter pendant un maximum de 5 secondes.</span><span class="sxs-lookup"><span data-stu-id="10689-871">A query against the table service may return a maximum of 1,000 entities at one time and may execute for a maximum of five seconds.</span></span> <span data-ttu-id="10689-872">Si l'ensemble des résultats contient plus de 1 000 entités, si la requête ne s'est pas terminée dans les 5 secondes ou si la requête dépasse la limite de la partition, le service de Table renvoie un jeton de liaison pour permettre à l'application cliente de demander l'ensemble d'entités suivant.</span><span class="sxs-lookup"><span data-stu-id="10689-872">If the result set contains more than 1,000 entities, if the query did not complete within five seconds, or if the query crosses the partition boundary, the Table service returns a continuation token to enable the client application to request the next set of entities.</span></span> <span data-ttu-id="10689-873">Pour plus d’informations sur la façon dont fonctionnent les jetons de continuation, consultez [Délai de requête et pagination](http://msdn.microsoft.com/library/azure/dd135718.aspx).</span><span class="sxs-lookup"><span data-stu-id="10689-873">For more information about how continuation tokens work, see [Query Timeout and Pagination](http://msdn.microsoft.com/library/azure/dd135718.aspx).</span></span>  

<span data-ttu-id="10689-874">Si vous utilisez la bibliothèque cliente de stockage, celle-ci peut gérer automatiquement les jetons de continuation pour vous en renvoyant des entités à partir du service de Table.</span><span class="sxs-lookup"><span data-stu-id="10689-874">If you are using the Storage Client Library, it can automatically handle continuation tokens for you as it returns entities from the Table service.</span></span> <span data-ttu-id="10689-875">L'exemple de code C# suivant utilise la bibliothèque cliente de stockage pour gérer automatiquement les jetons de continuation si le service de Table les renvoie dans une réponse :</span><span class="sxs-lookup"><span data-stu-id="10689-875">The following C# code sample using the Storage Client Library automatically handles continuation tokens if the table service returns them in a response:</span></span>  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

var employees = employeeTable.ExecuteQuery(employeeQuery);
foreach (var emp in employees)
{
        ...
}  
```

<span data-ttu-id="10689-876">Le code C# suivant gère les jetons de continuation de manière explicite :</span><span class="sxs-lookup"><span data-stu-id="10689-876">The following C# code handles continuation tokens explicitly:</span></span>  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

TableContinuationToken continuationToken = null;

do
{
        var employees = employeeTable.ExecuteQuerySegmented(
        employeeQuery, continuationToken);
    foreach (var emp in employees)
    {
    ...
    }
    continuationToken = employees.ContinuationToken;
} while (continuationToken != null);  
```

<span data-ttu-id="10689-877">En utilisant des jetons de continuation de manière explicite, vous pouvez contrôler le moment où votre application extrait le segment suivant des données.</span><span class="sxs-lookup"><span data-stu-id="10689-877">By using continuation tokens explicitly, you can control when your application retrieves the next segment of data.</span></span> <span data-ttu-id="10689-878">Par exemple, si votre application cliente permet aux utilisateurs de parcourir les entités stockées dans une table, un utilisateur peut décider de ne pas parcourir toutes les entités récupérées par la requête pour que votre application utilise uniquement un jeton de continuation pour extraire le segment suivant lorsque l'utilisateur a terminé la pagination via toutes les entités dans le segment actuel.</span><span class="sxs-lookup"><span data-stu-id="10689-878">For example, if your client application enables users to page through the entities stored in a table, a user may decide not to page through all the entities retrieved by the query so your application would only use a continuation token to retrieve the next segment when the user had finished paging through all the entities in the current segment.</span></span> <span data-ttu-id="10689-879">Cette approche présente plusieurs avantages :</span><span class="sxs-lookup"><span data-stu-id="10689-879">This approach has several benefits:</span></span>  

* <span data-ttu-id="10689-880">Elle vous permet de limiter la quantité de données à récupérer à partir du service de Table et que vous placez sur le réseau.</span><span class="sxs-lookup"><span data-stu-id="10689-880">It enables you to limit the amount of data to retrieve from the Table service and that you move over the network.</span></span>  
* <span data-ttu-id="10689-881">Elle vous permet d'effectuer des E/S asynchrones dans .NET.</span><span class="sxs-lookup"><span data-stu-id="10689-881">It enables you to perform asynchronous IO in .NET.</span></span>  
* <span data-ttu-id="10689-882">Elle vous permet de sérialiser le jeton de continuation dans un stockage permanent, pour que vous puissiez continuer même si l'application tombe en panne.</span><span class="sxs-lookup"><span data-stu-id="10689-882">It enables you to serialize the continuation token to persistent storage so you can continue in the event of an application crash.</span></span>  

> [!NOTE]
> <span data-ttu-id="10689-883">En général, un jeton de liaison retourne un segment contenant 1 000 entités, bien qu'il puisse y en avoir moins.</span><span class="sxs-lookup"><span data-stu-id="10689-883">A continuation token typically returns a segment containing 1,000 entities, although it may be fewer.</span></span> <span data-ttu-id="10689-884">C’est également le cas si vous limitez le nombre d’entrées qu’une requête renvoie à l’aide de l’instruction **Take** (prendre) pour renvoyer les n premières entités qui correspondent à vos critères de recherche : le service de table peut renvoyer un segment contenant moins de n entités avec un jeton de liaison pour vous permettre de récupérer les entités restantes.</span><span class="sxs-lookup"><span data-stu-id="10689-884">This is also the case if you limit the number of entries a query returns by using **Take** to return the first n entities that match your lookup criteria: the table service may return a segment containing fewer than n entities along with a continuation token to enable you to retrieve the remaining entities.</span></span>  
> 
> 

<span data-ttu-id="10689-885">Le code C# suivant montre comment modifier le nombre d'entités renvoyées à l'intérieur d'un segment :</span><span class="sxs-lookup"><span data-stu-id="10689-885">The following C# code shows how to modify the number of entities returned inside a segment:</span></span>  

```csharp
employeeQuery.TakeCount = 50;  
```

#### <a name="server-side-projection"></a><span data-ttu-id="10689-886">Projection côté serveur</span><span class="sxs-lookup"><span data-stu-id="10689-886">Server-side projection</span></span>
<span data-ttu-id="10689-887">Une seule entité peut avoir jusqu'à 255 propriétés et une taille allant jusqu'à 1 Mo.</span><span class="sxs-lookup"><span data-stu-id="10689-887">A single entity can have up to 255 properties and be up to 1 MB in size.</span></span> <span data-ttu-id="10689-888">Lorsque vous interrogez la table et récupérez des entités, il est possible que vous n'ayez pas besoin de toutes les propriétés et que vous puissiez éviter de transférer des données sans que cela soit nécessaire (ce qui permet de réduire la latence et les coûts).</span><span class="sxs-lookup"><span data-stu-id="10689-888">When you query the table and retrieve entities, you may not need all the properties and can avoid transferring data unnecessarily (to help reduce latency and cost).</span></span> <span data-ttu-id="10689-889">Vous pouvez utiliser la projection côté serveur pour transférer uniquement les propriétés que vous avez besoin.</span><span class="sxs-lookup"><span data-stu-id="10689-889">You can use server-side projection to transfer just the properties you need.</span></span> <span data-ttu-id="10689-890">L’exemple suivant extrait uniquement la propriété **Email** (avec les valeurs de **PartitionKey**, de **RowKey**, de **Timestamp** et d’**ETag**) à partir des entités sélectionnées par la requête.</span><span class="sxs-lookup"><span data-stu-id="10689-890">The following example is retrieves just the **Email** property (along with **PartitionKey**, **RowKey**, **Timestamp**, and **ETag**) from the entities selected by the query.</span></span>  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
List<string> columns = new List<string>() { "Email" };
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter).Select(columns);

var entities = employeeTable.ExecuteQuery(employeeQuery);
foreach (var e in entities)
{
        Console.WriteLine("RowKey: {0}, EmployeeEmail: {1}", e.RowKey, e.Email);
}  
```

<span data-ttu-id="10689-891">Notez comment la valeur de **RowKey** est disponible même si elle ne figurait pas dans la liste de propriétés à récupérer.</span><span class="sxs-lookup"><span data-stu-id="10689-891">Notice how the **RowKey** value is available even though it was not included in the list of properties to retrieve.</span></span>  

### <a name="modifying-entities"></a><span data-ttu-id="10689-892">Modification des entités</span><span class="sxs-lookup"><span data-stu-id="10689-892">Modifying entities</span></span>
<span data-ttu-id="10689-893">La bibliothèque cliente de stockage vous permet de modifier les entités stockées dans votre service de Table pour les insérer, les supprimer et les mettre à jour.</span><span class="sxs-lookup"><span data-stu-id="10689-893">The Storage Client Library enables you to modify your entities stored in the table service by inserting, deleting, and updating entities.</span></span> <span data-ttu-id="10689-894">Vous pouvez utiliser EGTs pour traiter par lot plusieurs opérations d'insertion, mise à jour et suppression afin de réduire le nombre d'allers-retours requis et améliorer les performances de votre solution.</span><span class="sxs-lookup"><span data-stu-id="10689-894">You can use EGTs to batch multiple insert, update, and delete operations together to reduce the number of round trips required and improve the performance of your solution.</span></span>  

<span data-ttu-id="10689-895">Notez que les exceptions levées lorsque la bibliothèque cliente de stockage exécute une EGT incluent généralement l'index de l'entité qui a provoqué l'échec du lot.</span><span class="sxs-lookup"><span data-stu-id="10689-895">Note that exceptions thrown when the Storage Client Library executes an EGT typically include the index of the entity that caused the batch to fail.</span></span> <span data-ttu-id="10689-896">Cela est utile lorsque vous déboguez du code qui utilise des EGT.</span><span class="sxs-lookup"><span data-stu-id="10689-896">This is helpful when you are debugging code that uses EGTs.</span></span>  

<span data-ttu-id="10689-897">Nous vous conseillons de réfléchir également à la façon dont votre conception affecte la méthode de votre application cliente pour gérer les opérations d'accès concurrentiel et de mises à jour.</span><span class="sxs-lookup"><span data-stu-id="10689-897">You should also consider how your design affects how your client application handles concurrency and update operations.</span></span>  

#### <a name="managing-concurrency"></a><span data-ttu-id="10689-898">Gérer l'accès concurrentiel</span><span class="sxs-lookup"><span data-stu-id="10689-898">Managing concurrency</span></span>
<span data-ttu-id="10689-899">Par défaut, le service de Table implémente des contrôles d’accès concurrentiel optimiste au niveau des entités individuelles pour les opérations **d’insertion** (Insert), de **fusion** (Merge) et de **suppression** (Delete), bien qu’il soit possible pour un client de forcer le service de Table à ignorer ces contrôles.</span><span class="sxs-lookup"><span data-stu-id="10689-899">By default, the table service implements optimistic concurrency checks at the level of individual entities for **Insert**, **Merge**, and **Delete** operations, although it is possible for a client to force the table service to bypass these checks.</span></span> <span data-ttu-id="10689-900">Pour plus d’informations sur la façon dont le service de Table gère l’accès concurrentiel, consultez [Gestion de l’accès concurrentiel dans Stockage Microsoft Azure](../storage/common/storage-concurrency.md).</span><span class="sxs-lookup"><span data-stu-id="10689-900">For more information about how the table service manages concurrency, see  [Managing Concurrency in Microsoft Azure Storage](../storage/common/storage-concurrency.md).</span></span>  

#### <a name="merge-or-replace"></a><span data-ttu-id="10689-901">Fusion ou remplacement</span><span class="sxs-lookup"><span data-stu-id="10689-901">Merge or replace</span></span>
<span data-ttu-id="10689-902">La méthode de **remplacement** (Replace) de la classe **TableOperation** remplace toujours l’entité complète du service de Table.</span><span class="sxs-lookup"><span data-stu-id="10689-902">The **Replace** method of the **TableOperation** class always replaces the complete entity in the Table service.</span></span> <span data-ttu-id="10689-903">Si vous n'incluez pas une propriété dans la demande lorsque cette propriété existe dans l'entité stockée, la demande supprime cette propriété de l'entité stockée.</span><span class="sxs-lookup"><span data-stu-id="10689-903">If you do not include a property in the request when that property exists in the stored entity, the request removes that property from the stored entity.</span></span> <span data-ttu-id="10689-904">Si vous ne souhaitez pas supprimer une propriété explicitement à partir d'une entité stockée, vous devez inclure chaque propriété dans la demande.</span><span class="sxs-lookup"><span data-stu-id="10689-904">Unless you want to remove a property explicitly from a stored entity, you must include every property in the request.</span></span>  

<span data-ttu-id="10689-905">Vous pouvez utiliser la méthode de **fusion** (Merge) de la classe **TableOperation** pour réduire la quantité de données que vous envoyez au service de Table quand vous souhaitez mettre à jour une entité.</span><span class="sxs-lookup"><span data-stu-id="10689-905">You can use the **Merge** method of the **TableOperation** class to reduce the amount of data that you send to the Table service when you want to update an entity.</span></span> <span data-ttu-id="10689-906">La méthode de **fusion** remplace toutes les propriétés de l’entité stockée par les valeurs de propriété de l’entité incluse dans la demande, mais ne modifie pas les propriétés de l’entité stockée qui ne sont pas incluses dans la demande.</span><span class="sxs-lookup"><span data-stu-id="10689-906">The **Merge** method replaces any properties in the stored entity with property values from the entity included in the request, but leaves intact any properties in the stored entity that are not included in the request.</span></span> <span data-ttu-id="10689-907">Cela est utile si vous avez des entités volumineuses et que vous avez seulement besoin de mettre à jour un petit nombre de propriétés dans une demande.</span><span class="sxs-lookup"><span data-stu-id="10689-907">This is useful if you have large entities and only need to update a small number of properties in a request.</span></span>  

> [!NOTE]
> <span data-ttu-id="10689-908">Les méthodes de **remplacement** et de **fusion** échouent si l’entité n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="10689-908">The **Replace** and **Merge** methods fail if the entity does not exist.</span></span> <span data-ttu-id="10689-909">Comme alternative, vous pouvez utiliser les méthodes **InsertOrReplace** et **InsertOrMerge** qui créent une entité si elle n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="10689-909">As an alternative, you can use the **InsertOrReplace** and **InsertOrMerge** methods that create a new entity if it doesn't exist.</span></span>  
> 
> 

### <a name="working-with-heterogeneous-entity-types"></a><span data-ttu-id="10689-910">Utilisation des types d’entités hétérogènes</span><span class="sxs-lookup"><span data-stu-id="10689-910">Working with heterogeneous entity types</span></span>
<span data-ttu-id="10689-911">Le service de Table est un magasin de tables *sans schéma* , ce qui signifie qu’une seule table peut stocker des entités de plusieurs types pour améliorer la flexibilité de votre conception.</span><span class="sxs-lookup"><span data-stu-id="10689-911">The Table service is a *schema-less* table store that means that a single table can store entities of multiple types providing great flexibility in your design.</span></span> <span data-ttu-id="10689-912">L'exemple suivant présente une table qui stocke les entités de service et d'employé :</span><span class="sxs-lookup"><span data-stu-id="10689-912">The following example illustrates a table storing both employee and department entities:</span></span>  

<table>
<tr>
<th><span data-ttu-id="10689-913">PartitionKey</span><span class="sxs-lookup"><span data-stu-id="10689-913">PartitionKey</span></span></th>
<th><span data-ttu-id="10689-914">RowKey</span><span class="sxs-lookup"><span data-stu-id="10689-914">RowKey</span></span></th>
<th><span data-ttu-id="10689-915">Timestamp</span><span class="sxs-lookup"><span data-stu-id="10689-915">Timestamp</span></span></th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="10689-916">FirstName</span><span class="sxs-lookup"><span data-stu-id="10689-916">FirstName</span></span></th>
<th><span data-ttu-id="10689-917">LastName</span><span class="sxs-lookup"><span data-stu-id="10689-917">LastName</span></span></th>
<th><span data-ttu-id="10689-918">Age</span><span class="sxs-lookup"><span data-stu-id="10689-918">Age</span></span></th>
<th><span data-ttu-id="10689-919">Email</span><span class="sxs-lookup"><span data-stu-id="10689-919">Email</span></span></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="10689-920">FirstName</span><span class="sxs-lookup"><span data-stu-id="10689-920">FirstName</span></span></th>
<th><span data-ttu-id="10689-921">LastName</span><span class="sxs-lookup"><span data-stu-id="10689-921">LastName</span></span></th>
<th><span data-ttu-id="10689-922">Age</span><span class="sxs-lookup"><span data-stu-id="10689-922">Age</span></span></th>
<th><span data-ttu-id="10689-923">Email</span><span class="sxs-lookup"><span data-stu-id="10689-923">Email</span></span></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="10689-924">DepartmentName</span><span class="sxs-lookup"><span data-stu-id="10689-924">DepartmentName</span></span></th>
<th><span data-ttu-id="10689-925">EmployeeCount</span><span class="sxs-lookup"><span data-stu-id="10689-925">EmployeeCount</span></span></th>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="10689-926">FirstName</span><span class="sxs-lookup"><span data-stu-id="10689-926">FirstName</span></span></th>
<th><span data-ttu-id="10689-927">LastName</span><span class="sxs-lookup"><span data-stu-id="10689-927">LastName</span></span></th>
<th><span data-ttu-id="10689-928">Age</span><span class="sxs-lookup"><span data-stu-id="10689-928">Age</span></span></th>
<th><span data-ttu-id="10689-929">Email</span><span class="sxs-lookup"><span data-stu-id="10689-929">Email</span></span></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

<span data-ttu-id="10689-930">Notez que chaque entité doit toujours avoir les valeurs **PartitionKey**, **RowKey** et **Timestamp**, mais elle peut aussi avoir n’importe quel ensemble de propriétés.</span><span class="sxs-lookup"><span data-stu-id="10689-930">Note that each entity must still have **PartitionKey**, **RowKey**, and **Timestamp** values, but may have any set of properties.</span></span> <span data-ttu-id="10689-931">De plus, il n'y a rien pour indiquer le type d'une entité, sauf si vous choisissez de stocker ces informations quelque part.</span><span class="sxs-lookup"><span data-stu-id="10689-931">Furthermore, there is nothing to indicate the type of an entity unless you choose to store that information somewhere.</span></span> <span data-ttu-id="10689-932">Il existe deux options pour identifier le type d'une entité :</span><span class="sxs-lookup"><span data-stu-id="10689-932">There are two options for identifying the entity type:</span></span>  

* <span data-ttu-id="10689-933">Ajout d’un préfixe de type d’entité à la **RowKey** (ou éventuellement à la **PartitionKey**).</span><span class="sxs-lookup"><span data-stu-id="10689-933">Prepend the entity type to the **RowKey** (or possibly the **PartitionKey**).</span></span> <span data-ttu-id="10689-934">Par exemple, **EMPLOYEE_000123** ou **DEPARTMENT_SALES** en tant que valeurs de **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="10689-934">For example, **EMPLOYEE_000123** or **DEPARTMENT_SALES** as **RowKey** values.</span></span>  
* <span data-ttu-id="10689-935">Utilisez une propriété distincte pour enregistrer le type d'entité comme indiqué dans le tableau ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="10689-935">Use a separate property to record the entity type as shown in the table below.</span></span>  

<table>
<tr>
<th><span data-ttu-id="10689-936">PartitionKey</span><span class="sxs-lookup"><span data-stu-id="10689-936">PartitionKey</span></span></th>
<th><span data-ttu-id="10689-937">RowKey</span><span class="sxs-lookup"><span data-stu-id="10689-937">RowKey</span></span></th>
<th><span data-ttu-id="10689-938">Timestamp</span><span class="sxs-lookup"><span data-stu-id="10689-938">Timestamp</span></span></th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="10689-939">EventType</span><span class="sxs-lookup"><span data-stu-id="10689-939">EntityType</span></span></th>
<th><span data-ttu-id="10689-940">FirstName</span><span class="sxs-lookup"><span data-stu-id="10689-940">FirstName</span></span></th>
<th><span data-ttu-id="10689-941">LastName</span><span class="sxs-lookup"><span data-stu-id="10689-941">LastName</span></span></th>
<th><span data-ttu-id="10689-942">Age</span><span class="sxs-lookup"><span data-stu-id="10689-942">Age</span></span></th>
<th><span data-ttu-id="10689-943">Email</span><span class="sxs-lookup"><span data-stu-id="10689-943">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="10689-944">Employee</span><span class="sxs-lookup"><span data-stu-id="10689-944">Employee</span></span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="10689-945">EntityType</span><span class="sxs-lookup"><span data-stu-id="10689-945">EntityType</span></span></th>
<th><span data-ttu-id="10689-946">FirstName</span><span class="sxs-lookup"><span data-stu-id="10689-946">FirstName</span></span></th>
<th><span data-ttu-id="10689-947">LastName</span><span class="sxs-lookup"><span data-stu-id="10689-947">LastName</span></span></th>
<th><span data-ttu-id="10689-948">Age</span><span class="sxs-lookup"><span data-stu-id="10689-948">Age</span></span></th>
<th><span data-ttu-id="10689-949">Email</span><span class="sxs-lookup"><span data-stu-id="10689-949">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="10689-950">Employee</span><span class="sxs-lookup"><span data-stu-id="10689-950">Employee</span></span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="10689-951">EventType</span><span class="sxs-lookup"><span data-stu-id="10689-951">EntityType</span></span></th>
<th><span data-ttu-id="10689-952">DepartmentName</span><span class="sxs-lookup"><span data-stu-id="10689-952">DepartmentName</span></span></th>
<th><span data-ttu-id="10689-953">EmployeeCount</span><span class="sxs-lookup"><span data-stu-id="10689-953">EmployeeCount</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="10689-954">department</span><span class="sxs-lookup"><span data-stu-id="10689-954">Department</span></span></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="10689-955">EventType</span><span class="sxs-lookup"><span data-stu-id="10689-955">EntityType</span></span></th>
<th><span data-ttu-id="10689-956">FirstName</span><span class="sxs-lookup"><span data-stu-id="10689-956">FirstName</span></span></th>
<th><span data-ttu-id="10689-957">LastName</span><span class="sxs-lookup"><span data-stu-id="10689-957">LastName</span></span></th>
<th><span data-ttu-id="10689-958">Age</span><span class="sxs-lookup"><span data-stu-id="10689-958">Age</span></span></th>
<th><span data-ttu-id="10689-959">Email</span><span class="sxs-lookup"><span data-stu-id="10689-959">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="10689-960">Employee</span><span class="sxs-lookup"><span data-stu-id="10689-960">Employee</span></span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

<span data-ttu-id="10689-961">La première option, qui consiste à ajouter un préfixe de type d’entité à la **RowKey**, est utile au cas où deux entités de types différents se retrouvent avec la même valeur de clé.</span><span class="sxs-lookup"><span data-stu-id="10689-961">The first option, prepending the entity type to the **RowKey**, is useful if there is a possibility that two entities of different types might have the same key value.</span></span> <span data-ttu-id="10689-962">Il regroupe également les entités du même type dans la partition.</span><span class="sxs-lookup"><span data-stu-id="10689-962">It also groups entities of the same type together in the partition.</span></span>  

<span data-ttu-id="10689-963">Les techniques présentées dans cette section sont particulièrement adaptées à la discussion [Relations d’héritage](#inheritance-relationships) plus haut dans ce guide, dans la section [Modélisation des relations](#modelling-relationships).</span><span class="sxs-lookup"><span data-stu-id="10689-963">The techniques discussed in this section are especially relevant to the discussion [Inheritance relationships](#inheritance-relationships) earlier in this guide in the section [Modelling relationships](#modelling-relationships).</span></span>  

> [!NOTE]
> <span data-ttu-id="10689-964">Pensez à inclure un numéro de version dans la valeur de type d'entité pour permettre aux applications clientes de faire évoluer des objets POCO et de travailler avec différentes versions.</span><span class="sxs-lookup"><span data-stu-id="10689-964">You should consider including a version number in the entity type value to enable client applications to evolve POCO objects and work with different versions.</span></span>  
> 
> 

<span data-ttu-id="10689-965">Le reste de cette section décrit certaines des fonctionnalités de la bibliothèque cliente de stockage qui facilitent l'utilisation de plusieurs types d'entités dans la même table.</span><span class="sxs-lookup"><span data-stu-id="10689-965">The remainder of this section describes some of the features in the Storage Client Library that facilitate working with multiple entity types in the same table.</span></span>  

#### <a name="retrieving-heterogeneous-entity-types"></a><span data-ttu-id="10689-966">Récupération de types d'entités hétérogènes</span><span class="sxs-lookup"><span data-stu-id="10689-966">Retrieving heterogeneous entity types</span></span>
<span data-ttu-id="10689-967">Si vous utilisez la bibliothèque cliente de stockage, vous avez trois options pour travailler avec plusieurs types d'entité.</span><span class="sxs-lookup"><span data-stu-id="10689-967">If you are using the Storage Client Library, you have three options for working with multiple entity types.</span></span>  

<span data-ttu-id="10689-968">Si vous connaissez le type de l’entité stockée avec des valeurs de **RowKey** et de **PartitionKey** spécifiques, vous pouvez spécifier le type d’entité quand vous récupérez l’entité, comme indiqué dans les deux exemples précédents qui récupèrent des entités de type **EmployeeEntity** : [Exécution d’une requête de pointage à l’aide de la bibliothèque cliente de stockage](#executing-a-point-query-using-the-storage-client-library) et [Récupération de plusieurs entités à l’aide de LINQ](#retrieving-multiple-entities-using-linq).</span><span class="sxs-lookup"><span data-stu-id="10689-968">If you know the type of the entity stored with a specific **RowKey** and **PartitionKey** values, then you can specify the entity type when you retrieve the entity as shown in the previous two examples that retrieve entities of type **EmployeeEntity**: [Executing a point query using the Storage Client Library](#executing-a-point-query-using-the-storage-client-library) and [Retrieving multiple entities using LINQ](#retrieving-multiple-entities-using-linq).</span></span>  

<span data-ttu-id="10689-969">La deuxième option consiste à utiliser le type **DynamicTableEntity** (un conteneur de propriétés) plutôt qu’un type d’entité POCO concret (cette option peut également améliorer les performances, car il n’est pas nécessaire de sérialiser et désérialiser l’entité en types .NET).</span><span class="sxs-lookup"><span data-stu-id="10689-969">The second option is to use the **DynamicTableEntity** type (a property bag) instead of a concrete POCO entity type (this option may also improve performance because there is no need to serialize and deserialize the entity to .NET types).</span></span> <span data-ttu-id="10689-970">Le code C# suivant récupère plusieurs entités de types différents à partir de la table, mais renvoie toutes les entités en tant qu’instances de **DynamicTableEntity** .</span><span class="sxs-lookup"><span data-stu-id="10689-970">The following C# code potentially retrieves multiple entities of different types from the table, but returns all entities as **DynamicTableEntity** instances.</span></span> <span data-ttu-id="10689-971">Il utilise ensuite la propriété **EventType** pour déterminer le type de chaque entité :</span><span class="sxs-lookup"><span data-stu-id="10689-971">It then uses the **EntityType** property to determine the type of each entity:</span></span>  

```csharp
string filter = TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("PartitionKey",
    QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("RowKey",
                    QueryComparisons.GreaterThanOrEqual, "B"),
        TableOperators.And,
        TableQuery.GenerateFilterCondition("RowKey",
        QueryComparisons.LessThan, "F")
    )
);
TableQuery<DynamicTableEntity> entityQuery =
    new TableQuery<DynamicTableEntity>().Where(filter);
var employees = employeeTable.ExecuteQuery(entityQuery);

IEnumerable<DynamicTableEntity> entities = employeeTable.ExecuteQuery(entityQuery);
foreach (var e in entities)
{
EntityProperty entityTypeProperty;
if (e.Properties.TryGetValue("EntityType", out entityTypeProperty))
{
    if (entityTypeProperty.StringValue == "Employee")
    {
        // Use entityTypeProperty, RowKey, PartitionKey, Etag, and Timestamp
        }
    }
}  
```

<span data-ttu-id="10689-972">Notez que pour récupérer d’autres propriétés, vous devez utiliser la méthode **TryGetValue** sur la propriété **Properties** de la classe **DynamicTableEntity**.</span><span class="sxs-lookup"><span data-stu-id="10689-972">Note that to retrieve other properties you must use the **TryGetValue** method on the **Properties** property of the **DynamicTableEntity** class.</span></span>  

<span data-ttu-id="10689-973">Une troisième option consiste à effectuer une combinaison à l’aide du type **DynamicTableEntity** et d’une instance **EntityResolver**.</span><span class="sxs-lookup"><span data-stu-id="10689-973">A third option is to combine using the **DynamicTableEntity** type and an **EntityResolver** instance.</span></span> <span data-ttu-id="10689-974">Cela vous permet de résoudre plusieurs types POCO dans la même requête.</span><span class="sxs-lookup"><span data-stu-id="10689-974">This enables you to resolve to multiple POCO types in the same query.</span></span> <span data-ttu-id="10689-975">Dans cet exemple, le délégué **EntityResolver** utilise la propriété **EntityType** pour faire la distinction entre les deux types d’entités renvoyés par la requête.</span><span class="sxs-lookup"><span data-stu-id="10689-975">In this example, the **EntityResolver** delegate is using the **EntityType** property to distinguish between the two types of entity that the query returns.</span></span> <span data-ttu-id="10689-976">La méthode **Resolve** utilise le délégué **resolver** pour résoudre les instances de **DynamicTableEntity** en instances **TableEntity**.</span><span class="sxs-lookup"><span data-stu-id="10689-976">The **Resolve** method uses the **resolver** delegate to resolve **DynamicTableEntity** instances to **TableEntity** instances.</span></span>  

```csharp
EntityResolver<TableEntity> resolver = (pk, rk, ts, props, etag) =>
{

        TableEntity resolvedEntity = null;
        if (props["EntityType"].StringValue == "Department")
        {
        resolvedEntity = new DepartmentEntity();
        }
        else if (props["EntityType"].StringValue == "Employee")
        {
        resolvedEntity = new EmployeeEntity();
        }
        else throw new ArgumentException("Unrecognized entity", "props");

        resolvedEntity.PartitionKey = pk;
        resolvedEntity.RowKey = rk;
        resolvedEntity.Timestamp = ts;
        resolvedEntity.ETag = etag;
        resolvedEntity.ReadEntity(props, null);
        return resolvedEntity;
};

string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<DynamicTableEntity> entityQuery =
        new TableQuery<DynamicTableEntity>().Where(filter);

var entities = employeeTable.ExecuteQuery(entityQuery, resolver);
foreach (var e in entities)
{
        if (e is DepartmentEntity)
        {
    ...
        }
        if (e is EmployeeEntity)
        {
    ...
        }
}  
```

#### <a name="modifying-heterogeneous-entity-types"></a><span data-ttu-id="10689-977">Modification des types d'entités hétérogènes</span><span class="sxs-lookup"><span data-stu-id="10689-977">Modifying heterogeneous entity types</span></span>
<span data-ttu-id="10689-978">Vous n'avez pas besoin de connaître le type d'une entité pour la supprimer et vous connaissez toujours le type d'une entité lorsque vous l'insérez.</span><span class="sxs-lookup"><span data-stu-id="10689-978">You do not need to know the type of an entity to delete it, and you always know the type of an entity when you insert it.</span></span> <span data-ttu-id="10689-979">Toutefois, vous pouvez utiliser le type **DynamicTableEntity** pour mettre à jour une entité sans connaître son type et sans utiliser de classe d’entité POCO.</span><span class="sxs-lookup"><span data-stu-id="10689-979">However, you can use **DynamicTableEntity** type to update an entity without knowing its type and without using a POCO entity class.</span></span> <span data-ttu-id="10689-980">L’exemple de code suivant récupère une entité unique et vérifie qu’elle dispose bien d’une propriété **EmployeeCount** avant de la mettre à jour.</span><span class="sxs-lookup"><span data-stu-id="10689-980">The following code sample retrieves a single entity, and checks the **EmployeeCount** property exists before updating it.</span></span>  

```csharp
TableResult result =
        employeeTable.Execute(TableOperation.Retrieve(partitionKey, rowKey));
DynamicTableEntity department = (DynamicTableEntity)result.Result;

EntityProperty countProperty;

if (!department.Properties.TryGetValue("EmployeeCount", out countProperty))
{
        throw new
        InvalidOperationException("Invalid entity, EmployeeCount property not found.");
}
countProperty.Int32Value += 1;
employeeTable.Execute(TableOperation.Merge(department));  
```

### <a name="controlling-access-with-shared-access-signatures"></a><span data-ttu-id="10689-981">Contrôle d’accès avec des signatures d’accès partagé</span><span class="sxs-lookup"><span data-stu-id="10689-981">Controlling access with Shared Access Signatures</span></span>
<span data-ttu-id="10689-982">Vous pouvez utiliser des signature d'accès partagé (SAP) pour permettre aux applications clientes de modifier (et d'interroger) des entités de table directement, sans avoir besoin de s'authentifier directement auprès du service de Table.</span><span class="sxs-lookup"><span data-stu-id="10689-982">You can use Shared Access Signature (SAS) tokens to enable client applications to modify (and query) table entities directly without the need to authenticate directly with the table service.</span></span> <span data-ttu-id="10689-983">En règle générale, il existe trois principaux avantages à l'utilisation de SAP dans votre application :</span><span class="sxs-lookup"><span data-stu-id="10689-983">Typically, there are three main benefits to using SAS in your application:</span></span>  

* <span data-ttu-id="10689-984">Vous n'avez plus besoin de distribuer votre clé de compte de stockage vers une plateforme non sécurisée (par exemple un appareil mobile) pour permettre à ce périphérique d'accéder à des entités dans le service de Table et de les modifier.</span><span class="sxs-lookup"><span data-stu-id="10689-984">You do not need to distribute your storage account key to an insecure platform (such as a mobile device) in order to allow that device to access and modify entities in the Table service.</span></span>  
* <span data-ttu-id="10689-985">Vous pouvez décharger certaines tâches effectuées par les rôles web et de travail lors de la gestion de vos entités sur les périphériques clients tels que les ordinateurs et appareils mobiles des utilisateurs finaux.</span><span class="sxs-lookup"><span data-stu-id="10689-985">You can offload some of the work that web and worker roles perform in managing your entities to client devices such as end-user computers and mobile devices.</span></span>  
* <span data-ttu-id="10689-986">Vous pouvez affecter un ensemble d'autorisations contraintes et limitées dans le temps à un client (par exemple, pour autoriser l'accès en lecture seule à des ressources spécifiques).</span><span class="sxs-lookup"><span data-stu-id="10689-986">You can assign a constrained and time limited set of permissions to a client (such as allowing read-only access to specific resources).</span></span>  

<span data-ttu-id="10689-987">Pour plus d’informations sur l’utilisation de jetons SAP avec le service de Table, consultez [Utilisation des signatures d’accès partagé (SAP)](../storage/common/storage-dotnet-shared-access-signature-part-1.md).</span><span class="sxs-lookup"><span data-stu-id="10689-987">For more information about using SAS tokens with the Table service, see [Using Shared Access Signatures (SAS)](../storage/common/storage-dotnet-shared-access-signature-part-1.md).</span></span>  

<span data-ttu-id="10689-988">Toutefois, vous devez toujours générer les jetons SAP qui permettent à une application cliente d'accéder aux entités du service de Table : vous devez le faire dans un environnement qui dispose d'un accès sécurisé à vos clés de compte de stockage.</span><span class="sxs-lookup"><span data-stu-id="10689-988">However, you must still generate the SAS tokens that grant a client application to the entities in the table service: you should do this in an environment that has secure access to your storage account keys.</span></span> <span data-ttu-id="10689-989">En règle générale, vous utilisez un rôle web ou de travail pour générer les jetons SAP et les transmettre vers les applications clientes qui ont besoin d'accéder à vos entités.</span><span class="sxs-lookup"><span data-stu-id="10689-989">Typically, you use a web or worker role to generate the SAS tokens and deliver them to the client applications that need access to your entities.</span></span> <span data-ttu-id="10689-990">Comme il existe toujours une surcharge impliquée dans la génération et l'envoi de jetons SAP aux clients, vous devez envisager la meilleure méthode pour réduire cette surcharge, en particulier dans les scénarios à volumes élevés.</span><span class="sxs-lookup"><span data-stu-id="10689-990">Because there is still an overhead involved in generating and delivering SAS tokens to clients, you should consider how best to reduce this overhead, especially in high-volume scenarios.</span></span>  

<span data-ttu-id="10689-991">Il est possible de générer un jeton SAP qui accorde l'accès à un sous-ensemble d'entités dans une table.</span><span class="sxs-lookup"><span data-stu-id="10689-991">It is possible to generate a SAS token that grants access to a subset of the entities in a table.</span></span> <span data-ttu-id="10689-992">Par défaut, vous créez un jeton SAP pour une table entière, mais il est également possible d’indiquer que le jeton SAP accorde l’accès à une plage de valeurs de **PartitionKey**, ou de **PartitionKey** et de **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="10689-992">By default, you create a SAS token for an entire table, but it is also possible to specify that the SAS token grant access to either a range of **PartitionKey** values, or a range of **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="10689-993">Vous pouvez choisir de générer des jetons SAP pour des utilisateurs individuels de votre système, de sorte que chaque jeton SAP d’un utilisateur lui permet uniquement d’accéder à ses propres entités dans le service de Table.</span><span class="sxs-lookup"><span data-stu-id="10689-993">You might choose to generate SAS tokens for individual users of your system such that each user's SAS token only allows them access to their own entities in the table service.</span></span>  

### <a name="asynchronous-and-parallel-operations"></a><span data-ttu-id="10689-994">Opérations asynchrones et parallèles</span><span class="sxs-lookup"><span data-stu-id="10689-994">Asynchronous and parallel operations</span></span>
<span data-ttu-id="10689-995">Si vous effectuez la diffusion de vos demandes sur plusieurs partitions, vous pouvez améliorer le débit et la réactivité du client en utilisant des requêtes asynchrones ou parallèles.</span><span class="sxs-lookup"><span data-stu-id="10689-995">Provided you are spreading your requests across multiple partitions, you can improve throughput and client responsiveness by using asynchronous or parallel queries.</span></span>
<span data-ttu-id="10689-996">Par exemple, vous pouvez avoir plusieurs instances de rôle de travail accédant à vos tables en parallèle.</span><span class="sxs-lookup"><span data-stu-id="10689-996">For example, you might have two or more worker role instances accessing your tables in parallel.</span></span> <span data-ttu-id="10689-997">Vous pouvez avoir des rôles de travail individuels responsables d'ensembles particuliers de partitions ou simplement plusieurs instances de rôle de travail, chacune étant en mesure d'accéder à toutes les partitions d'une table.</span><span class="sxs-lookup"><span data-stu-id="10689-997">You could have individual worker roles responsible for particular sets of partitions, or simply have multiple worker role instances, each able to access all the partitions in a table.</span></span>  

<span data-ttu-id="10689-998">Dans une instance cliente, vous pouvez améliorer le débit en exécutant des opérations de stockage en mode asynchrone.</span><span class="sxs-lookup"><span data-stu-id="10689-998">Within a client instance, you can improve throughput by executing storage operations asynchronously.</span></span> <span data-ttu-id="10689-999">La bibliothèque cliente de stockage facilite l'écriture des modifications et des requêtes asynchrones.</span><span class="sxs-lookup"><span data-stu-id="10689-999">The Storage Client Library makes it easy to write asynchronous queries and modifications.</span></span> <span data-ttu-id="10689-1000">Par exemple, vous pouvez commencer avec la méthode synchrone qui récupère toutes les entités dans une partition, comme illustré dans le code C# suivant :</span><span class="sxs-lookup"><span data-stu-id="10689-1000">For example, you might start with the synchronous method that retrieves all the entities in a partition as shown in the following C# code:</span></span>  

```csharp
private static void ManyEntitiesQuery(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

        TableContinuationToken continuationToken = null;

        do
        {
        var employees = employeeTable.ExecuteQuerySegmented(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
    {
        ...
    }
        continuationToken = employees.ContinuationToken;
        } while (continuationToken != null);
}  
```

<span data-ttu-id="10689-1001">Vous pouvez facilement modifier ce code afin que la requête s'exécute de façon asynchrone, comme suit :</span><span class="sxs-lookup"><span data-stu-id="10689-1001">You can easily modify this code so that the query runs asynchronously as follows:</span></span>  

```csharp
private static async Task ManyEntitiesQueryAsync(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);
        TableContinuationToken continuationToken = null;

        do
        {
        var employees = await employeeTable.ExecuteQuerySegmentedAsync(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
        {
            ...
        }
        continuationToken = employees.ContinuationToken;
            } while (continuationToken != null);
}  
```

<span data-ttu-id="10689-1002">Dans cet exemple asynchrone, vous pouvez voir les modifications suivantes par rapport à la version synchrone :</span><span class="sxs-lookup"><span data-stu-id="10689-1002">In this asynchronous example, you can see the following changes from the synchronous version:</span></span>  

* <span data-ttu-id="10689-1003">La signature de méthode inclut désormais le modificateur **async** et renvoie une instance **Task**.</span><span class="sxs-lookup"><span data-stu-id="10689-1003">The method signature now includes the **async** modifier and returns a **Task** instance.</span></span>  
* <span data-ttu-id="10689-1004">Au lieu d’appeler la méthode **ExecuteSegmented** pour récupérer les résultats, la méthode appelle maintenant la méthode **ExecuteSegmentedAsync** et utilise le modificateur **await** pour récupérer les résultats de façon asynchrone.</span><span class="sxs-lookup"><span data-stu-id="10689-1004">Instead of calling the **ExecuteSegmented** method to retrieve results, the method now calls the **ExecuteSegmentedAsync** method and uses the **await** modifier to retrieve results asynchronously.</span></span>  

<span data-ttu-id="10689-1005">L’application cliente peut appeler cette méthode plusieurs fois (avec des valeurs différentes pour le paramètre **department** ) et chaque requête s’exécute sur un thread distinct.</span><span class="sxs-lookup"><span data-stu-id="10689-1005">The client application can call this method multiple times (with different values for the **department** parameter), and each query will run on a separate thread.</span></span>  

<span data-ttu-id="10689-1006">Notez qu’il n’existe aucune version asynchrone de la méthode **Execute** dans la classe **TableQuery**, car l’interface **IEnumerable** ne prend pas en charge l’énumération asynchrone.</span><span class="sxs-lookup"><span data-stu-id="10689-1006">Note that there is no asynchronous version of the **Execute** method in the **TableQuery** class because the **IEnumerable** interface does not support asynchronous enumeration.</span></span>  

<span data-ttu-id="10689-1007">Vous pouvez également insérer, mettre à jour et supprimer des entités de façon asynchrone.</span><span class="sxs-lookup"><span data-stu-id="10689-1007">You can also insert, update, and delete entities asynchronously.</span></span> <span data-ttu-id="10689-1008">L'exemple C# suivant indique une méthode simple et synchrone pour insérer ou remplacer une entité d'employé :</span><span class="sxs-lookup"><span data-stu-id="10689-1008">The following C# example shows a simple, synchronous method to insert or replace an employee entity:</span></span>  

```csharp
private static void SimpleEmployeeUpsert(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = employeeTable
        .Execute(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

<span data-ttu-id="10689-1009">Vous pouvez facilement modifier ce code pour que la mise à jour s'exécute de façon asynchrone, comme suit :</span><span class="sxs-lookup"><span data-stu-id="10689-1009">You can easily modify this code so that the update runs asynchronously as follows:</span></span>  

```csharp
private static async Task SimpleEmployeeUpsertAsync(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = await employeeTable
        .ExecuteAsync(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

<span data-ttu-id="10689-1010">Dans cet exemple asynchrone, vous pouvez voir les modifications suivantes par rapport à la version synchrone :</span><span class="sxs-lookup"><span data-stu-id="10689-1010">In this asynchronous example, you can see the following changes from the synchronous version:</span></span>  

* <span data-ttu-id="10689-1011">La signature de méthode inclut désormais le modificateur **async** et renvoie une instance **Task**.</span><span class="sxs-lookup"><span data-stu-id="10689-1011">The method signature now includes the **async** modifier and returns a **Task** instance.</span></span>  
* <span data-ttu-id="10689-1012">Au lieu d’appeler la méthode **Execute** pour mettre à jour l’entité, la méthode appelle maintenant la méthode **ExecuteAsync** et utilise le modificateur **await** pour récupérer les résultats de façon asynchrone.</span><span class="sxs-lookup"><span data-stu-id="10689-1012">Instead of calling the **Execute** method to update the entity, the method now calls the **ExecuteAsync** method and uses the **await** modifier to retrieve results asynchronously.</span></span>  

<span data-ttu-id="10689-1013">L'application cliente peut appeler plusieurs méthodes asynchrones comme celle-ci, et chaque appel de méthode s'exécute sur un thread distinct.</span><span class="sxs-lookup"><span data-stu-id="10689-1013">The client application can call multiple asynchronous methods like this one, and each method invocation will run on a separate thread.</span></span>  

### <a name="credits"></a><span data-ttu-id="10689-1014">Crédits</span><span class="sxs-lookup"><span data-stu-id="10689-1014">Credits</span></span>
<span data-ttu-id="10689-1015">Nous aimerions remercier les membres suivants de l’équipe Azure pour leur contribution : Dominic Betts, Jason Hogg, Jean Ghanem, Jai Haridas, Jeff Irwin, Vamshidhar Kommineni, Vinay Shah et Serdar Ozler, ainsi que Tom Hollander de Microsoft DX.</span><span class="sxs-lookup"><span data-stu-id="10689-1015">We would like to thank the following members of the Azure team for their contributions: Dominic Betts, Jason Hogg, Jean Ghanem, Jai Haridas, Jeff Irwin, Vamshidhar Kommineni, Vinay Shah and Serdar Ozler as well as  Tom Hollander from Microsoft DX.</span></span> 

<span data-ttu-id="10689-1016">Nous aimerions également remercier les MVP Microsoft suivants pour leurs précieux commentaires durant les phases de révision : Igor Papirov et Edward Bakker.</span><span class="sxs-lookup"><span data-stu-id="10689-1016">We would also like to thank the following Microsoft MVP's for their valuable feedback during review cycles: Igor Papirov and Edward Bakker.</span></span>

[1]: ./media/storage-table-design-guide/storage-table-design-IMAGE01.png
[2]: ./media/storage-table-design-guide/storage-table-design-IMAGE02.png
[3]: ./media/storage-table-design-guide/storage-table-design-IMAGE03.png
[4]: ./media/storage-table-design-guide/storage-table-design-IMAGE04.png
[5]: ./media/storage-table-design-guide/storage-table-design-IMAGE05.png
[6]: ./media/storage-table-design-guide/storage-table-design-IMAGE06.png
[7]: ./media/storage-table-design-guide/storage-table-design-IMAGE07.png
[8]: ./media/storage-table-design-guide/storage-table-design-IMAGE08.png
[9]: ./media/storage-table-design-guide/storage-table-design-IMAGE09.png
[10]: ./media/storage-table-design-guide/storage-table-design-IMAGE10.png
[11]: ./media/storage-table-design-guide/storage-table-design-IMAGE11.png
[12]: ./media/storage-table-design-guide/storage-table-design-IMAGE12.png
[13]: ./media/storage-table-design-guide/storage-table-design-IMAGE13.png
[14]: ./media/storage-table-design-guide/storage-table-design-IMAGE14.png
[15]: ./media/storage-table-design-guide/storage-table-design-IMAGE15.png
[16]: ./media/storage-table-design-guide/storage-table-design-IMAGE16.png
[17]: ./media/storage-table-design-guide/storage-table-design-IMAGE17.png
[18]: ./media/storage-table-design-guide/storage-table-design-IMAGE18.png
[19]: ./media/storage-table-design-guide/storage-table-design-IMAGE19.png
[20]: ./media/storage-table-design-guide/storage-table-design-IMAGE20.png
[21]: ./media/storage-table-design-guide/storage-table-design-IMAGE21.png
[22]: ./media/storage-table-design-guide/storage-table-design-IMAGE22.png
[23]: ./media/storage-table-design-guide/storage-table-design-IMAGE23.png
[24]: ./media/storage-table-design-guide/storage-table-design-IMAGE24.png
[25]: ./media/storage-table-design-guide/storage-table-design-IMAGE25.png
[26]: ./media/storage-table-design-guide/storage-table-design-IMAGE26.png
[27]: ./media/storage-table-design-guide/storage-table-design-IMAGE27.png
[28]: ./media/storage-table-design-guide/storage-table-design-IMAGE28.png
[29]: ./media/storage-table-design-guide/storage-table-design-IMAGE29.png

