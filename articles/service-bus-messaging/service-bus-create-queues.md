---
title: "Écriture d’applications qui utilisent les files d’attente Azure Service Bus | Microsoft Docs"
description: "Comment écrire une application simple basée sur la file d’attente qui utilise Azure Service Bus."
services: service-bus-messaging
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: 754d91b3-1426-405e-84b4-fd36d65b114a
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 08/07/2017
ms.author: sethm
ms.openlocfilehash: 419caff7e8ceeb419c89a2ef9a6614c1accf3e52
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/18/2017
---
# <a name="create-applications-that-use-service-bus-queues"></a><span data-ttu-id="c7b4e-103">Création d'applications qui utilisent les files d'attente Service Bus</span><span class="sxs-lookup"><span data-stu-id="c7b4e-103">Create applications that use Service Bus queues</span></span>
<span data-ttu-id="c7b4e-104">Cette rubrique décrit les files d’attente Service Bus et montre comment écrire une application simple basée sur les files d’attente et qui utilise Service Bus.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-104">This topic describes Service Bus queues and shows how to write a simple queue-based application that uses Service Bus.</span></span>

<span data-ttu-id="c7b4e-105">Imaginez. Vous voilà plongé au cœur de la vente au détail. Les données de vente recueillies à partir de terminaux de point de vente (PDV) doivent être acheminées vers un système de gestion des stocks. Celui-ci utilise ces données pour déterminer le moment où il est nécessaire de renouveler les stocks.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-105">Consider a scenario from the world of retail in which sales data from individual Point-of-Sale (POS) terminals must be routed to an inventory management system that uses the data to determine when stock has to be replenished.</span></span> <span data-ttu-id="c7b4e-106">Cette solution utilise les messages Service Bus pour communiquer entre les terminaux et le système de gestion des stocks, comme illustré dans la figure suivante :</span><span class="sxs-lookup"><span data-stu-id="c7b4e-106">This solution uses Service Bus messaging for the communication between the terminals and the inventory management system, as illustrated in the following figure:</span></span>

![Image 1 Files d’attente Service Bus](./media/service-bus-create-queues/IC657161.gif)

<span data-ttu-id="c7b4e-108">Chaque terminal de PDV consigne ses données de vente en envoyant des messages à la **DataCollectionQueue**.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-108">Each POS terminal reports its sales data by sending messages to the **DataCollectionQueue**.</span></span> <span data-ttu-id="c7b4e-109">Ces messages restent dans cette file d'attente jusqu'à ce qu'ils soient récupérés par le système de gestion des stocks.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-109">These messages remain in this queue until they are retrieved by the inventory management system.</span></span> <span data-ttu-id="c7b4e-110">Ce modèle est souvent appelé *messagerie asynchrone*, car le terminal de PDV n’a pas à attendre une réponse à partir du système de gestion des stocks pour poursuivre le traitement.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-110">This pattern is often termed *asynchronous messaging*, because the POS terminal does not have to wait for a reply from the inventory management system to continue processing.</span></span>

## <a name="why-queuing"></a><span data-ttu-id="c7b4e-111">Avantages de la file d'attente</span><span class="sxs-lookup"><span data-stu-id="c7b4e-111">Why queuing?</span></span>
<span data-ttu-id="c7b4e-112">Avant d'examiner le code nécessaire à la configuration de cette application, considérez les avantages de l'utilisation d'une file d'attente dans ce scénario par rapport à la communication directe (synchrone) entre les terminaux de PDV et le système de gestion des stocks.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-112">Before we look at the code that is required to set up this application, consider the advantages of using a queue in this scenario instead of having the POS terminals talk directly (synchronously) to the inventory management system.</span></span>

### <a name="temporal-decoupling"></a><span data-ttu-id="c7b4e-113">Découplage temporel</span><span class="sxs-lookup"><span data-stu-id="c7b4e-113">Temporal decoupling</span></span>
<span data-ttu-id="c7b4e-114">Avec le modèle de messagerie asynchrone, les producteurs et les consommateurs n'ont pas besoin d'être en ligne en même temps.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-114">With the asynchronous messaging pattern, producers and consumers do not have to be online at the same time.</span></span> <span data-ttu-id="c7b4e-115">L'infrastructure de la messagerie stocke les messages de façon fiable jusqu'à ce que le récepteur soit prêt à les recevoir.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-115">The messaging infrastructure reliably stores messages until the consuming party is ready to receive them.</span></span> <span data-ttu-id="c7b4e-116">Ceci permet aux composants de l’application distribuée d’être déconnectés, soit volontairement, par exemple pour des raisons de maintenance, soit en raison de l’échec d’un composant, sans conséquences sur le système dans sa globalité.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-116">This means the components of the distributed application can be disconnected, either voluntarily; for example, for maintenance, or due to a component crash, without affecting the whole system.</span></span> <span data-ttu-id="c7b4e-117">De plus, l'application qui utilise les messages n'a besoin d'être en ligne que quelques fois par jour.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-117">Furthermore, the consuming application may only have to be online during certain times of the day.</span></span> <span data-ttu-id="c7b4e-118">Par exemple, dans ce scénario de vente au détail, le système de gestion des stocks peut très bien être en ligne uniquement en fin de journée.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-118">For example, in this retail scenario, the inventory management system may only have to come online after the end of the business day.</span></span>

### <a name="load-leveling"></a><span data-ttu-id="c7b4e-119">Niveau de charge</span><span class="sxs-lookup"><span data-stu-id="c7b4e-119">Load leveling</span></span>
<span data-ttu-id="c7b4e-120">Dans de nombreuses applications, la charge système varie dans le temps, alors que le temps de traitement nécessaire à chaque unité de travail est normalement constant.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-120">In many applications system load varies over time, whereas the processing time required for each unit of work is typically constant.</span></span> <span data-ttu-id="c7b4e-121">L'ajout d'une file d'attente entre les producteurs et les consommateurs des messages fait que l'application de destination (le rôle de travail) n'a besoin d'être configurée que pour une charge de travail moyenne, plutôt que pour une charge de travail maximale.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-121">Intermediating message producers and consumers with a queue means that the consuming application (the worker) only has to be provisioned to service an average load rather than a peak load.</span></span> <span data-ttu-id="c7b4e-122">La file d'attente s'allonge et se raccourcit en fonction de la charge entrante.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-122">The depth of the queue will grow and contract as the incoming load varies.</span></span> <span data-ttu-id="c7b4e-123">Ceci permet de faire des économies concernant les infrastructures nécessaires pour faire face à la charge de travail de l’application.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-123">This directly saves money with regard to the amount of infrastructure required to service the application load.</span></span>

![Image 2 Files d’attente Service Bus](./media/service-bus-create-queues/IC657162.gif)

### <a name="load-balancing"></a><span data-ttu-id="c7b4e-125">Équilibrage de la charge</span><span class="sxs-lookup"><span data-stu-id="c7b4e-125">Load balancing</span></span>
<span data-ttu-id="c7b4e-126">À mesure que la charge augmente, d'autres processus de travail peuvent être ajoutés pour lire les éléments de la file d'attente de travail.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-126">As the load increases, more worker processes can be added to read from the worker queue.</span></span> <span data-ttu-id="c7b4e-127">Chaque message est traité par un seul des processus de travail.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-127">Each message is processed by only one of the worker processes.</span></span> <span data-ttu-id="c7b4e-128">De plus, cet équilibrage de la charge basé sur l'extraction permet d'optimiser l'utilisation des ordinateurs de travail, même si ceux-ci diffèrent en termes de puissance de traitement, car ils demandent les messages au maximum de leur capacité.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-128">Furthermore, this pull-based load balancing allows for optimum usage of the worker computers even if the worker computers differ with regard to processing power, as they will pull messages at their own maximum rate.</span></span> <span data-ttu-id="c7b4e-129">Ce modèle est souvent appelé modèle consommateur concurrent.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-129">This pattern is often termed the competing consumer pattern.</span></span>

![Image 3 Files d’attente Service Bus](./media/service-bus-create-queues/IC657163.gif)

### <a name="loose-coupling"></a><span data-ttu-id="c7b4e-131">Couplage faible</span><span class="sxs-lookup"><span data-stu-id="c7b4e-131">Loose coupling</span></span>
<span data-ttu-id="c7b4e-132">L'utilisation de files d'attente de message comme intermédiaire entre les producteurs et les consommateurs de messages fournit un couplage souple et intrinsèque entre les composants.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-132">Using message queuing to intermediate between message producers and consumers provides an intrinsic loose coupling between the components.</span></span> <span data-ttu-id="c7b4e-133">Producteurs et consommateurs étant indépendants les uns des autres, il est possible de mettre à niveau un consommateur sans que cela affecte le producteur.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-133">Because producers and consumers are not aware of each other, a consumer can be upgraded without having any effect on the producer.</span></span> <span data-ttu-id="c7b4e-134">En outre, la topologie de messagerie peut évoluer sans affecter les points de terminaison existants.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-134">Furthermore, the messaging topology can evolve without affecting the existing endpoints.</span></span> <span data-ttu-id="c7b4e-135">Nous y reviendrons plus en détail lorsque nous aborderons la publication/l'abonnement.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-135">We’ll discuss this more when we talk about publish/subscribe.</span></span>

## <a name="show-me-the-code"></a><span data-ttu-id="c7b4e-136">Afficher le code</span><span class="sxs-lookup"><span data-stu-id="c7b4e-136">Show me the code</span></span>
<span data-ttu-id="c7b4e-137">La section suivante montre comment utiliser Service Bus pour créer cette application.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-137">The following section shows how to use Service Bus to build this application.</span></span>

### <a name="sign-up-for-an-azure-account"></a><span data-ttu-id="c7b4e-138">Créer un compte Azure</span><span class="sxs-lookup"><span data-stu-id="c7b4e-138">Sign up for an Azure account</span></span>
<span data-ttu-id="c7b4e-139">Vous aurez besoin d'un compte Azure pour commencer à travailler avec Service Bus.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-139">You’ll need an Azure account in order to start working with Service Bus.</span></span> <span data-ttu-id="c7b4e-140">Si vous n’en avez pas, vous pouvez vous inscrire [ici](https://azure.microsoft.com/pricing/free-trial/?WT.mc_id=A85619ABF) pour obtenir un compte gratuit.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-140">If you do not already have one, you can sign up for a free account [here](https://azure.microsoft.com/pricing/free-trial/?WT.mc_id=A85619ABF).</span></span>

### <a name="create-a-namespace"></a><span data-ttu-id="c7b4e-141">Créer un espace de noms</span><span class="sxs-lookup"><span data-stu-id="c7b4e-141">Create a namespace</span></span>
<span data-ttu-id="c7b4e-142">Une fois que vous avez un abonnement, vous pouvez [créer un espace de noms de service](service-bus-create-namespace-portal.md).</span><span class="sxs-lookup"><span data-stu-id="c7b4e-142">Once you have a subscription, you can [create a service namespace](service-bus-create-namespace-portal.md).</span></span> <span data-ttu-id="c7b4e-143">Un espace de noms est un conteneur d’étendue pour un jeu d’entités Service Bus.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-143">Each namespace acts as a scoping container for a set of Service Bus entities.</span></span> <span data-ttu-id="c7b4e-144">Donnez un nom unique à votre nouvel espace de noms sur tous les comptes Service Bus.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-144">Give your new namespace a unique name across all Service Bus accounts.</span></span> 

### <a name="install-the-nuget-package"></a><span data-ttu-id="c7b4e-145">Installez le package NuGet</span><span class="sxs-lookup"><span data-stu-id="c7b4e-145">Install the NuGet package</span></span>
<span data-ttu-id="c7b4e-146">Pour utiliser l’espace de noms Service Bus, une application doit référencer l’assembly Service Bus, et plus précisément le fichier Microsoft.ServiceBus.dll.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-146">To use the Service Bus namespace, an application must reference the Service Bus assembly, specifically Microsoft.ServiceBus.dll.</span></span> <span data-ttu-id="c7b4e-147">Vous pouvez retrouver cet assembly dans le kit de développement logiciel (SDK) Microsoft Azure. Le téléchargement est disponible sur la [page de téléchargement du kit de développement (SDK) de Microsoft Azure](https://azure.microsoft.com/downloads/).</span><span class="sxs-lookup"><span data-stu-id="c7b4e-147">You can find this assembly as part of the Microsoft Azure SDK, and the download is available at the [Azure SDK download page](https://azure.microsoft.com/downloads/).</span></span> <span data-ttu-id="c7b4e-148">Toutefois, le [package NuGet Service Bus](https://www.nuget.org/packages/WindowsAzure.ServiceBus) est le moyen le plus simple de se procurer l’API Service Bus et de configurer votre application avec toutes les dépendances Service Bus disponibles.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-148">However, the [Service Bus NuGet package](https://www.nuget.org/packages/WindowsAzure.ServiceBus) is the easiest way to get the Service Bus API and to configure your application with all of the Service Bus dependencies.</span></span>

### <a name="create-the-queue"></a><span data-ttu-id="c7b4e-149">Créer la file d’attente</span><span class="sxs-lookup"><span data-stu-id="c7b4e-149">Create the queue</span></span>
<span data-ttu-id="c7b4e-150">Les opérations de gestion des entités de messagerie Service Bus (rubriques files d’attente et publication/abonnement) sont effectuées via la classe [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager).</span><span class="sxs-lookup"><span data-stu-id="c7b4e-150">Management operations for Service Bus messaging entities (queues and publish/subscribe topics) are performed via the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class.</span></span> <span data-ttu-id="c7b4e-151">Service Bus utilise un modèle de sécurité basé sur une [signature d’accès partagé (SAP)](service-bus-sas.md).</span><span class="sxs-lookup"><span data-stu-id="c7b4e-151">Service Bus uses a [Shared Access Signature (SAS)](service-bus-sas.md) based security model.</span></span> <span data-ttu-id="c7b4e-152">La classe [TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider) représente un fournisseur de jetons de sécurité dont les méthodes de fabrique intégrées renvoient des fournisseurs de jetons bien connus.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-152">The [TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider) class represents a security token provider with built-in factory methods returning some well-known token providers.</span></span> <span data-ttu-id="c7b4e-153">Nous allons utiliser une méthode [CreateSharedAccessSignatureTokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#Microsoft_ServiceBus_TokenProvider_CreateSharedAccessSignatureTokenProvider_System_String_) pour retenir les informations d’identification SAP.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-153">We’ll use a [CreateSharedAccessSignatureTokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#Microsoft_ServiceBus_TokenProvider_CreateSharedAccessSignatureTokenProvider_System_String_) method to hold the SAS credentials.</span></span> <span data-ttu-id="c7b4e-154">L’instance [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) est ensuite créée avec l’adresse de base de l’espace de noms Service Bus et du fournisseur de jetons.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-154">The [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) instance is then constructed with the base address of the Service Bus namespace and the token provider.</span></span>

<span data-ttu-id="c7b4e-155">La classe [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) fournit des méthodes pour créer, énumérer et supprimer des entités de messagerie.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-155">The [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class provides methods to create, enumerate and delete messaging entities.</span></span> <span data-ttu-id="c7b4e-156">Le code ci-dessous montre comment l’instance [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) est créée et utilisée pour créer la file d’attente **DataCollectionQueue**.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-156">The code that is shown here shows how the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) instance is created and used to create the **DataCollectionQueue** queue.</span></span>

```csharp
Uri uri = ServiceBusEnvironment.CreateServiceUri("sb", 
                "test-blog", string.Empty);
string name = "RootManageSharedAccessKey";
string key = "abcdefghijklmopqrstuvwxyz";

TokenProvider tokenProvider = 
    TokenProvider.CreateSharedAccessSignatureTokenProvider(name, key);
NamespaceManager namespaceManager = 
    new NamespaceManager(uri, tokenProvider);
namespaceManager.CreateQueue("DataCollectionQueue");
```

<span data-ttu-id="c7b4e-157">Notez qu’il existe des surcharges de la méthode [CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_) qui activent les propriétés de la file d’attente à paramétrer.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-157">Note that there are overloads of the [CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_) method that enable properties of the queue to be tuned.</span></span> <span data-ttu-id="c7b4e-158">Par exemple, vous pouvez définir la valeur par défaut de durée de vie « time-to-live » pour les messages envoyés à la file d'attente.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-158">For example, you can set the default time-to-live (TTL) value for messages sent to the queue.</span></span>

### <a name="send-messages-to-the-queue"></a><span data-ttu-id="c7b4e-159">Envoyez des messages à la file d'attente</span><span class="sxs-lookup"><span data-stu-id="c7b4e-159">Send messages to the queue</span></span>
<span data-ttu-id="c7b4e-160">Pour des opérations d’exécution sur les entités Service Bus ; par exemple, pour l’envoi et la réception de messages, une application doit tout d’abord créer un objet [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory).</span><span class="sxs-lookup"><span data-stu-id="c7b4e-160">For run-time operations on Service Bus entities; for example, sending and receiving messages, an application must first create a [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) object.</span></span> <span data-ttu-id="c7b4e-161">Semblable à la classe [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager), l’instance [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) est créée à partir de l’adresse de base de l’espace de noms et du fournisseur de jetons.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-161">Similar to the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class, the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance is created from the base address of the service namespace and the token provider.</span></span>

```csharp
 BrokeredMessage bm = new BrokeredMessage(salesData);
 bm.Label = "SalesReport";
 bm.Properties["StoreName"] = "Redmond";
 bm.Properties["MachineID"] = "POS_1";
```

<span data-ttu-id="c7b4e-162">Les messages envoyés aux files d’attente Service Bus (et reçus de celles-ci) sont des instances de la classe [BrokeredMessage](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage).</span><span class="sxs-lookup"><span data-stu-id="c7b4e-162">Messages sent to, and received from Service Bus queues are instances of the [BrokeredMessage](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage) class.</span></span> <span data-ttu-id="c7b4e-163">Cette classe se compose d’un ensemble de propriétés standard (telles que [Label](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Label) et [TimeToLive](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_TimeToLive)), un dictionnaire servant à conserver les propriétés propres à une application, ainsi qu’un corps de données d’application arbitraires.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-163">This class consists of a set of standard properties (such as [Label](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Label) and [TimeToLive](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_TimeToLive)), a dictionary that is used to hold application properties, and a body of arbitrary application data.</span></span> <span data-ttu-id="c7b4e-164">Une application peut définir le corps en transmettant un objet sérialisable (l’exemple suivant transmet un objet **SalesData** qui représente les données de ventes à partir du terminal de PDV), qui utilisera [DataContractSerializer](https://msdn.microsoft.com/library/system.runtime.serialization.datacontractserializer.aspx) pour sérialiser l’objet.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-164">An application can set the body by passing in any serializable object (the following example passes in a **SalesData** object that represents the sales data from the POS terminal), which will use the [DataContractSerializer](https://msdn.microsoft.com/library/system.runtime.serialization.datacontractserializer.aspx) to serialize the object.</span></span> <span data-ttu-id="c7b4e-165">Une autre possibilité consiste à fournir un objet [Stream](https://msdn.microsoft.com/library/system.io.stream.aspx).</span><span class="sxs-lookup"><span data-stu-id="c7b4e-165">Alternatively, a [Stream](https://msdn.microsoft.com/library/system.io.stream.aspx) object can be provided.</span></span>

<span data-ttu-id="c7b4e-166">Le moyen le plus simple pour envoyer des messages à une file d’attente donnée, dans notre cas **DataCollectionQueue**, consiste à utiliser [CreateMessageSender](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageSender_System_String_) pour créer un objet [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) directement à partir de l’instance [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory).</span><span class="sxs-lookup"><span data-stu-id="c7b4e-166">The easiest way to send messages to a given queue, in our case the **DataCollectionQueue**, is to use [CreateMessageSender](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageSender_System_String_) to create a [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) object directly from the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance.</span></span>

```csharp
MessageSender sender = factory.CreateMessageSender("DataCollectionQueue");
sender.Send(bm);
```

### <a name="receiving-messages-from-the-queue"></a><span data-ttu-id="c7b4e-167">Réception de messages à partir de la file d'attente</span><span class="sxs-lookup"><span data-stu-id="c7b4e-167">Receiving messages from the queue</span></span>
<span data-ttu-id="c7b4e-168">Pour recevoir des messages de la file d’attente, vous pouvez utiliser un objet [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) que vous créez directement à partir de [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) à l’aide de [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_).</span><span class="sxs-lookup"><span data-stu-id="c7b4e-168">To receive messages from the queue, you can use a [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) object which you create directly from the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) using [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_).</span></span> <span data-ttu-id="c7b4e-169">Les destinataires de message peuvent fonctionner dans deux modes différents : **ReceiveAndDelete** et **PeekLock**.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-169">Message receivers can work in two different modes: **ReceiveAndDelete** and **PeekLock**.</span></span> <span data-ttu-id="c7b4e-170">Le [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) est défini lorsque le destinataire du message est créé, en tant que paramètre de l’appel [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory?redirectedfrom=MSDN#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_Microsoft_ServiceBus_Messaging_ReceiveMode_).</span><span class="sxs-lookup"><span data-stu-id="c7b4e-170">The [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) is set when the message receiver is created, as a parameter to the [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory?redirectedfrom=MSDN#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_Microsoft_ServiceBus_Messaging_ReceiveMode_) call.</span></span>

<span data-ttu-id="c7b4e-171">En mode **ReceiveAndDelete**, l’opération est exécutée une seule fois, en d’autres termes, lorsque Service Bus reçoit la demande, il marque ce message comme étant consommé et le renvoie à l’application.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-171">When using the **ReceiveAndDelete** mode, the receive is a single-shot operation; that is, when Service Bus receives the request, it marks the message as being consumed and returns it to the application.</span></span> <span data-ttu-id="c7b4e-172">Le mode **ReceiveAndDelete** est le modèle le plus simple et le mieux adapté aux scénarios dans lesquels une application est capable de tolérer le non-traitement d’un message en cas d’échec.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-172">**ReceiveAndDelete** mode is the simplest model and works best for scenarios in which the application can tolerate not processing a message if a failure were to occur.</span></span> <span data-ttu-id="c7b4e-173">Pour mieux comprendre, imaginez un scénario dans lequel le consommateur émet la demande de réception et subit un incident avant de la traiter.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-173">To understand this, consider a scenario in which the consumer issues the receive request and then crashes before processing it.</span></span> <span data-ttu-id="c7b4e-174">Service Bus ayant marqué le message comme étant consommé, lorsque l'application redémarre et recommence à traiter des messages, elle ignore le message consommé avant l'incident.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-174">Since Service Bus marked the message as being consumed, when the application restarts and starts consuming messages again, it will have missed the message that was consumed before the crash.</span></span>

<span data-ttu-id="c7b4e-175">En mode **PeekLock**, la réception devient une opération en deux étapes, qui autorise une prise en charge des applications qui ne peuvent pas tolérer les messages manquants.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-175">In **PeekLock** mode, the receive becomes a two-stage operation, which makes it possible to support applications that cannot tolerate missing messages.</span></span> <span data-ttu-id="c7b4e-176">Lorsque Service Bus reçoit la demande, il recherche le prochain message à consommer, le verrouille pour empêcher d'autres consommateurs de le recevoir, puis le renvoie à l'application.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-176">When Service Bus receives the request, it finds the next message to be consumed, locks it to prevent other consumers receiving it, and then returns it to the application.</span></span> <span data-ttu-id="c7b4e-177">Dès lors que l’application a terminé le traitement du message (ou qu’elle l’a stocké de manière fiable pour un traitement ultérieur), elle accomplit la deuxième étape du processus de réception en appelant [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) pour le message reçu.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-177">After the application finishes processing the message (or stores it reliably for future processing), it completes the second stage of the receive process by calling [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) on the received message.</span></span> <span data-ttu-id="c7b4e-178">Lorsque Service Bus obtient l’appel [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete), il marque le message comme étant consommé.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-178">When Service Bus sees the [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) call, it marks the message as being consumed.</span></span>

<span data-ttu-id="c7b4e-179">Deux autres issues sont possibles.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-179">Two other outcomes are possible.</span></span> <span data-ttu-id="c7b4e-180">Tout d’abord, si une application est dans l’impossibilité de traiter un message pour une raison quelconque, elle peut appeler la méthode [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) pour le message reçu (au lieu de la méthode [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span><span class="sxs-lookup"><span data-stu-id="c7b4e-180">First, if the application is unable to process the message for some reason, it can call [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) on the received message (instead of [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span></span> <span data-ttu-id="c7b4e-181">Cela permet à Service Bus de déverrouiller le message et le met à disposition pour être à nouveau reçu, soit par le même consommateur, soit par un consommateur concurrent.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-181">This causes Service Bus to unlock the message and make it available to be received again, either by the same consumer or by another completing consumer.</span></span> <span data-ttu-id="c7b4e-182">Ensuite, il faut savoir qu’un message verrouillé dans une file d’attente est assorti d’un délai d’expiration et que si l’application ne parvient pas à traiter le message dans le temps imparti (par exemple, en cas d’incident), Service Bus déverrouillera le message automatiquement et le rendra à nouveau disponible en réception (essentiellement en effectuant une opération [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) par défaut).</span><span class="sxs-lookup"><span data-stu-id="c7b4e-182">Second, there is a time-out associated with the lock and if the application cannot process the message before the lock time-out expires (for example, if the application crashes), then Service Bus will unlock the message and make it available to be received again (essentially performing an [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) operation by default).</span></span>

<span data-ttu-id="c7b4e-183">Notez que si l’application subit un incident après le traitement du message, mais avant l’envoi de la demande [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete), le message est à nouveau remis à l’application lorsqu’elle redémarre.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-183">Note that if the application crashes after it processes the message but before the [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) request was issued, the message will be redelivered to the application when it restarts.</span></span> <span data-ttu-id="c7b4e-184">On appelle cela * au moins une fois * le traitement.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-184">This is often termed *At Least Once * processing.</span></span> <span data-ttu-id="c7b4e-185">En d'autres termes, chaque message est traité au moins une fois, mais dans certaines situations le même message peut être redistribué.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-185">This means that each message will be processed at least once but in certain situations the same message may be redelivered.</span></span> <span data-ttu-id="c7b4e-186">Si le scénario ne peut pas tolérer un traitement dupliqué, une logique supplémentaire est nécessaire dans l'application pour détecter les doublons.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-186">If the scenario cannot tolerate duplicate processing, then additional logic is required in the application to detect duplicates.</span></span> <span data-ttu-id="c7b4e-187">Cela peut être effectué en fonction de la propriété [MessageId](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId) du message.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-187">This can be achieved based on the [MessageId](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId) property of the message.</span></span> <span data-ttu-id="c7b4e-188">La valeur de cette propriété ne change pas entre chaque tentative de remise.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-188">The value of this property remains constant across delivery attempts.</span></span> <span data-ttu-id="c7b4e-189">Cette opération est connue sous le nom de traitement *seulement une fois*.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-189">This is termed *Exactly Once* processing.</span></span>

<span data-ttu-id="c7b4e-190">Le code présenté ici reçoit et traite un message en utilisant le mode **PeekLock**, qui est la valeur par défaut si aucune valeur [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) n’est fournie explicitement.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-190">The code that is shown here receives and processes a message using the **PeekLock** mode, which is the default if no [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) value is explicitly provided.</span></span>

```csharp
MessageReceiver receiver = factory.CreateMessageReceiver("DataCollectionQueue");
BrokeredMessage receivedMessage = receiver.Receive();
try
{
    ProcessMessage(receivedMessage);
    receivedMessage.Complete();
}
catch (Exception e)
{
    receivedMessage.Abandon();
}
```

### <a name="use-the-queue-client"></a><span data-ttu-id="c7b4e-191">Utilisez le client de la file d'attente</span><span class="sxs-lookup"><span data-stu-id="c7b4e-191">Use the queue client</span></span>
<span data-ttu-id="c7b4e-192">Les exemples cités plus haut dans cette section ont directement créé les objets [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) et [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) à partir de [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) pour envoyer et recevoir des messages de la file d’attente, respectivement.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-192">The examples earlier in this section created [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) and [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) objects directly from the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) to send and receive messages from the queue, respectively.</span></span> <span data-ttu-id="c7b4e-193">Une autre approche consiste à utiliser un objet [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient) qui prend en charge les opérations d’envoi et de réception en plus des fonctionnalités plus avancées, telles que les sessions.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-193">An alternative approach is to use a [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient) object, which supports both send and receive operations in addition to more advanced features, such as sessions.</span></span>

```csharp
QueueClient queueClient = factory.CreateQueueClient("DataCollectionQueue");
queueClient.Send(bm);

BrokeredMessage message = queueClient.Receive();

try
{
    ProcessMessage(message);
    message.Complete();
}
catch (Exception e)
{
    message.Abandon();
} 
```

## <a name="next-steps"></a><span data-ttu-id="c7b4e-194">Étapes suivantes</span><span class="sxs-lookup"><span data-stu-id="c7b4e-194">Next steps</span></span>
<span data-ttu-id="c7b4e-195">Maintenant que vous avez appris les fondamentaux des files d’attente, consultez [Création d’applications qui utilisent des rubriques et des abonnements Service Bus](service-bus-create-topics-subscriptions.md) pour poursuivre cette discussion à l’aide des fonctions de publication/d’abonnement des rubriques et abonnements Service Bus.</span><span class="sxs-lookup"><span data-stu-id="c7b4e-195">Now that you've learned the basics of queues, see [Create applications that use Service Bus topics and subscriptions](service-bus-create-topics-subscriptions.md) to continue this discussion using the publish/subscribe capabilities of Service Bus topics and subscriptions.</span></span>

